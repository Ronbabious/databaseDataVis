import {
  $,
  ANGLE,
  CHANNELS,
  COLOR,
  COLUMN,
  DESCRIPTION,
  DETAIL,
  FACET,
  FACET_CHANNELS,
  FILL,
  FILLOPACITY,
  GEOJSON,
  GEOPOSITION_CHANNELS,
  HREF,
  KEY,
  LATITUDE,
  LATITUDE2,
  LONGITUDE,
  LONGITUDE2,
  NOMINAL,
  NONPOSITION_CHANNELS,
  NONPOSITION_SCALE_CHANNELS,
  NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES,
  OPACITY,
  ORDER,
  ORDINAL,
  POLAR_POSITION_SCALE_CHANNELS,
  POLAR_POSITION_SCALE_CHANNEL_INDEX,
  POSITION_SCALE_CHANNELS,
  POSITION_SCALE_CHANNEL_INDEX,
  QUANTITATIVE,
  RADIUS,
  RADIUS2,
  ROW,
  SCALE_CATEGORY_INDEX,
  SCALE_CHANNELS,
  SECONDARY_RANGE_CHANNEL,
  SHAPE,
  SIZE,
  STROKE,
  STROKEDASH,
  STROKEOPACITY,
  STROKEWIDTH,
  ScaleType,
  TEMPORAL,
  TEXT,
  THETA,
  THETA2,
  TOOLTIP,
  URL as URL2,
  X,
  X2,
  Y,
  Y2,
  __commonJS,
  __export,
  __require,
  __toModule,
  accessPathDepth,
  accessPathWithDatum,
  array,
  channelScalePropertyIncompatability,
  channelSupportScaleType,
  contains,
  debug,
  deepEqual,
  defaultScaleConfig,
  deleteNestedProperty,
  duplicate,
  entries,
  every,
  fieldIntersection,
  flatAccessWithDatum,
  forEachLeaf,
  getFirstDefined,
  getFullName,
  getMainRangeChannel,
  getOffsetChannel,
  getPositionChannelFromLatLong,
  getPositionScaleChannel,
  getSecondaryRangeChannel,
  getSizeChannel,
  getVgPositionChannel,
  has,
  hasContinuousDomain,
  hasDiscreteDomain,
  hasIntersection,
  hash,
  identity,
  internalField,
  isArray,
  isArray2,
  isBoolean,
  isBoolean2,
  isBoolean3,
  isChannel,
  isColorChannel,
  isContinuousToContinuous,
  isContinuousToDiscrete,
  isDomainUnionWith,
  isEmpty,
  isEqual,
  isExtendedScheme,
  isFieldRange,
  isFunction,
  isGeoPositionChannel,
  isInternalField,
  isNonPositionScaleChannel,
  isNullOrFalse,
  isNumber,
  isNumeric,
  isObject,
  isObject2,
  isParameterDomain,
  isPolarPositionChannel,
  isQuantitative,
  isScaleChannel,
  isSecondaryRangeChannel,
  isSingleDefUnitChannel,
  isString,
  isString2,
  isXorY,
  keys,
  logicalExpr,
  mergeConfig,
  mergeConfig2,
  mergeDeep,
  message_exports,
  normalizeAngle,
  normalizeLogicalComposition,
  omit,
  pick,
  prefixGenerator,
  rangeType,
  removePathFromField,
  replaceAll,
  replacePathInField,
  reset,
  resetIdCounter,
  scaleCompatible,
  scaleTypePrecedence,
  scaleTypeSupportDataType,
  scaleTypeSupportProperty,
  set,
  setEqual,
  some,
  stringify,
  supportLegend,
  supportMark,
  titleCase,
  toSet,
  unique,
  uniqueId,
  vals,
  varName,
  vega_module_exports,
  warn,
  writeConfig
} from "./chunk-HQZFELEC.js";

// node_modules/json-stringify-pretty-compact/index.js
var require_json_stringify_pretty_compact = __commonJS({
  "node_modules/json-stringify-pretty-compact/index.js"(exports, module5) {
    "use strict";
    var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g;
    module5.exports = function stringify4(passedObj, options) {
      var indent, maxLength, replacer2;
      options = options || {};
      indent = JSON.stringify([1], void 0, options.indent === void 0 ? 2 : options.indent).slice(2, -3);
      maxLength = indent === "" ? Infinity : options.maxLength === void 0 ? 80 : options.maxLength;
      replacer2 = options.replacer;
      return function _stringify(obj, currentIndent, reserved) {
        var end, index2, items, key, keyPart, keys3, length2, nextIndent, prettified, start, string, value;
        if (obj && typeof obj.toJSON === "function") {
          obj = obj.toJSON();
        }
        string = JSON.stringify(obj, replacer2);
        if (string === void 0) {
          return string;
        }
        length2 = maxLength - currentIndent.length - reserved;
        if (string.length <= length2) {
          prettified = string.replace(stringOrChar, function(match2, stringLiteral) {
            return stringLiteral || match2 + " ";
          });
          if (prettified.length <= length2) {
            return prettified;
          }
        }
        if (replacer2 != null) {
          obj = JSON.parse(string);
          replacer2 = void 0;
        }
        if (typeof obj === "object" && obj !== null) {
          nextIndent = currentIndent + indent;
          items = [];
          index2 = 0;
          if (Array.isArray(obj)) {
            start = "[";
            end = "]";
            length2 = obj.length;
            for (; index2 < length2; index2++) {
              items.push(_stringify(obj[index2], nextIndent, index2 === length2 - 1 ? 0 : 1) || "null");
            }
          } else {
            start = "{";
            end = "}";
            keys3 = Object.keys(obj);
            length2 = keys3.length;
            for (; index2 < length2; index2++) {
              key = keys3[index2];
              keyPart = JSON.stringify(key) + ": ";
              value = _stringify(obj[key], nextIndent, keyPart.length + (index2 === length2 - 1 ? 0 : 1));
              if (value !== void 0) {
                items.push(keyPart + value);
              }
            }
          }
          if (items.length > 0) {
            return [start, indent + items.join(",\n" + nextIndent), end].join("\n" + currentIndent);
          }
        }
        return string;
      }(passedObj, "", 0);
    };
  }
});

// node_modules/fast-json-patch/module/core.mjs
var core_exports = {};
__export(core_exports, {
  JsonPatchError: () => JsonPatchError,
  _areEquals: () => _areEquals,
  applyOperation: () => applyOperation,
  applyPatch: () => applyPatch,
  applyReducer: () => applyReducer,
  deepClone: () => deepClone,
  getValueByPointer: () => getValueByPointer,
  validate: () => validate,
  validator: () => validator
});

// node_modules/fast-json-patch/module/helpers.mjs
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
  return _hasOwnProperty.call(obj, key);
}
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    var keys3 = new Array(obj.length);
    for (var k = 0; k < keys3.length; k++) {
      keys3[k] = "" + k;
    }
    return keys3;
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keys3 = [];
  for (var i in obj) {
    if (hasOwnProperty(obj, i)) {
      keys3.push(i);
    }
  }
  return keys3;
}
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    case "undefined":
      return null;
    default:
      return obj;
  }
}
function isInteger(str) {
  var i = 0;
  var len = str.length;
  var charCode;
  while (i < len) {
    charCode = str.charCodeAt(i);
    if (charCode >= 48 && charCode <= 57) {
      i++;
      continue;
    }
    return false;
  }
  return true;
}
function escapePathComponent(path) {
  if (path.indexOf("/") === -1 && path.indexOf("~") === -1)
    return path;
  return path.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapePathComponent(path) {
  return path.replace(/~1/g, "/").replace(/~0/g, "~");
}
function hasUndefined(obj) {
  if (obj === void 0) {
    return true;
  }
  if (obj) {
    if (Array.isArray(obj)) {
      for (var i = 0, len = obj.length; i < len; i++) {
        if (hasUndefined(obj[i])) {
          return true;
        }
      }
    } else if (typeof obj === "object") {
      var objKeys = _objectKeys(obj);
      var objKeysLength = objKeys.length;
      for (var i = 0; i < objKeysLength; i++) {
        if (hasUndefined(obj[objKeys[i]])) {
          return true;
        }
      }
    }
  }
  return false;
}
function patchErrorMessageFormatter(message, args) {
  var messageParts = [message];
  for (var key in args) {
    var value = typeof args[key] === "object" ? JSON.stringify(args[key], null, 2) : args[key];
    if (typeof value !== "undefined") {
      messageParts.push(key + ": " + value);
    }
  }
  return messageParts.join("\n");
}
var PatchError = function(_super) {
  __extends(PatchError2, _super);
  function PatchError2(message, name5, index2, operation, tree) {
    var _newTarget = this.constructor;
    var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name5, index: index2, operation, tree })) || this;
    _this.name = name5;
    _this.index = index2;
    _this.operation = operation;
    _this.tree = tree;
    Object.setPrototypeOf(_this, _newTarget.prototype);
    _this.message = patchErrorMessageFormatter(message, { name: name5, index: index2, operation, tree });
    return _this;
  }
  return PatchError2;
}(Error);

// node_modules/fast-json-patch/module/core.mjs
var JsonPatchError = PatchError;
var deepClone = _deepClone;
var objOps = {
  add: function(obj, key, document2) {
    obj[key] = this.value;
    return { newDocument: document2 };
  },
  remove: function(obj, key, document2) {
    var removed = obj[key];
    delete obj[key];
    return { newDocument: document2, removed };
  },
  replace: function(obj, key, document2) {
    var removed = obj[key];
    obj[key] = this.value;
    return { newDocument: document2, removed };
  },
  move: function(obj, key, document2) {
    var removed = getValueByPointer(document2, this.path);
    if (removed) {
      removed = _deepClone(removed);
    }
    var originalValue = applyOperation(document2, { op: "remove", path: this.from }).removed;
    applyOperation(document2, { op: "add", path: this.path, value: originalValue });
    return { newDocument: document2, removed };
  },
  copy: function(obj, key, document2) {
    var valueToCopy = getValueByPointer(document2, this.from);
    applyOperation(document2, { op: "add", path: this.path, value: _deepClone(valueToCopy) });
    return { newDocument: document2 };
  },
  test: function(obj, key, document2) {
    return { newDocument: document2, test: _areEquals(obj[key], this.value) };
  },
  _get: function(obj, key, document2) {
    this.value = obj[key];
    return { newDocument: document2 };
  }
};
var arrOps = {
  add: function(arr, i, document2) {
    if (isInteger(i)) {
      arr.splice(i, 0, this.value);
    } else {
      arr[i] = this.value;
    }
    return { newDocument: document2, index: i };
  },
  remove: function(arr, i, document2) {
    var removedList = arr.splice(i, 1);
    return { newDocument: document2, removed: removedList[0] };
  },
  replace: function(arr, i, document2) {
    var removed = arr[i];
    arr[i] = this.value;
    return { newDocument: document2, removed };
  },
  move: objOps.move,
  copy: objOps.copy,
  test: objOps.test,
  _get: objOps._get
};
function getValueByPointer(document2, pointer) {
  if (pointer == "") {
    return document2;
  }
  var getOriginalDestination = { op: "_get", path: pointer };
  applyOperation(document2, getOriginalDestination);
  return getOriginalDestination.value;
}
function applyOperation(document2, operation, validateOperation, mutateDocument, banPrototypeModifications, index2) {
  if (validateOperation === void 0) {
    validateOperation = false;
  }
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (index2 === void 0) {
    index2 = 0;
  }
  if (validateOperation) {
    if (typeof validateOperation == "function") {
      validateOperation(operation, 0, document2, operation.path);
    } else {
      validator(operation, 0);
    }
  }
  if (operation.path === "") {
    var returnValue = { newDocument: document2 };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document2;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document2, operation.from);
      if (operation.op === "move") {
        returnValue.removed = document2;
      }
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document2, operation.value);
      if (returnValue.test === false) {
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
      }
      returnValue.newDocument = document2;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document2;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document2;
      return returnValue;
    } else {
      if (validateOperation) {
        throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index2, operation, document2);
      } else {
        return returnValue;
      }
    }
  } else {
    if (!mutateDocument) {
      document2 = _deepClone(document2);
    }
    var path = operation.path || "";
    var keys3 = path.split("/");
    var obj = document2;
    var t2 = 1;
    var len = keys3.length;
    var existingPathFragment = void 0;
    var key = void 0;
    var validateFunction = void 0;
    if (typeof validateOperation == "function") {
      validateFunction = validateOperation;
    } else {
      validateFunction = validator;
    }
    while (true) {
      key = keys3[t2];
      if (key && key.indexOf("~") != -1) {
        key = unescapePathComponent(key);
      }
      if (banPrototypeModifications && key == "__proto__") {
        throw new TypeError("JSON-Patch: modifying `__proto__` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      }
      if (validateOperation) {
        if (existingPathFragment === void 0) {
          if (obj[key] === void 0) {
            existingPathFragment = keys3.slice(0, t2).join("/");
          } else if (t2 == len - 1) {
            existingPathFragment = operation.path;
          }
          if (existingPathFragment !== void 0) {
            validateFunction(operation, 0, document2, existingPathFragment);
          }
        }
      }
      t2++;
      if (Array.isArray(obj)) {
        if (key === "-") {
          key = obj.length;
        } else {
          if (validateOperation && !isInteger(key)) {
            throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index2, operation, document2);
          } else if (isInteger(key)) {
            key = ~~key;
          }
        }
        if (t2 >= len) {
          if (validateOperation && operation.op === "add" && key > obj.length) {
            throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index2, operation, document2);
          }
          var returnValue = arrOps[operation.op].call(operation, obj, key, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
          }
          return returnValue;
        }
      } else {
        if (t2 >= len) {
          var returnValue = objOps[operation.op].call(operation, obj, key, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
          }
          return returnValue;
        }
      }
      obj = obj[key];
      if (validateOperation && t2 < len && (!obj || typeof obj !== "object")) {
        throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index2, operation, document2);
      }
    }
  }
}
function applyPatch(document2, patch, validateOperation, mutateDocument, banPrototypeModifications) {
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (validateOperation) {
    if (!Array.isArray(patch)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
  }
  if (!mutateDocument) {
    document2 = _deepClone(document2);
  }
  var results = new Array(patch.length);
  for (var i = 0, length_1 = patch.length; i < length_1; i++) {
    results[i] = applyOperation(document2, patch[i], validateOperation, true, banPrototypeModifications, i);
    document2 = results[i].newDocument;
  }
  results.newDocument = document2;
  return results;
}
function applyReducer(document2, operation, index2) {
  var operationResult = applyOperation(document2, operation);
  if (operationResult.test === false) {
    throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
  }
  return operationResult.newDocument;
}
function validator(operation, index2, document2, existingPathFragment) {
  if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
    throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index2, operation, document2);
  } else if (!objOps[operation.op]) {
    throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index2, operation, document2);
  } else if (typeof operation.path !== "string") {
    throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index2, operation, document2);
  } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
    throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index2, operation, document2);
  } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
    throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index2, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index2, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index2, operation, document2);
  } else if (document2) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
        throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index2, operation, document2);
      }
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment) {
        throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index2, operation, document2);
      }
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = { op: "_get", path: operation.from, value: void 0 };
      var error2 = validate([existingValue], document2);
      if (error2 && error2.name === "OPERATION_PATH_UNRESOLVABLE") {
        throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index2, operation, document2);
      }
    }
  }
}
function validate(sequence, document2, externalValidator) {
  try {
    if (!Array.isArray(sequence)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
    if (document2) {
      applyPatch(_deepClone(document2), _deepClone(sequence), externalValidator || true);
    } else {
      externalValidator = externalValidator || validator;
      for (var i = 0; i < sequence.length; i++) {
        externalValidator(sequence[i], i, document2, void 0);
      }
    }
  } catch (e2) {
    if (e2 instanceof JsonPatchError) {
      return e2;
    } else {
      throw e2;
    }
  }
}
function _areEquals(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length2, key;
    if (arrA && arrB) {
      length2 = a.length;
      if (length2 != b.length)
        return false;
      for (i = length2; i-- !== 0; )
        if (!_areEquals(a[i], b[i]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var keys3 = Object.keys(a);
    length2 = keys3.length;
    if (length2 !== Object.keys(b).length)
      return false;
    for (i = length2; i-- !== 0; )
      if (!b.hasOwnProperty(keys3[i]))
        return false;
    for (i = length2; i-- !== 0; ) {
      key = keys3[i];
      if (!_areEquals(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
}

// node_modules/fast-json-patch/module/duplex.mjs
var duplex_exports = {};
__export(duplex_exports, {
  compare: () => compare,
  generate: () => generate,
  observe: () => observe,
  unobserve: () => unobserve
});
var beforeDict = new WeakMap();
var Mirror = function() {
  function Mirror2(obj) {
    this.observers = new Map();
    this.obj = obj;
  }
  return Mirror2;
}();
var ObserverInfo = function() {
  function ObserverInfo2(callback, observer) {
    this.callback = callback;
    this.observer = observer;
  }
  return ObserverInfo2;
}();
function getMirror(obj) {
  return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
  return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
  mirror.observers.delete(observer.callback);
}
function unobserve(root, observer) {
  observer.unobserve();
}
function observe(obj, callback) {
  var patches = [];
  var observer;
  var mirror = getMirror(obj);
  if (!mirror) {
    mirror = new Mirror(obj);
    beforeDict.set(obj, mirror);
  } else {
    var observerInfo = getObserverFromMirror(mirror, callback);
    observer = observerInfo && observerInfo.observer;
  }
  if (observer) {
    return observer;
  }
  observer = {};
  mirror.value = _deepClone(obj);
  if (callback) {
    observer.callback = callback;
    observer.next = null;
    var dirtyCheck = function() {
      generate(observer);
    };
    var fastCheck = function() {
      clearTimeout(observer.next);
      observer.next = setTimeout(dirtyCheck);
    };
    if (typeof window !== "undefined") {
      window.addEventListener("mouseup", fastCheck);
      window.addEventListener("keyup", fastCheck);
      window.addEventListener("mousedown", fastCheck);
      window.addEventListener("keydown", fastCheck);
      window.addEventListener("change", fastCheck);
    }
  }
  observer.patches = patches;
  observer.object = obj;
  observer.unobserve = function() {
    generate(observer);
    clearTimeout(observer.next);
    removeObserverFromMirror(mirror, observer);
    if (typeof window !== "undefined") {
      window.removeEventListener("mouseup", fastCheck);
      window.removeEventListener("keyup", fastCheck);
      window.removeEventListener("mousedown", fastCheck);
      window.removeEventListener("keydown", fastCheck);
      window.removeEventListener("change", fastCheck);
    }
  };
  mirror.observers.set(callback, new ObserverInfo(callback, observer));
  return observer;
}
function generate(observer, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var mirror = beforeDict.get(observer.object);
  _generate(mirror.value, observer.object, observer.patches, "", invertible);
  if (observer.patches.length) {
    applyPatch(mirror.value, observer.patches);
  }
  var temp = observer.patches;
  if (temp.length > 0) {
    observer.patches = [];
    if (observer.callback) {
      observer.callback(temp);
    }
  }
  return temp;
}
function _generate(mirror, obj, patches, path, invertible) {
  if (obj === mirror) {
    return;
  }
  if (typeof obj.toJSON === "function") {
    obj = obj.toJSON();
  }
  var newKeys = _objectKeys(obj);
  var oldKeys = _objectKeys(mirror);
  var changed = false;
  var deleted = false;
  for (var t2 = oldKeys.length - 1; t2 >= 0; t2--) {
    var key = oldKeys[t2];
    var oldVal = mirror[key];
    if (hasOwnProperty(obj, key) && !(obj[key] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
      var newVal = obj[key];
      if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
        _generate(oldVal, newVal, patches, path + "/" + escapePathComponent(key), invertible);
      } else {
        if (oldVal !== newVal) {
          changed = true;
          if (invertible) {
            patches.push({ op: "test", path: path + "/" + escapePathComponent(key), value: _deepClone(oldVal) });
          }
          patches.push({ op: "replace", path: path + "/" + escapePathComponent(key), value: _deepClone(newVal) });
        }
      }
    } else if (Array.isArray(mirror) === Array.isArray(obj)) {
      if (invertible) {
        patches.push({ op: "test", path: path + "/" + escapePathComponent(key), value: _deepClone(oldVal) });
      }
      patches.push({ op: "remove", path: path + "/" + escapePathComponent(key) });
      deleted = true;
    } else {
      if (invertible) {
        patches.push({ op: "test", path, value: mirror });
      }
      patches.push({ op: "replace", path, value: obj });
      changed = true;
    }
  }
  if (!deleted && newKeys.length == oldKeys.length) {
    return;
  }
  for (var t2 = 0; t2 < newKeys.length; t2++) {
    var key = newKeys[t2];
    if (!hasOwnProperty(mirror, key) && obj[key] !== void 0) {
      patches.push({ op: "add", path: path + "/" + escapePathComponent(key), value: _deepClone(obj[key]) });
    }
  }
}
function compare(tree1, tree2, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var patches = [];
  _generate(tree1, tree2, patches, "", invertible);
  return patches;
}

// node_modules/fast-json-patch/index.mjs
var fast_json_patch_default = Object.assign({}, core_exports, duplex_exports, {
  JsonPatchError: PatchError,
  deepClone: _deepClone,
  escapePathComponent,
  unescapePathComponent
});

// node_modules/vega-embed/build/vega-embed.module.js
var import_json_stringify_pretty_compact = __toModule(require_json_stringify_pretty_compact());

// node_modules/vega-interpreter/build/vega-interpreter.module.js
function adjustSpatial(item, encode13, swap) {
  let t2;
  if (encode13.x2) {
    if (encode13.x) {
      if (swap && item.x > item.x2) {
        t2 = item.x;
        item.x = item.x2;
        item.x2 = t2;
      }
      item.width = item.x2 - item.x;
    } else {
      item.x = item.x2 - (item.width || 0);
    }
  }
  if (encode13.xc) {
    item.x = item.xc - (item.width || 0) / 2;
  }
  if (encode13.y2) {
    if (encode13.y) {
      if (swap && item.y > item.y2) {
        t2 = item.y;
        item.y = item.y2;
        item.y2 = t2;
      }
      item.height = item.y2 - item.y;
    } else {
      item.y = item.y2 - (item.height || 0);
    }
  }
  if (encode13.yc) {
    item.y = item.yc - (item.height || 0) / 2;
  }
}
var Constants = {
  NaN: NaN,
  E: Math.E,
  LN2: Math.LN2,
  LN10: Math.LN10,
  LOG2E: Math.LOG2E,
  LOG10E: Math.LOG10E,
  PI: Math.PI,
  SQRT1_2: Math.SQRT1_2,
  SQRT2: Math.SQRT2,
  MIN_VALUE: Number.MIN_VALUE,
  MAX_VALUE: Number.MAX_VALUE
};
var Ops = {
  "*": (a, b) => a * b,
  "+": (a, b) => a + b,
  "-": (a, b) => a - b,
  "/": (a, b) => a / b,
  "%": (a, b) => a % b,
  ">": (a, b) => a > b,
  "<": (a, b) => a < b,
  "<=": (a, b) => a <= b,
  ">=": (a, b) => a >= b,
  "==": (a, b) => a == b,
  "!=": (a, b) => a != b,
  "===": (a, b) => a === b,
  "!==": (a, b) => a !== b,
  "&": (a, b) => a & b,
  "|": (a, b) => a | b,
  "^": (a, b) => a ^ b,
  "<<": (a, b) => a << b,
  ">>": (a, b) => a >> b,
  ">>>": (a, b) => a >>> b
};
var Unary = {
  "+": (a) => +a,
  "-": (a) => -a,
  "~": (a) => ~a,
  "!": (a) => !a
};
var slice = Array.prototype.slice;
var apply = (m, args, cast) => {
  const obj = cast ? cast(args[0]) : args[0];
  return obj[m].apply(obj, slice.call(args, 1));
};
var datetime = (y, m, d, H, M, S, ms) => new Date(y, m || 0, d != null ? d : 1, H || 0, M || 0, S || 0, ms || 0);
var Functions = {
  isNaN: Number.isNaN,
  isFinite: Number.isFinite,
  abs: Math.abs,
  acos: Math.acos,
  asin: Math.asin,
  atan: Math.atan,
  atan2: Math.atan2,
  ceil: Math.ceil,
  cos: Math.cos,
  exp: Math.exp,
  floor: Math.floor,
  log: Math.log,
  max: Math.max,
  min: Math.min,
  pow: Math.pow,
  random: Math.random,
  round: Math.round,
  sin: Math.sin,
  sqrt: Math.sqrt,
  tan: Math.tan,
  clamp: (a, b, c) => Math.max(b, Math.min(c, a)),
  now: Date.now,
  utc: Date.UTC,
  datetime,
  date: (d) => new Date(d).getDate(),
  day: (d) => new Date(d).getDay(),
  year: (d) => new Date(d).getFullYear(),
  month: (d) => new Date(d).getMonth(),
  hours: (d) => new Date(d).getHours(),
  minutes: (d) => new Date(d).getMinutes(),
  seconds: (d) => new Date(d).getSeconds(),
  milliseconds: (d) => new Date(d).getMilliseconds(),
  time: (d) => new Date(d).getTime(),
  timezoneoffset: (d) => new Date(d).getTimezoneOffset(),
  utcdate: (d) => new Date(d).getUTCDate(),
  utcday: (d) => new Date(d).getUTCDay(),
  utcyear: (d) => new Date(d).getUTCFullYear(),
  utcmonth: (d) => new Date(d).getUTCMonth(),
  utchours: (d) => new Date(d).getUTCHours(),
  utcminutes: (d) => new Date(d).getUTCMinutes(),
  utcseconds: (d) => new Date(d).getUTCSeconds(),
  utcmilliseconds: (d) => new Date(d).getUTCMilliseconds(),
  length: (x) => x.length,
  join: function() {
    return apply("join", arguments);
  },
  indexof: function() {
    return apply("indexOf", arguments);
  },
  lastindexof: function() {
    return apply("lastIndexOf", arguments);
  },
  slice: function() {
    return apply("slice", arguments);
  },
  reverse: (x) => x.slice().reverse(),
  parseFloat,
  parseInt,
  upper: (x) => String(x).toUpperCase(),
  lower: (x) => String(x).toLowerCase(),
  substring: function() {
    return apply("substring", arguments, String);
  },
  split: function() {
    return apply("split", arguments, String);
  },
  replace: function() {
    return apply("replace", arguments, String);
  },
  trim: (x) => String(x).trim(),
  regexp: RegExp,
  test: (r, t2) => RegExp(r).test(t2)
};
var EventFunctions = ["view", "item", "group", "xy", "x", "y"];
var Visitors = {
  Literal: ($2, n) => n.value,
  Identifier: ($2, n) => {
    const id = n.name;
    return $2.memberDepth > 0 ? id : id === "datum" ? $2.datum : id === "event" ? $2.event : id === "item" ? $2.item : Constants[id] || $2.params["$" + id];
  },
  MemberExpression: ($2, n) => {
    const d = !n.computed, o = $2(n.object);
    if (d)
      $2.memberDepth += 1;
    const p = $2(n.property);
    if (d)
      $2.memberDepth -= 1;
    return o[p];
  },
  CallExpression: ($2, n) => {
    const args = n.arguments;
    let name5 = n.callee.name;
    if (name5.startsWith("_")) {
      name5 = name5.slice(1);
    }
    return name5 === "if" ? $2(args[0]) ? $2(args[1]) : $2(args[2]) : ($2.fn[name5] || Functions[name5]).apply($2.fn, args.map($2));
  },
  ArrayExpression: ($2, n) => n.elements.map($2),
  BinaryExpression: ($2, n) => Ops[n.operator]($2(n.left), $2(n.right)),
  UnaryExpression: ($2, n) => Unary[n.operator]($2(n.argument)),
  ConditionalExpression: ($2, n) => $2(n.test) ? $2(n.consequent) : $2(n.alternate),
  LogicalExpression: ($2, n) => n.operator === "&&" ? $2(n.left) && $2(n.right) : $2(n.left) || $2(n.right),
  ObjectExpression: ($2, n) => n.properties.reduce((o, p) => {
    $2.memberDepth += 1;
    const k = $2(p.key);
    $2.memberDepth -= 1;
    o[k] = $2(p.value);
    return o;
  }, {})
};
function interpret(ast, fn, params, datum, event, item) {
  const $2 = (n) => Visitors[n.type]($2, n);
  $2.memberDepth = 0;
  $2.fn = Object.create(fn);
  $2.params = params;
  $2.datum = datum;
  $2.event = event;
  $2.item = item;
  EventFunctions.forEach((f) => $2.fn[f] = (...args) => event.vega[f](...args));
  return $2(ast);
}
var expression = {
  operator(ctx, expr) {
    const ast = expr.ast, fn = ctx.functions;
    return (_) => interpret(ast, fn, _);
  },
  parameter(ctx, expr) {
    const ast = expr.ast, fn = ctx.functions;
    return (datum, _) => interpret(ast, fn, _, datum);
  },
  event(ctx, expr) {
    const ast = expr.ast, fn = ctx.functions;
    return (event) => interpret(ast, fn, void 0, void 0, event);
  },
  handler(ctx, expr) {
    const ast = expr.ast, fn = ctx.functions;
    return (_, event) => {
      const datum = event.item && event.item.datum;
      return interpret(ast, fn, _, datum, event);
    };
  },
  encode(ctx, encode13) {
    const {
      marktype,
      channels
    } = encode13, fn = ctx.functions, swap = marktype === "group" || marktype === "image" || marktype === "rect";
    return (item, _) => {
      const datum = item.datum;
      let m = 0, v;
      for (const name5 in channels) {
        v = interpret(channels[name5].ast, fn, _, datum, void 0, item);
        if (item[name5] !== v) {
          item[name5] = v;
          m = 1;
        }
      }
      if (marktype !== "rule") {
        adjustSpatial(item, channels, swap);
      }
      return m;
    };
  }
};

// node_modules/vega-lite/build/src/index.js
var src_exports = {};
__export(src_exports, {
  accessPathDepth: () => accessPathDepth,
  accessPathWithDatum: () => accessPathWithDatum,
  compile: () => compile,
  contains: () => contains,
  deepEqual: () => deepEqual,
  deleteNestedProperty: () => deleteNestedProperty,
  duplicate: () => duplicate,
  entries: () => entries,
  every: () => every,
  fieldIntersection: () => fieldIntersection,
  flatAccessWithDatum: () => flatAccessWithDatum,
  getFirstDefined: () => getFirstDefined,
  hasIntersection: () => hasIntersection,
  hash: () => hash,
  internalField: () => internalField,
  isBoolean: () => isBoolean3,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isInternalField: () => isInternalField,
  isNullOrFalse: () => isNullOrFalse,
  isNumeric: () => isNumeric,
  keys: () => keys,
  logicalExpr: () => logicalExpr,
  mergeDeep: () => mergeDeep,
  normalize: () => normalize,
  normalizeAngle: () => normalizeAngle,
  omit: () => omit,
  pick: () => pick,
  prefixGenerator: () => prefixGenerator,
  removePathFromField: () => removePathFromField,
  replaceAll: () => replaceAll,
  replacePathInField: () => replacePathInField,
  resetIdCounter: () => resetIdCounter,
  setEqual: () => setEqual,
  some: () => some,
  stringify: () => stringify,
  titleCase: () => titleCase,
  unique: () => unique,
  uniqueId: () => uniqueId,
  vals: () => vals,
  varName: () => varName,
  version: () => version2
});

// node_modules/vega-lite/build/package.json
var name = "vega-lite";
var author = 'Dominik Moritz, Kanit "Ham" Wongsuphasawat, Arvind Satyanarayan, Jeffrey Heer';
var version = "5.1.1";
var collaborators = [
  "Kanit Wongsuphasawat (http://kanitw.yellowpigz.com)",
  "Dominik Moritz (https://www.domoritz.de)",
  "Arvind Satyanarayan (https://arvindsatya.com)",
  "Jeffrey Heer (https://jheer.org)"
];
var homepage = "https://vega.github.io/vega-lite/";
var description = "Vega-Lite is a concise high-level language for interactive visualization.";
var main = "build/vega-lite.js";
var unpkg = "build/vega-lite.min.js";
var jsdelivr = "build/vega-lite.min.js";
var module = "build/src/index";
var types = "build/src/index.d.ts";
var bin = {
  vl2png: "./bin/vl2png",
  vl2svg: "./bin/vl2svg",
  vl2pdf: "./bin/vl2pdf",
  vl2vg: "./bin/vl2vg"
};
var directories = {
  test: "test"
};
var files = [
  "bin",
  "build",
  "src",
  "vega-lite*",
  "tsconfig.json"
];
var scripts = {
  changelog: "conventional-changelog -p angular -r 2",
  prebuild: "yarn clean:build",
  build: "yarn build:only",
  "build:only": "tsc -p tsconfig.build.json && rollup -c",
  "prebuild:examples": "yarn build:only",
  "build:examples": "yarn data && TZ=America/Los_Angeles scripts/build-examples.sh",
  "prebuild:examples-full": "yarn build:only",
  "build:examples-full": "TZ=America/Los_Angeles scripts/build-examples.sh 1",
  "build:example": "TZ=America/Los_Angeles scripts/build-example.sh",
  "build:toc": "yarn build:jekyll && scripts/generate-toc",
  "build:site": "rollup -c site/rollup.config.js",
  "build:jekyll": "pushd site && bundle exec jekyll build -q && popd",
  "build:versions": "scripts/update-version.sh",
  clean: "yarn clean:build && del-cli 'site/data/*' 'examples/compiled/*.png' && find site/examples ! -name 'index.md' ! -name 'data' -type f -delete",
  "clean:build": "del-cli 'build/*' !build/vega-lite-schema.json",
  "predeploy:site": "yarn presite",
  "deploy:site": "gh-pages -d site",
  data: "rsync -r node_modules/vega-datasets/data/* site/data",
  schema: "mkdir -p build && ts-json-schema-generator -f tsconfig.json -p src/index.ts -t TopLevelSpec --no-type-check --no-ref-encode > build/vega-lite-schema.json && yarn renameschema && cp build/vega-lite-schema.json site/_data/",
  renameschema: "scripts/rename-schema.sh",
  presite: "yarn data && yarn schema && yarn build:site && yarn build:versions && scripts/create-example-pages.sh",
  site: "yarn site:only",
  "site:only": "pushd site && bundle exec jekyll serve -I -l && popd",
  prettierbase: "prettier '**/*.{md,css,yml}'",
  eslintbase: "eslint .",
  format: "yarn eslintbase --fix && yarn prettierbase --write",
  lint: "yarn eslintbase && yarn prettierbase --check",
  jest: "NODE_OPTIONS=--experimental-vm-modules npx jest",
  test: "yarn jest test/ && yarn lint && yarn schema && yarn jest examples/ && yarn test:runtime",
  "test:cover": "yarn jest --collectCoverage test/",
  "test:inspect": "node --inspect-brk --experimental-vm-modules ./node_modules/.bin/jest --runInBand test",
  "test:runtime": "NODE_OPTIONS=--experimental-vm-modules TZ=America/Los_Angeles npx jest test-runtime/ --config test-runtime/jest-config.json",
  "test:runtime:generate": "yarn build:only && del-cli test-runtime/resources && VL_GENERATE_TESTS=true yarn test:runtime",
  watch: "tsc -p tsconfig.build.json -w",
  "watch:site": "yarn build:site -w",
  "watch:test": "yarn jest --watch test/"
};
var repository = {
  type: "git",
  url: "https://github.com/vega/vega-lite.git"
};
var license = "BSD-3-Clause";
var bugs = {
  url: "https://github.com/vega/vega-lite/issues"
};
var devDependencies = {
  "@babel/core": "^7.15.0",
  "@babel/preset-env": "^7.15.0",
  "@babel/preset-typescript": "^7.15.0",
  "@rollup/plugin-babel": "^5.3.0",
  "@rollup/plugin-commonjs": "^20.0.0",
  "@rollup/plugin-json": "^4.1.0",
  "@rollup/plugin-node-resolve": "^13.0.4",
  "@types/chai": "^4.2.21",
  "@types/d3": "^7.0.0",
  "@types/jest": "^27.0.1",
  "@types/mkdirp": "^1.0.2",
  "@types/pako": "^1.0.2",
  "@typescript-eslint/eslint-plugin": "^4.29.2",
  "@typescript-eslint/parser": "^4.29.2",
  ajv: "^8.6.2",
  "ajv-formats": "^2.1.1",
  chai: "^4.3.4",
  cheerio: "^1.0.0-rc.10",
  "conventional-changelog-cli": "^2.1.1",
  d3: "^7.0.1",
  "del-cli": "^4.0.1",
  eslint: "^7.32.0",
  "eslint-config-prettier": "^8.3.0",
  "eslint-plugin-jest": "^24.4.0",
  "eslint-plugin-prettier": "^4.0.0",
  "gh-pages": "^3.2.3",
  "highlight.js": "^11.2.0",
  jest: "^27.0.6",
  "jest-dev-server": "^5.0.3",
  mkdirp: "^1.0.4",
  pako: "^2.0.4",
  prettier: "^2.3.2",
  puppeteer: "^10.2.0",
  rollup: "^2.56.3",
  "rollup-plugin-bundle-size": "^1.0.3",
  "rollup-plugin-sourcemaps": "^0.6.3",
  "rollup-plugin-terser": "^7.0.2",
  serve: "^12.0.0",
  terser: "^5.7.1",
  "ts-jest": "^27.0.5",
  "ts-json-schema-generator": "^0.95.0",
  typescript: "~4.4.2",
  "vega-cli": "^5.20.2",
  "vega-datasets": "~2.2.0",
  "vega-embed": "^6.18.2",
  "vega-tooltip": "^0.27.0",
  "yaml-front-matter": "^4.1.1"
};
var dependencies = {
  "@types/clone": "~2.1.1",
  "array-flat-polyfill": "^1.0.1",
  clone: "~2.1.2",
  "fast-deep-equal": "~3.1.3",
  "fast-json-stable-stringify": "~2.1.0",
  "json-stringify-pretty-compact": "~3.0.0",
  tslib: "~2.3.1",
  "vega-event-selector": "~2.0.6",
  "vega-expression": "~4.0.1",
  "vega-util": "~1.16.1",
  yargs: "~17.1.1"
};
var peerDependencies = {
  vega: "^5.20.2"
};
var engines = {
  node: ">=12"
};
var package_default = {
  name,
  author,
  version,
  collaborators,
  homepage,
  description,
  main,
  unpkg,
  jsdelivr,
  module,
  types,
  bin,
  directories,
  files,
  scripts,
  repository,
  license,
  bugs,
  devDependencies,
  dependencies,
  peerDependencies,
  engines
};

// node_modules/vega-lite/build/src/aggregate.js
var AGGREGATE_OP_INDEX = {
  argmax: 1,
  argmin: 1,
  average: 1,
  count: 1,
  distinct: 1,
  product: 1,
  max: 1,
  mean: 1,
  median: 1,
  min: 1,
  missing: 1,
  q1: 1,
  q3: 1,
  ci0: 1,
  ci1: 1,
  stderr: 1,
  stdev: 1,
  stdevp: 1,
  sum: 1,
  valid: 1,
  values: 1,
  variance: 1,
  variancep: 1
};
var MULTIDOMAIN_SORT_OP_INDEX = {
  count: 1,
  min: 1,
  max: 1
};
function isArgminDef(a) {
  return !!a && !!a["argmin"];
}
function isArgmaxDef(a) {
  return !!a && !!a["argmax"];
}
var AGGREGATE_OPS = keys(AGGREGATE_OP_INDEX);
function isAggregateOp(a) {
  return isString2(a) && !!AGGREGATE_OP_INDEX[a];
}
var COUNTING_OPS = ["count", "valid", "missing", "distinct"];
function isCountingAggregateOp(aggregate) {
  return isString2(aggregate) && contains(COUNTING_OPS, aggregate);
}
function isMinMaxOp(aggregate) {
  return isString2(aggregate) && contains(["min", "max"], aggregate);
}
var SUM_OPS = ["count", "sum", "distinct", "valid", "missing"];
var SHARED_DOMAIN_OPS = ["mean", "average", "median", "q1", "q3", "min", "max"];
var SHARED_DOMAIN_OP_INDEX = toSet(SHARED_DOMAIN_OPS);

// node_modules/vega-lite/build/src/bin.js
function binToString(bin2) {
  if (isBoolean2(bin2)) {
    bin2 = normalizeBin(bin2, void 0);
  }
  return "bin" + keys(bin2).map((p) => isParameterExtent(bin2[p]) ? varName(`_${p}_${entries(bin2[p])}`) : varName(`_${p}_${bin2[p]}`)).join("");
}
function isBinning(bin2) {
  return bin2 === true || isBinParams(bin2) && !bin2.binned;
}
function isBinned(bin2) {
  return bin2 === "binned" || isBinParams(bin2) && bin2.binned === true;
}
function isBinParams(bin2) {
  return isObject2(bin2);
}
function isParameterExtent(extent) {
  return extent === null || extent === void 0 ? void 0 : extent["param"];
}
function autoMaxBins(channel) {
  switch (channel) {
    case ROW:
    case COLUMN:
    case SIZE:
    case COLOR:
    case FILL:
    case STROKE:
    case STROKEWIDTH:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case SHAPE:
      return 6;
    case STROKEDASH:
      return 4;
    default:
      return 10;
  }
}

// node_modules/vega-lite/build/src/expr.js
function isExprRef(o) {
  return o && !!o["expr"];
}
function replaceExprRef(index2) {
  const props = keys(index2 || {});
  const newIndex = {};
  for (const prop of props) {
    newIndex[prop] = signalRefOrValue(index2[prop]);
  }
  return newIndex;
}

// node_modules/vega-lite/build/src/title.js
var __rest = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function extractTitleConfig(titleConfig) {
  const {
    anchor,
    frame,
    offset,
    orient: orient2,
    angle,
    limit,
    color: color2,
    subtitleColor,
    subtitleFont,
    subtitleFontSize,
    subtitleFontStyle,
    subtitleFontWeight,
    subtitleLineHeight,
    subtitlePadding
  } = titleConfig, rest = __rest(titleConfig, ["anchor", "frame", "offset", "orient", "angle", "limit", "color", "subtitleColor", "subtitleFont", "subtitleFontSize", "subtitleFontStyle", "subtitleFontWeight", "subtitleLineHeight", "subtitlePadding"]);
  const titleMarkConfig = Object.assign(Object.assign({}, rest), color2 ? { fill: color2 } : {});
  const nonMarkTitleProperties = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, anchor ? { anchor } : {}), frame ? { frame } : {}), offset ? { offset } : {}), orient2 ? { orient: orient2 } : {}), angle !== void 0 ? { angle } : {}), limit !== void 0 ? { limit } : {});
  const subtitle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, subtitleColor ? { subtitleColor } : {}), subtitleFont ? { subtitleFont } : {}), subtitleFontSize ? { subtitleFontSize } : {}), subtitleFontStyle ? { subtitleFontStyle } : {}), subtitleFontWeight ? { subtitleFontWeight } : {}), subtitleLineHeight ? { subtitleLineHeight } : {}), subtitlePadding ? { subtitlePadding } : {});
  const subtitleMarkConfig = pick(titleConfig, ["align", "baseline", "dx", "dy", "limit"]);
  return { titleMarkConfig, subtitleMarkConfig, nonMarkTitleProperties, subtitle };
}
function isText(v) {
  return isString2(v) || isArray2(v) && isString2(v[0]);
}

// node_modules/vega-lite/build/src/vega.schema.js
function isSignalRef(o) {
  return o && !!o["signal"];
}
function isVgRangeStep(range2) {
  return !!range2["step"];
}
function isDataRefUnionedDomain(domain2) {
  if (!isArray2(domain2)) {
    return "fields" in domain2 && !("data" in domain2);
  }
  return false;
}
function isFieldRefUnionDomain(domain2) {
  if (!isArray2(domain2)) {
    return "fields" in domain2 && "data" in domain2;
  }
  return false;
}
function isDataRefDomain(domain2) {
  if (!isArray2(domain2)) {
    return "field" in domain2 && "data" in domain2;
  }
  return false;
}
var VG_MARK_CONFIG_INDEX = {
  aria: 1,
  description: 1,
  ariaRole: 1,
  ariaRoleDescription: 1,
  blend: 1,
  opacity: 1,
  fill: 1,
  fillOpacity: 1,
  stroke: 1,
  strokeCap: 1,
  strokeWidth: 1,
  strokeOpacity: 1,
  strokeDash: 1,
  strokeDashOffset: 1,
  strokeJoin: 1,
  strokeOffset: 1,
  strokeMiterLimit: 1,
  startAngle: 1,
  endAngle: 1,
  padAngle: 1,
  innerRadius: 1,
  outerRadius: 1,
  size: 1,
  shape: 1,
  interpolate: 1,
  tension: 1,
  orient: 1,
  align: 1,
  baseline: 1,
  text: 1,
  dir: 1,
  dx: 1,
  dy: 1,
  ellipsis: 1,
  limit: 1,
  radius: 1,
  theta: 1,
  angle: 1,
  font: 1,
  fontSize: 1,
  fontWeight: 1,
  fontStyle: 1,
  lineBreak: 1,
  lineHeight: 1,
  cursor: 1,
  href: 1,
  tooltip: 1,
  cornerRadius: 1,
  cornerRadiusTopLeft: 1,
  cornerRadiusTopRight: 1,
  cornerRadiusBottomLeft: 1,
  cornerRadiusBottomRight: 1,
  aspect: 1,
  width: 1,
  height: 1,
  url: 1,
  smooth: 1
};
var VG_MARK_CONFIGS = keys(VG_MARK_CONFIG_INDEX);
var VG_MARK_INDEX = {
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
var VG_CORNERRADIUS_CHANNELS = [
  "cornerRadius",
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight"
];

// node_modules/vega-lite/build/src/compile/common.js
var __rest2 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function signalOrValueRefWithCondition(val) {
  const condition = isArray2(val.condition) ? val.condition.map(conditionalSignalRefOrValue) : conditionalSignalRefOrValue(val.condition);
  return Object.assign(Object.assign({}, signalRefOrValue(val)), { condition });
}
function signalRefOrValue(value) {
  if (isExprRef(value)) {
    const { expr } = value, rest = __rest2(value, ["expr"]);
    return Object.assign({ signal: expr }, rest);
  }
  return value;
}
function conditionalSignalRefOrValue(value) {
  if (isExprRef(value)) {
    const { expr } = value, rest = __rest2(value, ["expr"]);
    return Object.assign({ signal: expr }, rest);
  }
  return value;
}
function signalOrValueRef(value) {
  if (isExprRef(value)) {
    const { expr } = value, rest = __rest2(value, ["expr"]);
    return Object.assign({ signal: expr }, rest);
  }
  if (isSignalRef(value)) {
    return value;
  }
  return value !== void 0 ? { value } : void 0;
}
function exprFromValueOrSignalRef(ref5) {
  if (isSignalRef(ref5)) {
    return ref5.signal;
  }
  return $(ref5.value);
}
function signalOrStringValue(v) {
  if (isSignalRef(v)) {
    return v.signal;
  }
  return v == null ? null : $(v);
}
function applyMarkConfig(e2, model, propsList) {
  for (const property of propsList) {
    const value = getMarkConfig(property, model.markDef, model.config);
    if (value !== void 0) {
      e2[property] = signalOrValueRef(value);
    }
  }
  return e2;
}
function getStyles(mark3) {
  var _a;
  return [].concat(mark3.type, (_a = mark3.style) !== null && _a !== void 0 ? _a : []);
}
function getMarkPropOrConfig(channel, mark3, config, opt = {}) {
  const { vgChannel, ignoreVgConfig } = opt;
  if (vgChannel && mark3[vgChannel] !== void 0) {
    return mark3[vgChannel];
  } else if (mark3[channel] !== void 0) {
    return mark3[channel];
  } else if (ignoreVgConfig && (!vgChannel || vgChannel === channel)) {
    return void 0;
  }
  return getMarkConfig(channel, mark3, config, opt);
}
function getMarkConfig(channel, mark3, config, { vgChannel } = {}) {
  return getFirstDefined(vgChannel ? getMarkStyleConfig(channel, mark3, config.style) : void 0, getMarkStyleConfig(channel, mark3, config.style), vgChannel ? config[mark3.type][vgChannel] : void 0, config[mark3.type][channel], vgChannel ? config.mark[vgChannel] : config.mark[channel]);
}
function getMarkStyleConfig(prop, mark3, styleConfigIndex) {
  return getStyleConfig(prop, getStyles(mark3), styleConfigIndex);
}
function getStyleConfig(p, styles, styleConfigIndex) {
  styles = array(styles);
  let value;
  for (const style of styles) {
    const styleConfig = styleConfigIndex[style];
    if (styleConfig && styleConfig[p] !== void 0) {
      value = styleConfig[p];
    }
  }
  return value;
}
function sortParams(orderDef, fieldRefOption) {
  return array(orderDef).reduce((s, orderChannelDef) => {
    var _a;
    s.field.push(vgField(orderChannelDef, fieldRefOption));
    s.order.push((_a = orderChannelDef.sort) !== null && _a !== void 0 ? _a : "ascending");
    return s;
  }, { field: [], order: [] });
}
function mergeTitleFieldDefs(f1, f2) {
  const merged = [...f1];
  f2.forEach((fdToMerge) => {
    for (const fieldDef1 of merged) {
      if (deepEqual(fieldDef1, fdToMerge)) {
        return;
      }
    }
    merged.push(fdToMerge);
  });
  return merged;
}
function mergeTitle(title1, title2) {
  if (deepEqual(title1, title2) || !title2) {
    return title1;
  } else if (!title1) {
    return title2;
  } else {
    return [...array(title1), ...array(title2)].join(", ");
  }
}
function mergeTitleComponent(v1, v2) {
  const v1Val = v1.value;
  const v2Val = v2.value;
  if (v1Val == null || v2Val === null) {
    return {
      explicit: v1.explicit,
      value: null
    };
  } else if ((isText(v1Val) || isSignalRef(v1Val)) && (isText(v2Val) || isSignalRef(v2Val))) {
    return {
      explicit: v1.explicit,
      value: mergeTitle(v1Val, v2Val)
    };
  } else if (isText(v1Val) || isSignalRef(v1Val)) {
    return {
      explicit: v1.explicit,
      value: v1Val
    };
  } else if (isText(v2Val) || isSignalRef(v2Val)) {
    return {
      explicit: v1.explicit,
      value: v2Val
    };
  } else if (!isText(v1Val) && !isSignalRef(v1Val) && !isText(v2Val) && !isSignalRef(v2Val)) {
    return {
      explicit: v1.explicit,
      value: mergeTitleFieldDefs(v1Val, v2Val)
    };
  }
  throw new Error("It should never reach here");
}

// node_modules/vega-lite/build/src/datetime.js
function isDateTime(o) {
  if (o && isObject2(o)) {
    for (const part of TIMEUNIT_PARTS) {
      if (part in o) {
        return true;
      }
    }
  }
  return false;
}
var MONTHS = [
  "january",
  "february",
  "march",
  "april",
  "may",
  "june",
  "july",
  "august",
  "september",
  "october",
  "november",
  "december"
];
var SHORT_MONTHS = MONTHS.map((m) => m.substr(0, 3));
var DAYS = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
var SHORT_DAYS = DAYS.map((d) => d.substr(0, 3));
function normalizeQuarter(q) {
  if (isNumeric(q)) {
    q = +q;
  }
  if (isNumber(q)) {
    if (q > 4) {
      warn(message_exports.invalidTimeUnit("quarter", q));
    }
    return q - 1;
  } else {
    throw new Error(message_exports.invalidTimeUnit("quarter", q));
  }
}
function normalizeMonth(m) {
  if (isNumeric(m)) {
    m = +m;
  }
  if (isNumber(m)) {
    return m - 1;
  } else {
    const lowerM = m.toLowerCase();
    const monthIndex = MONTHS.indexOf(lowerM);
    if (monthIndex !== -1) {
      return monthIndex;
    }
    const shortM = lowerM.substr(0, 3);
    const shortMonthIndex = SHORT_MONTHS.indexOf(shortM);
    if (shortMonthIndex !== -1) {
      return shortMonthIndex;
    }
    throw new Error(message_exports.invalidTimeUnit("month", m));
  }
}
function normalizeDay(d) {
  if (isNumeric(d)) {
    d = +d;
  }
  if (isNumber(d)) {
    return d % 7;
  } else {
    const lowerD = d.toLowerCase();
    const dayIndex = DAYS.indexOf(lowerD);
    if (dayIndex !== -1) {
      return dayIndex;
    }
    const shortD = lowerD.substr(0, 3);
    const shortDayIndex = SHORT_DAYS.indexOf(shortD);
    if (shortDayIndex !== -1) {
      return shortDayIndex;
    }
    throw new Error(message_exports.invalidTimeUnit("day", d));
  }
}
function dateTimeParts(d, normalize2) {
  const parts = [];
  if (normalize2 && d.day !== void 0) {
    if (keys(d).length > 1) {
      warn(message_exports.droppedDay(d));
      d = duplicate(d);
      delete d.day;
    }
  }
  if (d.year !== void 0) {
    parts.push(d.year);
  } else {
    parts.push(2012);
  }
  if (d.month !== void 0) {
    const month = normalize2 ? normalizeMonth(d.month) : d.month;
    parts.push(month);
  } else if (d.quarter !== void 0) {
    const quarter = normalize2 ? normalizeQuarter(d.quarter) : d.quarter;
    parts.push(isNumber(quarter) ? quarter * 3 : `${quarter}*3`);
  } else {
    parts.push(0);
  }
  if (d.date !== void 0) {
    parts.push(d.date);
  } else if (d.day !== void 0) {
    const day = normalize2 ? normalizeDay(d.day) : d.day;
    parts.push(isNumber(day) ? day + 1 : `${day}+1`);
  } else {
    parts.push(1);
  }
  for (const timeUnit of ["hours", "minutes", "seconds", "milliseconds"]) {
    const unit = d[timeUnit];
    parts.push(typeof unit === "undefined" ? 0 : unit);
  }
  return parts;
}
function dateTimeToExpr(d) {
  const parts = dateTimeParts(d, true);
  const string = parts.join(", ");
  if (d.utc) {
    return `utc(${string})`;
  } else {
    return `datetime(${string})`;
  }
}
function dateTimeExprToExpr(d) {
  const parts = dateTimeParts(d, false);
  const string = parts.join(", ");
  if (d.utc) {
    return `utc(${string})`;
  } else {
    return `datetime(${string})`;
  }
}
function dateTimeToTimestamp(d) {
  const parts = dateTimeParts(d, true);
  if (d.utc) {
    return +new Date(Date.UTC(...parts));
  } else {
    return +new Date(...parts);
  }
}

// node_modules/vega-lite/build/src/timeunit.js
var __rest3 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var LOCAL_SINGLE_TIMEUNIT_INDEX = {
  year: 1,
  quarter: 1,
  month: 1,
  week: 1,
  day: 1,
  dayofyear: 1,
  date: 1,
  hours: 1,
  minutes: 1,
  seconds: 1,
  milliseconds: 1
};
var TIMEUNIT_PARTS = keys(LOCAL_SINGLE_TIMEUNIT_INDEX);
function isLocalSingleTimeUnit(timeUnit) {
  return !!LOCAL_SINGLE_TIMEUNIT_INDEX[timeUnit];
}
function isUTCTimeUnit(t2) {
  return t2.startsWith("utc");
}
function getLocalTimeUnit(t2) {
  return t2.substr(3);
}
var VEGALITE_TIMEFORMAT = {
  "year-month": "%b %Y ",
  "year-month-date": "%b %d, %Y "
};
function getTimeUnitParts(timeUnit) {
  return TIMEUNIT_PARTS.filter((part) => containsTimeUnit(timeUnit, part));
}
function containsTimeUnit(fullTimeUnit, timeUnit) {
  const index2 = fullTimeUnit.indexOf(timeUnit);
  if (index2 < 0) {
    return false;
  }
  if (index2 > 0 && timeUnit === "seconds" && fullTimeUnit.charAt(index2 - 1) === "i") {
    return false;
  }
  if (fullTimeUnit.length > index2 + 3 && timeUnit === "day" && fullTimeUnit.charAt(index2 + 3) === "o") {
    return false;
  }
  if (index2 > 0 && timeUnit === "year" && fullTimeUnit.charAt(index2 - 1) === "f") {
    return false;
  }
  return true;
}
function fieldExpr(fullTimeUnit, field, { end } = { end: false }) {
  const fieldRef = accessPathWithDatum(field);
  const utc = isUTCTimeUnit(fullTimeUnit) ? "utc" : "";
  function func(timeUnit) {
    if (timeUnit === "quarter") {
      return `(${utc}quarter(${fieldRef})-1)`;
    } else {
      return `${utc}${timeUnit}(${fieldRef})`;
    }
  }
  let lastTimeUnit;
  const dateExpr = {};
  for (const part of TIMEUNIT_PARTS) {
    if (containsTimeUnit(fullTimeUnit, part)) {
      dateExpr[part] = func(part);
      lastTimeUnit = part;
    }
  }
  if (end) {
    dateExpr[lastTimeUnit] += "+1";
  }
  return dateTimeExprToExpr(dateExpr);
}
function timeUnitSpecifierExpression(timeUnit) {
  if (!timeUnit) {
    return void 0;
  }
  const timeUnitParts = getTimeUnitParts(timeUnit);
  return `timeUnitSpecifier(${stringify(timeUnitParts)}, ${stringify(VEGALITE_TIMEFORMAT)})`;
}
function formatExpression(timeUnit, field, isUTCScale) {
  if (!timeUnit) {
    return void 0;
  }
  const expr = timeUnitSpecifierExpression(timeUnit);
  const utc = isUTCScale || isUTCTimeUnit(timeUnit);
  return `${utc ? "utc" : "time"}Format(${field}, ${expr})`;
}
function normalizeTimeUnit(timeUnit) {
  if (!timeUnit) {
    return void 0;
  }
  let params;
  if (isString2(timeUnit)) {
    params = {
      unit: timeUnit
    };
  } else if (isObject2(timeUnit)) {
    params = Object.assign(Object.assign({}, timeUnit), timeUnit.unit ? { unit: timeUnit.unit } : {});
  }
  if (isUTCTimeUnit(params.unit)) {
    params.utc = true;
    params.unit = getLocalTimeUnit(params.unit);
  }
  return params;
}
function timeUnitToString(tu) {
  const _a = normalizeTimeUnit(tu), { utc } = _a, rest = __rest3(_a, ["utc"]);
  if (rest.unit) {
    return (utc ? "utc" : "") + keys(rest).map((p) => varName(`${p === "unit" ? "" : `_${p}_`}${rest[p]}`)).join("");
  } else {
    return (utc ? "utc" : "") + "timeunit" + keys(rest).map((p) => varName(`_${p}_${rest[p]}`)).join("");
  }
}

// node_modules/vega-lite/build/src/predicate.js
function isSelectionPredicate(predicate) {
  return predicate === null || predicate === void 0 ? void 0 : predicate["param"];
}
function isFieldEqualPredicate(predicate) {
  return predicate && !!predicate.field && predicate.equal !== void 0;
}
function isFieldLTPredicate(predicate) {
  return predicate && !!predicate.field && predicate.lt !== void 0;
}
function isFieldLTEPredicate(predicate) {
  return predicate && !!predicate.field && predicate.lte !== void 0;
}
function isFieldGTPredicate(predicate) {
  return predicate && !!predicate.field && predicate.gt !== void 0;
}
function isFieldGTEPredicate(predicate) {
  return predicate && !!predicate.field && predicate.gte !== void 0;
}
function isFieldRangePredicate(predicate) {
  if (predicate === null || predicate === void 0 ? void 0 : predicate.field) {
    if (isArray2(predicate.range) && predicate.range.length === 2) {
      return true;
    } else if (isSignalRef(predicate.range)) {
      return true;
    }
  }
  return false;
}
function isFieldOneOfPredicate(predicate) {
  return predicate && !!predicate.field && (isArray2(predicate.oneOf) || isArray2(predicate.in));
}
function isFieldValidPredicate(predicate) {
  return predicate && !!predicate.field && predicate.valid !== void 0;
}
function isFieldPredicate(predicate) {
  return isFieldOneOfPredicate(predicate) || isFieldEqualPredicate(predicate) || isFieldRangePredicate(predicate) || isFieldLTPredicate(predicate) || isFieldGTPredicate(predicate) || isFieldLTEPredicate(predicate) || isFieldGTEPredicate(predicate);
}
function predicateValueExpr(v, timeUnit) {
  return valueExpr(v, { timeUnit, wrapTime: true });
}
function predicateValuesExpr(vals2, timeUnit) {
  return vals2.map((v) => predicateValueExpr(v, timeUnit));
}
function fieldFilterExpression(predicate, useInRange = true) {
  var _a;
  const { field } = predicate;
  const timeUnit = (_a = normalizeTimeUnit(predicate.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;
  const fieldExpr2 = timeUnit ? `time(${fieldExpr(timeUnit, field)})` : vgField(predicate, { expr: "datum" });
  if (isFieldEqualPredicate(predicate)) {
    return `${fieldExpr2}===${predicateValueExpr(predicate.equal, timeUnit)}`;
  } else if (isFieldLTPredicate(predicate)) {
    const upper = predicate.lt;
    return `${fieldExpr2}<${predicateValueExpr(upper, timeUnit)}`;
  } else if (isFieldGTPredicate(predicate)) {
    const lower = predicate.gt;
    return `${fieldExpr2}>${predicateValueExpr(lower, timeUnit)}`;
  } else if (isFieldLTEPredicate(predicate)) {
    const upper = predicate.lte;
    return `${fieldExpr2}<=${predicateValueExpr(upper, timeUnit)}`;
  } else if (isFieldGTEPredicate(predicate)) {
    const lower = predicate.gte;
    return `${fieldExpr2}>=${predicateValueExpr(lower, timeUnit)}`;
  } else if (isFieldOneOfPredicate(predicate)) {
    return `indexof([${predicateValuesExpr(predicate.oneOf, timeUnit).join(",")}], ${fieldExpr2}) !== -1`;
  } else if (isFieldValidPredicate(predicate)) {
    return fieldValidPredicate(fieldExpr2, predicate.valid);
  } else if (isFieldRangePredicate(predicate)) {
    const { range: range2 } = predicate;
    const lower = isSignalRef(range2) ? { signal: `${range2.signal}[0]` } : range2[0];
    const upper = isSignalRef(range2) ? { signal: `${range2.signal}[1]` } : range2[1];
    if (lower !== null && upper !== null && useInRange) {
      return "inrange(" + fieldExpr2 + ", [" + predicateValueExpr(lower, timeUnit) + ", " + predicateValueExpr(upper, timeUnit) + "])";
    }
    const exprs = [];
    if (lower !== null) {
      exprs.push(`${fieldExpr2} >= ${predicateValueExpr(lower, timeUnit)}`);
    }
    if (upper !== null) {
      exprs.push(`${fieldExpr2} <= ${predicateValueExpr(upper, timeUnit)}`);
    }
    return exprs.length > 0 ? exprs.join(" && ") : "true";
  }
  throw new Error(`Invalid field predicate: ${stringify(predicate)}`);
}
function fieldValidPredicate(fieldExpr2, valid = true) {
  if (valid) {
    return `isValid(${fieldExpr2}) && isFinite(+${fieldExpr2})`;
  } else {
    return `!isValid(${fieldExpr2}) || !isFinite(+${fieldExpr2})`;
  }
}
function normalizePredicate(f) {
  var _a;
  if (isFieldPredicate(f) && f.timeUnit) {
    return Object.assign(Object.assign({}, f), { timeUnit: (_a = normalizeTimeUnit(f.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit });
  }
  return f;
}

// node_modules/vega-lite/build/src/mark.js
var Mark = {
  arc: "arc",
  area: "area",
  bar: "bar",
  image: "image",
  line: "line",
  point: "point",
  rect: "rect",
  rule: "rule",
  text: "text",
  tick: "tick",
  trail: "trail",
  circle: "circle",
  square: "square",
  geoshape: "geoshape"
};
var ARC = Mark.arc;
var AREA = Mark.area;
var BAR = Mark.bar;
var IMAGE = Mark.image;
var LINE = Mark.line;
var POINT = Mark.point;
var RECT = Mark.rect;
var RULE = Mark.rule;
var TEXT2 = Mark.text;
var TICK = Mark.tick;
var TRAIL = Mark.trail;
var CIRCLE = Mark.circle;
var SQUARE = Mark.square;
var GEOSHAPE = Mark.geoshape;
function isPathMark(m) {
  return ["line", "area", "trail"].includes(m);
}
function isRectBasedMark(m) {
  return ["rect", "bar", "image", "arc"].includes(m);
}
var PRIMITIVE_MARKS = keys(Mark);
function isMarkDef(mark3) {
  return mark3["type"];
}
var PRIMITIVE_MARK_INDEX = toSet(PRIMITIVE_MARKS);
var STROKE_CONFIG = [
  "stroke",
  "strokeWidth",
  "strokeDash",
  "strokeDashOffset",
  "strokeOpacity",
  "strokeJoin",
  "strokeMiterLimit"
];
var FILL_CONFIG = ["fill", "fillOpacity"];
var FILL_STROKE_CONFIG = [...STROKE_CONFIG, ...FILL_CONFIG];
var VL_ONLY_MARK_CONFIG_INDEX = {
  color: 1,
  filled: 1,
  invalid: 1,
  order: 1,
  radius2: 1,
  theta2: 1,
  timeUnitBandSize: 1,
  timeUnitBandPosition: 1
};
var VL_ONLY_MARK_CONFIG_PROPERTIES = keys(VL_ONLY_MARK_CONFIG_INDEX);
var VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = {
  area: ["line", "point"],
  bar: ["binSpacing", "continuousBandSize", "discreteBandSize"],
  rect: ["binSpacing", "continuousBandSize", "discreteBandSize"],
  line: ["point"],
  tick: ["bandSize", "thickness"]
};
var defaultMarkConfig = {
  color: "#4c78a8",
  invalid: "filter",
  timeUnitBandSize: 1
};
var MARK_CONFIG_INDEX = {
  mark: 1,
  arc: 1,
  area: 1,
  bar: 1,
  circle: 1,
  image: 1,
  line: 1,
  point: 1,
  rect: 1,
  rule: 1,
  square: 1,
  text: 1,
  tick: 1,
  trail: 1,
  geoshape: 1
};
var MARK_CONFIGS = keys(MARK_CONFIG_INDEX);
function isRelativeBandSize(o) {
  return o && o["band"] != void 0;
}
var BAR_CORNER_RADIUS_INDEX = {
  horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
  vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
};
var DEFAULT_RECT_BAND_SIZE = 5;
var defaultBarConfig = {
  binSpacing: 1,
  continuousBandSize: DEFAULT_RECT_BAND_SIZE,
  timeUnitBandPosition: 0.5
};
var defaultRectConfig = {
  binSpacing: 0,
  continuousBandSize: DEFAULT_RECT_BAND_SIZE,
  timeUnitBandPosition: 0.5
};
var defaultTickConfig = {
  thickness: 1
};
function getMarkType(m) {
  return isMarkDef(m) ? m.type : m;
}

// node_modules/vega-lite/build/src/compile/mark/encode/valueref.js
function midPointRefWithPositionInvalidTest(params) {
  const { channel, channelDef, markDef, scale, config } = params;
  const ref5 = midPoint(params);
  if (isFieldDef(channelDef) && !isCountingAggregateOp(channelDef.aggregate) && scale && isContinuousToContinuous(scale.get("type")) && scale.get("zero") === false) {
    return wrapPositionInvalidTest({
      fieldDef: channelDef,
      channel,
      markDef,
      ref: ref5,
      config
    });
  }
  return ref5;
}
function wrapPositionInvalidTest({ fieldDef, channel, markDef, ref: ref5, config }) {
  if (isPathMark(markDef.type)) {
    return ref5;
  }
  const invalid = getMarkPropOrConfig("invalid", markDef, config);
  if (invalid === null) {
    return ref5;
  }
  return [fieldInvalidTestValueRef(fieldDef, channel), ref5];
}
function fieldInvalidTestValueRef(fieldDef, channel) {
  const test = fieldInvalidPredicate(fieldDef, true);
  const mainChannel = getMainRangeChannel(channel);
  const zeroValueRef = mainChannel === "y" ? { field: { group: "height" } } : { value: 0 };
  return Object.assign({ test }, zeroValueRef);
}
function fieldInvalidPredicate(field, invalid = true) {
  return fieldValidPredicate(isString2(field) ? field : vgField(field, { expr: "datum" }), !invalid);
}
function datumDefToExpr(datumDef) {
  const { datum } = datumDef;
  if (isDateTime(datum)) {
    return dateTimeToExpr(datum);
  }
  return `${stringify(datum)}`;
}
function valueRefForFieldOrDatumDef(fieldDef, scaleName, opt, encode13) {
  const ref5 = {};
  if (scaleName) {
    ref5.scale = scaleName;
  }
  if (isDatumDef(fieldDef)) {
    const { datum } = fieldDef;
    if (isDateTime(datum)) {
      ref5.signal = dateTimeToExpr(datum);
    } else if (isSignalRef(datum)) {
      ref5.signal = datum.signal;
    } else if (isExprRef(datum)) {
      ref5.signal = datum.expr;
    } else {
      ref5.value = datum;
    }
  } else {
    ref5.field = vgField(fieldDef, opt);
  }
  if (encode13) {
    const { offset, band } = encode13;
    if (offset) {
      ref5.offset = offset;
    }
    if (band) {
      ref5.band = band;
    }
  }
  return ref5;
}
function interpolatedSignalRef({ scaleName, fieldOrDatumDef, fieldOrDatumDef2, offset, startSuffix, bandPosition = 0.5 }) {
  const expr = 0 < bandPosition && bandPosition < 1 ? "datum" : void 0;
  const start = vgField(fieldOrDatumDef, { expr, suffix: startSuffix });
  const end = fieldOrDatumDef2 !== void 0 ? vgField(fieldOrDatumDef2, { expr }) : vgField(fieldOrDatumDef, { suffix: "end", expr });
  const ref5 = {};
  if (bandPosition === 0 || bandPosition === 1) {
    ref5.scale = scaleName;
    const val = bandPosition === 0 ? start : end;
    ref5.field = val;
  } else {
    const datum = isSignalRef(bandPosition) ? `${bandPosition.signal} * ${start} + (1-${bandPosition.signal}) * ${end}` : `${bandPosition} * ${start} + ${1 - bandPosition} * ${end}`;
    ref5.signal = `scale("${scaleName}", ${datum})`;
  }
  if (offset) {
    ref5.offset = offset;
  }
  return ref5;
}
function midPoint({ channel, channelDef, channel2Def, markDef, config, scaleName, scale, stack: stack2, offset, defaultRef, bandPosition }) {
  var _a;
  if (channelDef) {
    if (isFieldOrDatumDef(channelDef)) {
      if (isTypedFieldDef(channelDef)) {
        bandPosition !== null && bandPosition !== void 0 ? bandPosition : bandPosition = getBandPosition({
          fieldDef: channelDef,
          fieldDef2: channel2Def,
          markDef,
          config
        });
        const { bin: bin2, timeUnit, type } = channelDef;
        if (isBinning(bin2) || bandPosition && timeUnit && type === TEMPORAL) {
          if (stack2 === null || stack2 === void 0 ? void 0 : stack2.impute) {
            return valueRefForFieldOrDatumDef(channelDef, scaleName, { binSuffix: "mid" }, { offset });
          }
          if (bandPosition) {
            return interpolatedSignalRef({ scaleName, fieldOrDatumDef: channelDef, bandPosition, offset });
          }
          return valueRefForFieldOrDatumDef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? { binSuffix: "range" } : {}, {
            offset
          });
        } else if (isBinned(bin2)) {
          if (isFieldDef(channel2Def)) {
            return interpolatedSignalRef({
              scaleName,
              fieldOrDatumDef: channelDef,
              fieldOrDatumDef2: channel2Def,
              bandPosition,
              offset
            });
          } else {
            const channel2 = channel === X ? X2 : Y2;
            warn(message_exports.channelRequiredForBinned(channel2));
          }
        }
      }
      const scaleType2 = scale === null || scale === void 0 ? void 0 : scale.get("type");
      return valueRefForFieldOrDatumDef(channelDef, scaleName, hasDiscreteDomain(scaleType2) ? { binSuffix: "range" } : {}, {
        offset,
        band: scaleType2 === "band" ? (_a = bandPosition !== null && bandPosition !== void 0 ? bandPosition : channelDef.bandPosition) !== null && _a !== void 0 ? _a : 0.5 : void 0
      });
    } else if (isValueDef(channelDef)) {
      const value = channelDef.value;
      const offsetMixins = offset ? { offset } : {};
      return Object.assign(Object.assign({}, widthHeightValueOrSignalRef(channel, value)), offsetMixins);
    }
  }
  if (isFunction(defaultRef)) {
    defaultRef = defaultRef();
  }
  if (defaultRef) {
    return Object.assign(Object.assign({}, defaultRef), offset ? { offset } : {});
  }
  return defaultRef;
}
function widthHeightValueOrSignalRef(channel, value) {
  if (contains(["x", "x2"], channel) && value === "width") {
    return { field: { group: "width" } };
  } else if (contains(["y", "y2"], channel) && value === "height") {
    return { field: { group: "height" } };
  }
  return signalOrValueRef(value);
}

// node_modules/vega-lite/build/src/compile/format.js
function isCustomFormatType(formatType) {
  return formatType && formatType !== "number" && formatType !== "time";
}
function customFormatExpr(formatType, field, format) {
  return `${formatType}(${field}${format ? `, ${stringify(format)}` : ""})`;
}
var BIN_RANGE_DELIMITER = " \u2013 ";
function formatSignalRef({ fieldOrDatumDef, format, formatType, expr, normalizeStack, config }) {
  var _a, _b;
  if (isCustomFormatType(formatType)) {
    return formatCustomType({
      fieldOrDatumDef,
      format,
      formatType,
      expr,
      config
    });
  }
  const field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {
    const signal = timeFormatExpression(field, isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : void 0, format, config.timeFormat, isScaleFieldDef(fieldOrDatumDef) && ((_b = fieldOrDatumDef.scale) === null || _b === void 0 ? void 0 : _b.type) === ScaleType.UTC);
    return signal ? { signal } : void 0;
  }
  format = numberFormat(channelDefType(fieldOrDatumDef), format, config);
  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {
    const endField = vgField(fieldOrDatumDef, { expr, binSuffix: "end" });
    return {
      signal: binFormatExpression(field, endField, format, formatType, config)
    };
  } else if (format || channelDefType(fieldOrDatumDef) === "quantitative") {
    return {
      signal: `${formatExpr(field, format)}`
    };
  } else {
    return { signal: `isValid(${field}) ? ${field} : ""+${field}` };
  }
}
function fieldToFormat(fieldOrDatumDef, expr, normalizeStack) {
  if (isFieldDef(fieldOrDatumDef)) {
    if (normalizeStack) {
      return `${vgField(fieldOrDatumDef, { expr, suffix: "end" })}-${vgField(fieldOrDatumDef, {
        expr,
        suffix: "start"
      })}`;
    } else {
      return vgField(fieldOrDatumDef, { expr });
    }
  } else {
    return datumDefToExpr(fieldOrDatumDef);
  }
}
function formatCustomType({ fieldOrDatumDef, format, formatType, expr, normalizeStack, config, field }) {
  field !== null && field !== void 0 ? field : field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);
  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {
    const endField = vgField(fieldOrDatumDef, { expr, binSuffix: "end" });
    return {
      signal: binFormatExpression(field, endField, format, formatType, config)
    };
  }
  return { signal: customFormatExpr(formatType, field, format) };
}
function guideFormat(fieldOrDatumDef, type, format, formatType, config, omitTimeFormatConfig) {
  var _a;
  if (isCustomFormatType(formatType)) {
    return void 0;
  }
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {
    const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : void 0;
    return timeFormat(format, timeUnit, config, omitTimeFormatConfig);
  }
  return numberFormat(type, format, config);
}
function guideFormatType(formatType, fieldOrDatumDef, scaleType2) {
  if (formatType && (isSignalRef(formatType) || formatType === "number" || formatType === "time")) {
    return formatType;
  }
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType2 !== "time" && scaleType2 !== "utc") {
    return "time";
  }
  return void 0;
}
function numberFormat(type, specifiedFormat, config) {
  if (isString2(specifiedFormat)) {
    return specifiedFormat;
  }
  if (type === QUANTITATIVE) {
    return config.numberFormat;
  }
  return void 0;
}
function timeFormat(specifiedFormat, timeUnit, config, omitTimeFormatConfig) {
  if (specifiedFormat) {
    return specifiedFormat;
  }
  if (timeUnit) {
    return {
      signal: timeUnitSpecifierExpression(timeUnit)
    };
  }
  return omitTimeFormatConfig ? void 0 : config.timeFormat;
}
function formatExpr(field, format) {
  return `format(${field}, "${format || ""}")`;
}
function binNumberFormatExpr(field, format, formatType, config) {
  var _a;
  if (isCustomFormatType(formatType)) {
    return customFormatExpr(formatType, field, format);
  }
  return formatExpr(field, (_a = isString2(format) ? format : void 0) !== null && _a !== void 0 ? _a : config.numberFormat);
}
function binFormatExpression(startField, endField, format, formatType, config) {
  const start = binNumberFormatExpr(startField, format, formatType, config);
  const end = binNumberFormatExpr(endField, format, formatType, config);
  return `${fieldValidPredicate(startField, false)} ? "null" : ${start} + "${BIN_RANGE_DELIMITER}" + ${end}`;
}
function timeFormatExpression(field, timeUnit, format, rawTimeFormat, isUTCScale) {
  if (!timeUnit || format) {
    format = isString2(format) ? format : rawTimeFormat;
    return `${isUTCScale ? "utc" : "time"}Format(${field}, '${format}')`;
  } else {
    return formatExpression(timeUnit, field, isUTCScale);
  }
}

// node_modules/vega-lite/build/src/sort.js
var DEFAULT_SORT_OP = "min";
var SORT_BY_CHANNEL_INDEX = {
  x: 1,
  y: 1,
  color: 1,
  fill: 1,
  stroke: 1,
  strokeWidth: 1,
  size: 1,
  shape: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  opacity: 1,
  text: 1
};
function isSortByChannel(c) {
  return c in SORT_BY_CHANNEL_INDEX;
}
function isSortByEncoding(sort) {
  return !!sort && !!sort["encoding"];
}
function isSortField(sort) {
  return !!sort && (sort["op"] === "count" || !!sort["field"]);
}
function isSortArray(sort) {
  return !!sort && isArray2(sort);
}

// node_modules/vega-lite/build/src/spec/facet.js
function isFacetMapping(f) {
  return "row" in f || "column" in f;
}
function isFacetFieldDef(channelDef) {
  return !!channelDef && "header" in channelDef;
}
function isFacetSpec(spec) {
  return "facet" in spec;
}

// node_modules/vega-lite/build/src/channeldef.js
var __rest4 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function isConditionalParameter(c) {
  return c["param"];
}
function isRepeatRef(field) {
  return field && !isString2(field) && "repeat" in field;
}
function toFieldDefBase(fieldDef) {
  const { field, timeUnit, bin: bin2, aggregate } = fieldDef;
  return Object.assign(Object.assign(Object.assign(Object.assign({}, timeUnit ? { timeUnit } : {}), bin2 ? { bin: bin2 } : {}), aggregate ? { aggregate } : {}), { field });
}
function isSortableFieldDef(fieldDef) {
  return "sort" in fieldDef;
}
function getBandPosition({ fieldDef, fieldDef2, markDef: mark3, config }) {
  if (isFieldOrDatumDef(fieldDef) && fieldDef.bandPosition !== void 0) {
    return fieldDef.bandPosition;
  }
  if (isFieldDef(fieldDef)) {
    const { timeUnit, bin: bin2 } = fieldDef;
    if (timeUnit && !fieldDef2) {
      return isRectBasedMark(mark3.type) ? 0 : getMarkConfig("timeUnitBandPosition", mark3, config);
    } else if (isBinning(bin2)) {
      return 0.5;
    }
  }
  return void 0;
}
function getBandSize({ channel, fieldDef, fieldDef2, markDef: mark3, config, scaleType: scaleType2, useVlSizeChannel }) {
  var _a, _b, _c;
  const sizeChannel = getSizeChannel(channel);
  const size = getMarkPropOrConfig(useVlSizeChannel ? "size" : sizeChannel, mark3, config, {
    vgChannel: sizeChannel
  });
  if (size !== void 0) {
    return size;
  }
  if (isFieldDef(fieldDef)) {
    const { timeUnit, bin: bin2 } = fieldDef;
    if (timeUnit && !fieldDef2) {
      return { band: getMarkConfig("timeUnitBandSize", mark3, config) };
    } else if (isBinning(bin2) && !hasDiscreteDomain(scaleType2)) {
      return { band: 1 };
    }
  }
  if (isRectBasedMark(mark3.type)) {
    if (scaleType2) {
      if (hasDiscreteDomain(scaleType2)) {
        return ((_a = config[mark3.type]) === null || _a === void 0 ? void 0 : _a.discreteBandSize) || { band: 1 };
      } else {
        return (_b = config[mark3.type]) === null || _b === void 0 ? void 0 : _b.continuousBandSize;
      }
    }
    return (_c = config[mark3.type]) === null || _c === void 0 ? void 0 : _c.discreteBandSize;
  }
  return void 0;
}
function hasBandEnd(fieldDef, fieldDef2, markDef, config) {
  if (isBinning(fieldDef.bin) || fieldDef.timeUnit && isTypedFieldDef(fieldDef) && fieldDef.type === "temporal") {
    return getBandPosition({ fieldDef, fieldDef2, markDef, config }) !== void 0;
  }
  return false;
}
function isConditionalDef(channelDef) {
  return channelDef && "condition" in channelDef;
}
function hasConditionalFieldDef(channelDef) {
  const condition = channelDef && channelDef["condition"];
  return !!condition && !isArray2(condition) && isFieldDef(condition);
}
function hasConditionalFieldOrDatumDef(channelDef) {
  const condition = channelDef && channelDef["condition"];
  return !!condition && !isArray2(condition) && isFieldOrDatumDef(condition);
}
function hasConditionalValueDef(channelDef) {
  const condition = channelDef && channelDef["condition"];
  return !!condition && (isArray2(condition) || isValueDef(condition));
}
function isFieldDef(channelDef) {
  return channelDef && (!!channelDef["field"] || channelDef["aggregate"] === "count");
}
function channelDefType(channelDef) {
  return channelDef && channelDef["type"];
}
function isDatumDef(channelDef) {
  return channelDef && "datum" in channelDef;
}
function isContinuousFieldOrDatumDef(cd) {
  return isTypedFieldDef(cd) && !isDiscrete(cd) || isNumericDataDef(cd);
}
function isNumericDataDef(cd) {
  return isDatumDef(cd) && isNumber(cd.datum);
}
function isFieldOrDatumDef(channelDef) {
  return isFieldDef(channelDef) || isDatumDef(channelDef);
}
function isTypedFieldDef(channelDef) {
  return channelDef && ("field" in channelDef || channelDef["aggregate"] === "count") && "type" in channelDef;
}
function isValueDef(channelDef) {
  return channelDef && "value" in channelDef && "value" in channelDef;
}
function isScaleFieldDef(channelDef) {
  return channelDef && ("scale" in channelDef || "sort" in channelDef);
}
function isPositionFieldOrDatumDef(channelDef) {
  return channelDef && ("axis" in channelDef || "stack" in channelDef || "impute" in channelDef);
}
function isMarkPropFieldOrDatumDef(channelDef) {
  return channelDef && "legend" in channelDef;
}
function isStringFieldOrDatumDef(channelDef) {
  return channelDef && ("format" in channelDef || "formatType" in channelDef);
}
function toStringFieldDef(fieldDef) {
  return omit(fieldDef, ["legend", "axis", "header", "scale"]);
}
function isOpFieldDef(fieldDef) {
  return "op" in fieldDef;
}
function vgField(fieldDef, opt = {}) {
  var _a, _b, _c;
  let field = fieldDef.field;
  const prefix = opt.prefix;
  let suffix = opt.suffix;
  let argAccessor = "";
  if (isCount(fieldDef)) {
    field = internalField("count");
  } else {
    let fn;
    if (!opt.nofn) {
      if (isOpFieldDef(fieldDef)) {
        fn = fieldDef.op;
      } else {
        const { bin: bin2, aggregate, timeUnit } = fieldDef;
        if (isBinning(bin2)) {
          fn = binToString(bin2);
          suffix = ((_a = opt.binSuffix) !== null && _a !== void 0 ? _a : "") + ((_b = opt.suffix) !== null && _b !== void 0 ? _b : "");
        } else if (aggregate) {
          if (isArgmaxDef(aggregate)) {
            argAccessor = `["${field}"]`;
            field = `argmax_${aggregate.argmax}`;
          } else if (isArgminDef(aggregate)) {
            argAccessor = `["${field}"]`;
            field = `argmin_${aggregate.argmin}`;
          } else {
            fn = String(aggregate);
          }
        } else if (timeUnit) {
          fn = timeUnitToString(timeUnit);
          suffix = (!["range", "mid"].includes(opt.binSuffix) && opt.binSuffix || "") + ((_c = opt.suffix) !== null && _c !== void 0 ? _c : "");
        }
      }
    }
    if (fn) {
      field = field ? `${fn}_${field}` : fn;
    }
  }
  if (suffix) {
    field = `${field}_${suffix}`;
  }
  if (prefix) {
    field = `${prefix}_${field}`;
  }
  if (opt.forAs) {
    return removePathFromField(field);
  } else if (opt.expr) {
    return flatAccessWithDatum(field, opt.expr) + argAccessor;
  } else {
    return replacePathInField(field) + argAccessor;
  }
}
function isDiscrete(def) {
  switch (def.type) {
    case "nominal":
    case "ordinal":
    case "geojson":
      return true;
    case "quantitative":
      return isFieldDef(def) && !!def.bin;
    case "temporal":
      return false;
  }
  throw new Error(message_exports.invalidFieldType(def.type));
}
function isDiscretizing(def) {
  var _a;
  return isScaleFieldDef(def) && isContinuousToDiscrete((_a = def.scale) === null || _a === void 0 ? void 0 : _a.type);
}
function isCount(fieldDef) {
  return fieldDef.aggregate === "count";
}
function verbalTitleFormatter(fieldDef, config) {
  var _a;
  const { field, bin: bin2, timeUnit, aggregate } = fieldDef;
  if (aggregate === "count") {
    return config.countTitle;
  } else if (isBinning(bin2)) {
    return `${field} (binned)`;
  } else if (timeUnit) {
    const unit = (_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;
    if (unit) {
      return `${field} (${getTimeUnitParts(unit).join("-")})`;
    }
  } else if (aggregate) {
    if (isArgmaxDef(aggregate)) {
      return `${field} for max ${aggregate.argmax}`;
    } else if (isArgminDef(aggregate)) {
      return `${field} for min ${aggregate.argmin}`;
    } else {
      return `${titleCase(aggregate)} of ${field}`;
    }
  }
  return field;
}
function functionalTitleFormatter(fieldDef) {
  const { aggregate, bin: bin2, timeUnit, field } = fieldDef;
  if (isArgmaxDef(aggregate)) {
    return `${field} for argmax(${aggregate.argmax})`;
  } else if (isArgminDef(aggregate)) {
    return `${field} for argmin(${aggregate.argmin})`;
  }
  const timeUnitParams = normalizeTimeUnit(timeUnit);
  const fn = aggregate || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.unit) || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.maxbins) && "timeunit" || isBinning(bin2) && "bin";
  if (fn) {
    return `${fn.toUpperCase()}(${field})`;
  } else {
    return field;
  }
}
var defaultTitleFormatter = (fieldDef, config) => {
  switch (config.fieldTitle) {
    case "plain":
      return fieldDef.field;
    case "functional":
      return functionalTitleFormatter(fieldDef);
    default:
      return verbalTitleFormatter(fieldDef, config);
  }
};
var titleFormatter = defaultTitleFormatter;
function setTitleFormatter(formatter) {
  titleFormatter = formatter;
}
function resetTitleFormatter() {
  setTitleFormatter(defaultTitleFormatter);
}
function title(fieldOrDatumDef, config, { allowDisabling, includeDefault = true }) {
  var _a, _b;
  const guideTitle = (_a = getGuide(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.title;
  if (!isFieldDef(fieldOrDatumDef)) {
    return guideTitle;
  }
  const fieldDef = fieldOrDatumDef;
  const def = includeDefault ? defaultTitle(fieldDef, config) : void 0;
  if (allowDisabling) {
    return getFirstDefined(guideTitle, fieldDef.title, def);
  } else {
    return (_b = guideTitle !== null && guideTitle !== void 0 ? guideTitle : fieldDef.title) !== null && _b !== void 0 ? _b : def;
  }
}
function getGuide(fieldDef) {
  if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis) {
    return fieldDef.axis;
  } else if (isMarkPropFieldOrDatumDef(fieldDef) && fieldDef.legend) {
    return fieldDef.legend;
  } else if (isFacetFieldDef(fieldDef) && fieldDef.header) {
    return fieldDef.header;
  }
  return void 0;
}
function defaultTitle(fieldDef, config) {
  return titleFormatter(fieldDef, config);
}
function getFormatMixins(fieldDef) {
  var _a;
  if (isStringFieldOrDatumDef(fieldDef)) {
    const { format, formatType } = fieldDef;
    return { format, formatType };
  } else {
    const guide = (_a = getGuide(fieldDef)) !== null && _a !== void 0 ? _a : {};
    const { format, formatType } = guide;
    return { format, formatType };
  }
}
function defaultType(fieldDef, channel) {
  var _a;
  switch (channel) {
    case "latitude":
    case "longitude":
      return "quantitative";
    case "row":
    case "column":
    case "facet":
    case "shape":
    case "strokeDash":
      return "nominal";
    case "order":
      return "ordinal";
  }
  if (isSortableFieldDef(fieldDef) && isArray2(fieldDef.sort)) {
    return "ordinal";
  }
  const { aggregate, bin: bin2, timeUnit } = fieldDef;
  if (timeUnit) {
    return "temporal";
  }
  if (bin2 || aggregate && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {
    return "quantitative";
  }
  if (isScaleFieldDef(fieldDef) && ((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.type)) {
    switch (SCALE_CATEGORY_INDEX[fieldDef.scale.type]) {
      case "numeric":
      case "discretizing":
        return "quantitative";
      case "time":
        return "temporal";
    }
  }
  return "nominal";
}
function getFieldDef(channelDef) {
  if (isFieldDef(channelDef)) {
    return channelDef;
  } else if (hasConditionalFieldDef(channelDef)) {
    return channelDef.condition;
  }
  return void 0;
}
function getFieldOrDatumDef(channelDef) {
  if (isFieldOrDatumDef(channelDef)) {
    return channelDef;
  } else if (hasConditionalFieldOrDatumDef(channelDef)) {
    return channelDef.condition;
  }
  return void 0;
}
function initChannelDef(channelDef, channel, config, opt = {}) {
  if (isString2(channelDef) || isNumber(channelDef) || isBoolean2(channelDef)) {
    const primitiveType = isString2(channelDef) ? "string" : isNumber(channelDef) ? "number" : "boolean";
    warn(message_exports.primitiveChannelDef(channel, primitiveType, channelDef));
    return { value: channelDef };
  }
  if (isFieldOrDatumDef(channelDef)) {
    return initFieldOrDatumDef(channelDef, channel, config, opt);
  } else if (hasConditionalFieldOrDatumDef(channelDef)) {
    return Object.assign(Object.assign({}, channelDef), {
      condition: initFieldOrDatumDef(channelDef.condition, channel, config, opt)
    });
  }
  return channelDef;
}
function initFieldOrDatumDef(fd, channel, config, opt) {
  if (isStringFieldOrDatumDef(fd)) {
    const { format, formatType } = fd, rest = __rest4(fd, ["format", "formatType"]);
    if (isCustomFormatType(formatType) && !config.customFormatTypes) {
      warn(message_exports.customFormatTypeNotAllowed(channel));
      return initFieldOrDatumDef(rest, channel, config, opt);
    }
  } else {
    const guideType = isPositionFieldOrDatumDef(fd) ? "axis" : isMarkPropFieldOrDatumDef(fd) ? "legend" : isFacetFieldDef(fd) ? "header" : null;
    if (guideType && fd[guideType]) {
      const _a = fd[guideType], { format, formatType } = _a, newGuide = __rest4(_a, ["format", "formatType"]);
      if (isCustomFormatType(formatType) && !config.customFormatTypes) {
        warn(message_exports.customFormatTypeNotAllowed(channel));
        return initFieldOrDatumDef(Object.assign(Object.assign({}, fd), { [guideType]: newGuide }), channel, config, opt);
      }
    }
  }
  if (isFieldDef(fd)) {
    return initFieldDef(fd, channel, opt);
  }
  return initDatumDef(fd);
}
function initDatumDef(datumDef) {
  let type = datumDef["type"];
  if (type) {
    return datumDef;
  }
  const { datum } = datumDef;
  type = isNumber(datum) ? "quantitative" : isString2(datum) ? "nominal" : isDateTime(datum) ? "temporal" : void 0;
  return Object.assign(Object.assign({}, datumDef), { type });
}
function initFieldDef(fd, channel, { compositeMark = false } = {}) {
  const { aggregate, timeUnit, bin: bin2, field } = fd;
  const fieldDef = Object.assign({}, fd);
  if (!compositeMark && aggregate && !isAggregateOp(aggregate) && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {
    warn(message_exports.invalidAggregate(aggregate));
    delete fieldDef.aggregate;
  }
  if (timeUnit) {
    fieldDef.timeUnit = normalizeTimeUnit(timeUnit);
  }
  if (field) {
    fieldDef.field = `${field}`;
  }
  if (isBinning(bin2)) {
    fieldDef.bin = normalizeBin(bin2, channel);
  }
  if (isBinned(bin2) && !isXorY(channel)) {
    warn(message_exports.channelShouldNotBeUsedForBinned(channel));
  }
  if (isTypedFieldDef(fieldDef)) {
    const { type } = fieldDef;
    const fullType = getFullName(type);
    if (type !== fullType) {
      fieldDef.type = fullType;
    }
    if (type !== "quantitative") {
      if (isCountingAggregateOp(aggregate)) {
        warn(message_exports.invalidFieldTypeForCountAggregate(type, aggregate));
        fieldDef.type = "quantitative";
      }
    }
  } else if (!isSecondaryRangeChannel(channel)) {
    const newType = defaultType(fieldDef, channel);
    fieldDef["type"] = newType;
  }
  if (isTypedFieldDef(fieldDef)) {
    const { compatible, warning } = channelCompatibility(fieldDef, channel) || {};
    if (compatible === false) {
      warn(warning);
    }
  }
  if (isSortableFieldDef(fieldDef) && isString2(fieldDef.sort)) {
    const { sort } = fieldDef;
    if (isSortByChannel(sort)) {
      return Object.assign(Object.assign({}, fieldDef), { sort: { encoding: sort } });
    }
    const sub = sort.substr(1);
    if (sort.charAt(0) === "-" && isSortByChannel(sub)) {
      return Object.assign(Object.assign({}, fieldDef), { sort: { encoding: sub, order: "descending" } });
    }
  }
  if (isFacetFieldDef(fieldDef)) {
    const { header } = fieldDef;
    if (header) {
      const { orient: orient2 } = header, rest = __rest4(header, ["orient"]);
      if (orient2) {
        return Object.assign(Object.assign({}, fieldDef), { header: Object.assign(Object.assign({}, rest), { labelOrient: header.labelOrient || orient2, titleOrient: header.titleOrient || orient2 }) });
      }
    }
  }
  return fieldDef;
}
function normalizeBin(bin2, channel) {
  if (isBoolean2(bin2)) {
    return { maxbins: autoMaxBins(channel) };
  } else if (bin2 === "binned") {
    return {
      binned: true
    };
  } else if (!bin2.maxbins && !bin2.step) {
    return Object.assign(Object.assign({}, bin2), { maxbins: autoMaxBins(channel) });
  } else {
    return bin2;
  }
}
var COMPATIBLE = { compatible: true };
function channelCompatibility(fieldDef, channel) {
  const type = fieldDef.type;
  if (type === "geojson" && channel !== "shape") {
    return {
      compatible: false,
      warning: `Channel ${channel} should not be used with a geojson data.`
    };
  }
  switch (channel) {
    case ROW:
    case COLUMN:
    case FACET:
      if (!isDiscrete(fieldDef)) {
        return {
          compatible: false,
          warning: message_exports.channelShouldBeDiscrete(channel)
        };
      }
      return COMPATIBLE;
    case X:
    case Y:
    case COLOR:
    case FILL:
    case STROKE:
    case TEXT:
    case DETAIL:
    case KEY:
    case TOOLTIP:
    case HREF:
    case URL2:
    case ANGLE:
    case THETA:
    case RADIUS:
    case DESCRIPTION:
      return COMPATIBLE;
    case LONGITUDE:
    case LONGITUDE2:
    case LATITUDE:
    case LATITUDE2:
      if (type !== QUANTITATIVE) {
        return {
          compatible: false,
          warning: `Channel ${channel} should be used with a quantitative field only, not ${fieldDef.type} field.`
        };
      }
      return COMPATIBLE;
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case STROKEWIDTH:
    case SIZE:
    case THETA2:
    case RADIUS2:
    case X2:
    case Y2:
      if (type === "nominal" && !fieldDef["sort"]) {
        return {
          compatible: false,
          warning: `Channel ${channel} should not be used with an unsorted discrete field.`
        };
      }
      return COMPATIBLE;
    case SHAPE:
    case STROKEDASH:
      if (!isDiscrete(fieldDef) && !isDiscretizing(fieldDef)) {
        return {
          compatible: false,
          warning: message_exports.channelShouldBeDiscreteOrDiscretizing(channel)
        };
      }
      return COMPATIBLE;
    case ORDER:
      if (fieldDef.type === "nominal" && !("sort" in fieldDef)) {
        return {
          compatible: false,
          warning: `Channel order is inappropriate for nominal field, which has no inherent order.`
        };
      }
      return COMPATIBLE;
  }
}
function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) {
  const { formatType } = getFormatMixins(fieldOrDatumDef);
  return formatType === "time" || !formatType && isTimeFieldDef(fieldOrDatumDef);
}
function isTimeFieldDef(def) {
  return def && (def["type"] === "temporal" || isFieldDef(def) && !!def.timeUnit);
}
function valueExpr(v, { timeUnit, type, wrapTime, undefinedIfExprNotRequired }) {
  var _a;
  const unit = timeUnit && ((_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit);
  let isTime = unit || type === "temporal";
  let expr;
  if (isExprRef(v)) {
    expr = v.expr;
  } else if (isSignalRef(v)) {
    expr = v.signal;
  } else if (isDateTime(v)) {
    isTime = true;
    expr = dateTimeToExpr(v);
  } else if (isString2(v) || isNumber(v)) {
    if (isTime) {
      expr = `datetime(${stringify(v)})`;
      if (isLocalSingleTimeUnit(unit)) {
        if (isNumber(v) && v < 1e4 || isString2(v) && isNaN(Date.parse(v))) {
          expr = dateTimeToExpr({ [unit]: v });
        }
      }
    }
  }
  if (expr) {
    return wrapTime && isTime ? `time(${expr})` : expr;
  }
  return undefinedIfExprNotRequired ? void 0 : stringify(v);
}
function valueArray(fieldOrDatumDef, values4) {
  const { type } = fieldOrDatumDef;
  return values4.map((v) => {
    const expr = valueExpr(v, {
      timeUnit: isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.timeUnit : void 0,
      type,
      undefinedIfExprNotRequired: true
    });
    if (expr !== void 0) {
      return { signal: expr };
    }
    return v;
  });
}
function binRequiresRange(fieldDef, channel) {
  if (!isBinning(fieldDef.bin)) {
    console.warn("Only call this method for binned field defs.");
    return false;
  }
  return isScaleChannel(channel) && ["ordinal", "nominal"].includes(fieldDef.type);
}

// node_modules/vega-lite/build/src/axis.js
var CONDITIONAL_AXIS_PROP_INDEX = {
  labelAlign: {
    part: "labels",
    vgProp: "align"
  },
  labelBaseline: {
    part: "labels",
    vgProp: "baseline"
  },
  labelColor: {
    part: "labels",
    vgProp: "fill"
  },
  labelFont: {
    part: "labels",
    vgProp: "font"
  },
  labelFontSize: {
    part: "labels",
    vgProp: "fontSize"
  },
  labelFontStyle: {
    part: "labels",
    vgProp: "fontStyle"
  },
  labelFontWeight: {
    part: "labels",
    vgProp: "fontWeight"
  },
  labelOpacity: {
    part: "labels",
    vgProp: "opacity"
  },
  labelOffset: null,
  labelPadding: null,
  gridColor: {
    part: "grid",
    vgProp: "stroke"
  },
  gridDash: {
    part: "grid",
    vgProp: "strokeDash"
  },
  gridDashOffset: {
    part: "grid",
    vgProp: "strokeDashOffset"
  },
  gridOpacity: {
    part: "grid",
    vgProp: "opacity"
  },
  gridWidth: {
    part: "grid",
    vgProp: "strokeWidth"
  },
  tickColor: {
    part: "ticks",
    vgProp: "stroke"
  },
  tickDash: {
    part: "ticks",
    vgProp: "strokeDash"
  },
  tickDashOffset: {
    part: "ticks",
    vgProp: "strokeDashOffset"
  },
  tickOpacity: {
    part: "ticks",
    vgProp: "opacity"
  },
  tickSize: null,
  tickWidth: {
    part: "ticks",
    vgProp: "strokeWidth"
  }
};
function isConditionalAxisValue(v) {
  return v && v["condition"];
}
var AXIS_PARTS = ["domain", "grid", "labels", "ticks", "title"];
var AXIS_PROPERTY_TYPE = {
  grid: "grid",
  gridCap: "grid",
  gridColor: "grid",
  gridDash: "grid",
  gridDashOffset: "grid",
  gridOpacity: "grid",
  gridScale: "grid",
  gridWidth: "grid",
  orient: "main",
  bandPosition: "both",
  aria: "main",
  description: "main",
  domain: "main",
  domainCap: "main",
  domainColor: "main",
  domainDash: "main",
  domainDashOffset: "main",
  domainOpacity: "main",
  domainWidth: "main",
  format: "main",
  formatType: "main",
  labelAlign: "main",
  labelAngle: "main",
  labelBaseline: "main",
  labelBound: "main",
  labelColor: "main",
  labelFlush: "main",
  labelFlushOffset: "main",
  labelFont: "main",
  labelFontSize: "main",
  labelFontStyle: "main",
  labelFontWeight: "main",
  labelLimit: "main",
  labelLineHeight: "main",
  labelOffset: "main",
  labelOpacity: "main",
  labelOverlap: "main",
  labelPadding: "main",
  labels: "main",
  labelSeparation: "main",
  maxExtent: "main",
  minExtent: "main",
  offset: "both",
  position: "main",
  tickCap: "main",
  tickColor: "main",
  tickDash: "main",
  tickDashOffset: "main",
  tickMinStep: "both",
  tickOffset: "both",
  tickOpacity: "main",
  tickRound: "both",
  ticks: "main",
  tickSize: "main",
  tickWidth: "both",
  title: "main",
  titleAlign: "main",
  titleAnchor: "main",
  titleAngle: "main",
  titleBaseline: "main",
  titleColor: "main",
  titleFont: "main",
  titleFontSize: "main",
  titleFontStyle: "main",
  titleFontWeight: "main",
  titleLimit: "main",
  titleLineHeight: "main",
  titleOpacity: "main",
  titlePadding: "main",
  titleX: "main",
  titleY: "main",
  encode: "both",
  scale: "both",
  tickBand: "both",
  tickCount: "both",
  tickExtra: "both",
  translate: "both",
  values: "both",
  zindex: "both"
};
var COMMON_AXIS_PROPERTIES_INDEX = {
  orient: 1,
  aria: 1,
  bandPosition: 1,
  description: 1,
  domain: 1,
  domainCap: 1,
  domainColor: 1,
  domainDash: 1,
  domainDashOffset: 1,
  domainOpacity: 1,
  domainWidth: 1,
  format: 1,
  formatType: 1,
  grid: 1,
  gridCap: 1,
  gridColor: 1,
  gridDash: 1,
  gridDashOffset: 1,
  gridOpacity: 1,
  gridWidth: 1,
  labelAlign: 1,
  labelAngle: 1,
  labelBaseline: 1,
  labelBound: 1,
  labelColor: 1,
  labelFlush: 1,
  labelFlushOffset: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelLineHeight: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labels: 1,
  labelSeparation: 1,
  maxExtent: 1,
  minExtent: 1,
  offset: 1,
  position: 1,
  tickBand: 1,
  tickCap: 1,
  tickColor: 1,
  tickCount: 1,
  tickDash: 1,
  tickDashOffset: 1,
  tickExtra: 1,
  tickMinStep: 1,
  tickOffset: 1,
  tickOpacity: 1,
  tickRound: 1,
  ticks: 1,
  tickSize: 1,
  tickWidth: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleAngle: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titlePadding: 1,
  titleX: 1,
  titleY: 1,
  translate: 1,
  values: 1,
  zindex: 1
};
var AXIS_PROPERTIES_INDEX = Object.assign(Object.assign({}, COMMON_AXIS_PROPERTIES_INDEX), { style: 1, labelExpr: 1, encoding: 1 });
function isAxisProperty(prop) {
  return !!AXIS_PROPERTIES_INDEX[prop];
}
var AXIS_PROPERTIES = keys(AXIS_PROPERTIES_INDEX);
var AXIS_CONFIGS_INDEX = {
  axis: 1,
  axisBand: 1,
  axisBottom: 1,
  axisDiscrete: 1,
  axisLeft: 1,
  axisPoint: 1,
  axisQuantitative: 1,
  axisRight: 1,
  axisTemporal: 1,
  axisTop: 1,
  axisX: 1,
  axisXBand: 1,
  axisXDiscrete: 1,
  axisXPoint: 1,
  axisXQuantitative: 1,
  axisXTemporal: 1,
  axisY: 1,
  axisYBand: 1,
  axisYDiscrete: 1,
  axisYPoint: 1,
  axisYQuantitative: 1,
  axisYTemporal: 1
};
var AXIS_CONFIGS = keys(AXIS_CONFIGS_INDEX);

// node_modules/vega-lite/build/src/spec/unit.js
function isUnitSpec(spec) {
  return "mark" in spec;
}

// node_modules/vega-lite/build/src/compositemark/base.js
var CompositeMarkNormalizer = class {
  constructor(name5, run) {
    this.name = name5;
    this.run = run;
  }
  hasMatchingType(spec) {
    if (isUnitSpec(spec)) {
      return getMarkType(spec.mark) === this.name;
    }
    return false;
  }
};

// node_modules/vega-lite/build/src/encoding.js
var __rest5 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function channelHasField(encoding, channel) {
  const channelDef = encoding && encoding[channel];
  if (channelDef) {
    if (isArray2(channelDef)) {
      return some(channelDef, (fieldDef) => !!fieldDef.field);
    } else {
      return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);
    }
  }
  return false;
}
function isAggregate(encoding) {
  return some(CHANNELS, (channel) => {
    if (channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      if (isArray2(channelDef)) {
        return some(channelDef, (fieldDef) => !!fieldDef.aggregate);
      } else {
        const fieldDef = getFieldDef(channelDef);
        return fieldDef && !!fieldDef.aggregate;
      }
    }
    return false;
  });
}
function extractTransformsFromEncoding(oldEncoding, config) {
  const groupby = [];
  const bins2 = [];
  const timeUnits = [];
  const aggregate = [];
  const encoding = {};
  forEach(oldEncoding, (channelDef, channel) => {
    if (isFieldDef(channelDef)) {
      const { field, aggregate: aggOp, bin: bin2, timeUnit } = channelDef, remaining = __rest5(channelDef, ["field", "aggregate", "bin", "timeUnit"]);
      if (aggOp || timeUnit || bin2) {
        const guide = getGuide(channelDef);
        const isTitleDefined = guide === null || guide === void 0 ? void 0 : guide.title;
        let newField = vgField(channelDef, { forAs: true });
        const newFieldDef = Object.assign(Object.assign(Object.assign({}, isTitleDefined ? [] : { title: title(channelDef, config, { allowDisabling: true }) }), remaining), {
          field: newField
        });
        if (aggOp) {
          let op;
          if (isArgmaxDef(aggOp)) {
            op = "argmax";
            newField = vgField({ op: "argmax", field: aggOp.argmax }, { forAs: true });
            newFieldDef.field = `${newField}.${field}`;
          } else if (isArgminDef(aggOp)) {
            op = "argmin";
            newField = vgField({ op: "argmin", field: aggOp.argmin }, { forAs: true });
            newFieldDef.field = `${newField}.${field}`;
          } else if (aggOp !== "boxplot" && aggOp !== "errorbar" && aggOp !== "errorband") {
            op = aggOp;
          }
          if (op) {
            const aggregateEntry = {
              op,
              as: newField
            };
            if (field) {
              aggregateEntry.field = field;
            }
            aggregate.push(aggregateEntry);
          }
        } else {
          groupby.push(newField);
          if (isTypedFieldDef(channelDef) && isBinning(bin2)) {
            bins2.push({ bin: bin2, field, as: newField });
            groupby.push(vgField(channelDef, { binSuffix: "end" }));
            if (binRequiresRange(channelDef, channel)) {
              groupby.push(vgField(channelDef, { binSuffix: "range" }));
            }
            if (isXorY(channel)) {
              const secondaryChannel = {
                field: `${newField}_end`
              };
              encoding[`${channel}2`] = secondaryChannel;
            }
            newFieldDef.bin = "binned";
            if (!isSecondaryRangeChannel(channel)) {
              newFieldDef["type"] = QUANTITATIVE;
            }
          } else if (timeUnit) {
            timeUnits.push({
              timeUnit,
              field,
              as: newField
            });
            const formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && "time";
            if (formatType) {
              if (channel === TEXT || channel === TOOLTIP) {
                newFieldDef["formatType"] = formatType;
              } else if (isNonPositionScaleChannel(channel)) {
                newFieldDef["legend"] = Object.assign({ formatType }, newFieldDef["legend"]);
              } else if (isXorY(channel)) {
                newFieldDef["axis"] = Object.assign({ formatType }, newFieldDef["axis"]);
              }
            }
          }
        }
        encoding[channel] = newFieldDef;
      } else {
        groupby.push(field);
        encoding[channel] = oldEncoding[channel];
      }
    } else {
      encoding[channel] = oldEncoding[channel];
    }
  });
  return {
    bins: bins2,
    timeUnits,
    aggregate,
    groupby,
    encoding
  };
}
function markChannelCompatible(encoding, channel, mark3) {
  const markSupported = supportMark(channel, mark3);
  if (!markSupported) {
    return false;
  } else if (markSupported === "binned") {
    const primaryFieldDef = encoding[channel === X2 ? X : Y];
    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {
      return true;
    } else {
      return false;
    }
  }
  return true;
}
function initEncoding(encoding, mark3, filled, config) {
  return keys(encoding).reduce((normalizedEncoding, channel) => {
    if (!isChannel(channel)) {
      warn(message_exports.invalidEncodingChannel(channel));
      return normalizedEncoding;
    }
    const channelDef = encoding[channel];
    if (channel === "angle" && mark3 === "arc" && !encoding.theta) {
      warn(message_exports.REPLACE_ANGLE_WITH_THETA);
      channel = THETA;
    }
    if (!markChannelCompatible(encoding, channel, mark3)) {
      warn(message_exports.incompatibleChannel(channel, mark3));
      return normalizedEncoding;
    }
    if (channel === SIZE && mark3 === "line") {
      const fieldDef = getFieldDef(encoding[channel]);
      if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.aggregate) {
        warn(message_exports.LINE_WITH_VARYING_SIZE);
        return normalizedEncoding;
      }
    }
    if (channel === COLOR && (filled ? "fill" in encoding : "stroke" in encoding)) {
      warn(message_exports.droppingColor("encoding", { fill: "fill" in encoding, stroke: "stroke" in encoding }));
      return normalizedEncoding;
    }
    if (channel === DETAIL || channel === ORDER && !isArray2(channelDef) && !isValueDef(channelDef) || channel === TOOLTIP && isArray2(channelDef)) {
      if (channelDef) {
        normalizedEncoding[channel] = array(channelDef).reduce((defs, fieldDef) => {
          if (!isFieldDef(fieldDef)) {
            warn(message_exports.emptyFieldDef(fieldDef, channel));
          } else {
            defs.push(initFieldDef(fieldDef, channel));
          }
          return defs;
        }, []);
      }
    } else {
      if (channel === TOOLTIP && channelDef === null) {
        normalizedEncoding[channel] = null;
      } else if (!isFieldDef(channelDef) && !isDatumDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef) && !isSignalRef(channelDef)) {
        warn(message_exports.emptyFieldDef(channelDef, channel));
        return normalizedEncoding;
      }
      normalizedEncoding[channel] = initChannelDef(channelDef, channel, config);
    }
    return normalizedEncoding;
  }, {});
}
function normalizeEncoding(encoding, config) {
  const normalizedEncoding = {};
  for (const channel of keys(encoding)) {
    const newChannelDef = initChannelDef(encoding[channel], channel, config, { compositeMark: true });
    normalizedEncoding[channel] = newChannelDef;
  }
  return normalizedEncoding;
}
function fieldDefs(encoding) {
  const arr = [];
  for (const channel of keys(encoding)) {
    if (channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      const channelDefArray = array(channelDef);
      for (const def of channelDefArray) {
        if (isFieldDef(def)) {
          arr.push(def);
        } else if (hasConditionalFieldDef(def)) {
          arr.push(def.condition);
        }
      }
    }
  }
  return arr;
}
function forEach(mapping, f, thisArg) {
  if (!mapping) {
    return;
  }
  for (const channel of keys(mapping)) {
    const el = mapping[channel];
    if (isArray2(el)) {
      for (const channelDef of el) {
        f.call(thisArg, channelDef, channel);
      }
    } else {
      f.call(thisArg, el, channel);
    }
  }
}
function reduce(mapping, f, init, thisArg) {
  if (!mapping) {
    return init;
  }
  return keys(mapping).reduce((r, channel) => {
    const map = mapping[channel];
    if (isArray2(map)) {
      return map.reduce((r1, channelDef) => {
        return f.call(thisArg, r1, channelDef, channel);
      }, r);
    } else {
      return f.call(thisArg, r, map, channel);
    }
  }, init);
}
function pathGroupingFields(mark3, encoding) {
  return keys(encoding).reduce((details, channel) => {
    switch (channel) {
      case X:
      case Y:
      case HREF:
      case DESCRIPTION:
      case URL2:
      case X2:
      case Y2:
      case THETA:
      case THETA2:
      case RADIUS:
      case RADIUS2:
      case LATITUDE:
      case LONGITUDE:
      case LATITUDE2:
      case LONGITUDE2:
      case TEXT:
      case SHAPE:
      case ANGLE:
      case TOOLTIP:
        return details;
      case ORDER:
        if (mark3 === "line" || mark3 === "trail") {
          return details;
        }
      case DETAIL:
      case KEY: {
        const channelDef = encoding[channel];
        if (isArray2(channelDef) || isFieldDef(channelDef)) {
          for (const fieldDef of array(channelDef)) {
            if (!fieldDef.aggregate) {
              details.push(vgField(fieldDef, {}));
            }
          }
        }
        return details;
      }
      case SIZE:
        if (mark3 === "trail") {
          return details;
        }
      case COLOR:
      case FILL:
      case STROKE:
      case OPACITY:
      case FILLOPACITY:
      case STROKEOPACITY:
      case STROKEDASH:
      case STROKEWIDTH: {
        const fieldDef = getFieldDef(encoding[channel]);
        if (fieldDef && !fieldDef.aggregate) {
          details.push(vgField(fieldDef, {}));
        }
        return details;
      }
    }
  }, []);
}

// node_modules/vega-lite/build/src/compositemark/common.js
var __rest6 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function filterTooltipWithAggregatedField(oldEncoding) {
  const { tooltip: tooltip2 } = oldEncoding, filteredEncoding = __rest6(oldEncoding, ["tooltip"]);
  if (!tooltip2) {
    return { filteredEncoding };
  }
  let customTooltipWithAggregatedField;
  let customTooltipWithoutAggregatedField;
  if (isArray2(tooltip2)) {
    for (const t2 of tooltip2) {
      if (t2.aggregate) {
        if (!customTooltipWithAggregatedField) {
          customTooltipWithAggregatedField = [];
        }
        customTooltipWithAggregatedField.push(t2);
      } else {
        if (!customTooltipWithoutAggregatedField) {
          customTooltipWithoutAggregatedField = [];
        }
        customTooltipWithoutAggregatedField.push(t2);
      }
    }
    if (customTooltipWithAggregatedField) {
      filteredEncoding.tooltip = customTooltipWithAggregatedField;
    }
  } else {
    if (tooltip2["aggregate"]) {
      filteredEncoding.tooltip = tooltip2;
    } else {
      customTooltipWithoutAggregatedField = tooltip2;
    }
  }
  if (isArray2(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {
    customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];
  }
  return { customTooltipWithoutAggregatedField, filteredEncoding };
}
function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, withFieldName = true) {
  if ("tooltip" in encodingWithoutContinuousAxis) {
    return { tooltip: encodingWithoutContinuousAxis.tooltip };
  }
  const fiveSummaryTooltip = tooltipSummary.map(({ fieldPrefix, titlePrefix }) => {
    const mainTitle = withFieldName ? ` of ${getTitle(continuousAxisChannelDef)}` : "";
    return {
      field: fieldPrefix + continuousAxisChannelDef.field,
      type: continuousAxisChannelDef.type,
      title: isSignalRef(titlePrefix) ? { signal: `${titlePrefix}"${escape(mainTitle)}"` } : titlePrefix + mainTitle
    };
  });
  const tooltipFieldDefs = fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);
  return {
    tooltip: [
      ...fiveSummaryTooltip,
      ...unique(tooltipFieldDefs, hash)
    ]
  };
}
function getTitle(continuousAxisChannelDef) {
  const { title: title2, field } = continuousAxisChannelDef;
  return getFirstDefined(title2, field);
}
function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {
  const { scale, axis } = continuousAxisChannelDef;
  return ({ partName, mark: mark3, positionPrefix, endPositionPrefix = void 0, extraEncoding = {} }) => {
    const title2 = getTitle(continuousAxisChannelDef);
    return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, {
      mark: mark3,
      encoding: Object.assign(Object.assign(Object.assign({ [continuousAxis]: Object.assign(Object.assign(Object.assign({ field: `${positionPrefix}_${continuousAxisChannelDef.field}`, type: continuousAxisChannelDef.type }, title2 !== void 0 ? { title: title2 } : {}), scale !== void 0 ? { scale } : {}), axis !== void 0 ? { axis } : {}) }, isString2(endPositionPrefix) ? {
        [`${continuousAxis}2`]: {
          field: `${endPositionPrefix}_${continuousAxisChannelDef.field}`
        }
      } : {}), sharedEncoding), extraEncoding)
    });
  };
}
function partLayerMixins(markDef, part, compositeMarkConfig, partBaseSpec) {
  const { clip, color: color2, opacity: opacity2 } = markDef;
  const mark3 = markDef.type;
  if (markDef[part] || markDef[part] === void 0 && compositeMarkConfig[part]) {
    return [
      Object.assign(Object.assign({}, partBaseSpec), { mark: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, compositeMarkConfig[part]), clip ? { clip } : {}), color2 ? { color: color2 } : {}), opacity2 ? { opacity: opacity2 } : {}), isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : { type: partBaseSpec.mark }), { style: `${mark3}-${part}` }), isBoolean2(markDef[part]) ? {} : markDef[part]) })
    ];
  }
  return [];
}
function compositeMarkContinuousAxis(spec, orient2, compositeMark) {
  const { encoding } = spec;
  const continuousAxis = orient2 === "vertical" ? "y" : "x";
  const continuousAxisChannelDef = encoding[continuousAxis];
  const continuousAxisChannelDef2 = encoding[`${continuousAxis}2`];
  const continuousAxisChannelDefError = encoding[`${continuousAxis}Error`];
  const continuousAxisChannelDefError2 = encoding[`${continuousAxis}Error2`];
  return {
    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),
    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),
    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),
    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),
    continuousAxis
  };
}
function filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {
  if (continuousAxisChannelDef === null || continuousAxisChannelDef === void 0 ? void 0 : continuousAxisChannelDef.aggregate) {
    const { aggregate } = continuousAxisChannelDef, continuousAxisWithoutAggregate = __rest6(continuousAxisChannelDef, ["aggregate"]);
    if (aggregate !== compositeMark) {
      warn(message_exports.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));
    }
    return continuousAxisWithoutAggregate;
  } else {
    return continuousAxisChannelDef;
  }
}
function compositeMarkOrient(spec, compositeMark) {
  const { mark: mark3, encoding } = spec;
  const { x, y } = encoding;
  if (isMarkDef(mark3) && mark3.orient) {
    return mark3.orient;
  }
  if (isContinuousFieldOrDatumDef(x)) {
    if (isContinuousFieldOrDatumDef(y)) {
      const xAggregate = isFieldDef(x) && x.aggregate;
      const yAggregate = isFieldDef(y) && y.aggregate;
      if (!xAggregate && yAggregate === compositeMark) {
        return "vertical";
      } else if (!yAggregate && xAggregate === compositeMark) {
        return "horizontal";
      } else if (xAggregate === compositeMark && yAggregate === compositeMark) {
        throw new Error("Both x and y cannot have aggregate");
      } else {
        if (isFieldOrDatumDefForTimeFormat(y) && !isFieldOrDatumDefForTimeFormat(x)) {
          return "horizontal";
        }
        return "vertical";
      }
    }
    return "horizontal";
  } else if (isContinuousFieldOrDatumDef(y)) {
    return "vertical";
  } else {
    throw new Error(`Need a valid continuous axis for ${compositeMark}s`);
  }
}

// node_modules/vega-lite/build/src/compositemark/boxplot.js
var __rest7 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var BOXPLOT = "boxplot";
var BOXPLOT_PARTS = ["box", "median", "outliers", "rule", "ticks"];
var boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);
function getBoxPlotType(extent) {
  if (isNumber(extent)) {
    return "tukey";
  }
  return extent;
}
function normalizeBoxPlot(spec, { config }) {
  var _a, _b;
  spec = Object.assign(Object.assign({}, spec), { encoding: normalizeEncoding(spec.encoding, config) });
  const { mark: mark3, encoding: _encoding, params, projection: _p } = spec, outerSpec = __rest7(spec, ["mark", "encoding", "params", "projection"]);
  const markDef = isMarkDef(mark3) ? mark3 : { type: mark3 };
  if (params) {
    warn(message_exports.selectionNotSupported("boxplot"));
  }
  const extent = (_a = markDef.extent) !== null && _a !== void 0 ? _a : config.boxplot.extent;
  const sizeValue = getMarkPropOrConfig("size", markDef, config);
  const boxPlotType = getBoxPlotType(extent);
  const { bins: bins2, timeUnits, transform, continuousAxisChannelDef, continuousAxis, groupby, aggregate, encodingWithoutContinuousAxis, ticksOrient, boxOrient, customTooltipWithoutAggregatedField } = boxParams(spec, extent, config);
  const { color: color2, size } = encodingWithoutContinuousAxis, encodingWithoutSizeColorAndContinuousAxis = __rest7(encodingWithoutContinuousAxis, ["color", "size"]);
  const makeBoxPlotPart = (sharedEncoding) => {
    return makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, config.boxplot);
  };
  const makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);
  const makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);
  const makeBoxPlotMidTick = makeBoxPlotPart(Object.assign(Object.assign({}, encodingWithoutSizeColorAndContinuousAxis), size ? { size } : {}));
  const fiveSummaryTooltipEncoding = getCompositeMarkTooltip([
    { fieldPrefix: boxPlotType === "min-max" ? "upper_whisker_" : "max_", titlePrefix: "Max" },
    { fieldPrefix: "upper_box_", titlePrefix: "Q3" },
    { fieldPrefix: "mid_box_", titlePrefix: "Median" },
    { fieldPrefix: "lower_box_", titlePrefix: "Q1" },
    { fieldPrefix: boxPlotType === "min-max" ? "lower_whisker_" : "min_", titlePrefix: "Min" }
  ], continuousAxisChannelDef, encodingWithoutContinuousAxis);
  const endTick = { type: "tick", color: "black", opacity: 1, orient: ticksOrient, invalid: null, aria: false };
  const whiskerTooltipEncoding = boxPlotType === "min-max" ? fiveSummaryTooltipEncoding : getCompositeMarkTooltip([
    { fieldPrefix: "upper_whisker_", titlePrefix: "Upper Whisker" },
    { fieldPrefix: "lower_whisker_", titlePrefix: "Lower Whisker" }
  ], continuousAxisChannelDef, encodingWithoutContinuousAxis);
  const whiskerLayers = [
    ...makeBoxPlotExtent({
      partName: "rule",
      mark: { type: "rule", invalid: null, aria: false },
      positionPrefix: "lower_whisker",
      endPositionPrefix: "lower_box",
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "rule",
      mark: { type: "rule", invalid: null, aria: false },
      positionPrefix: "upper_box",
      endPositionPrefix: "upper_whisker",
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "ticks",
      mark: endTick,
      positionPrefix: "lower_whisker",
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "ticks",
      mark: endTick,
      positionPrefix: "upper_whisker",
      extraEncoding: whiskerTooltipEncoding
    })
  ];
  const boxLayers = [
    ...boxPlotType !== "tukey" ? whiskerLayers : [],
    ...makeBoxPlotBox({
      partName: "box",
      mark: Object.assign(Object.assign({ type: "bar" }, sizeValue ? { size: sizeValue } : {}), { orient: boxOrient, invalid: null, ariaRoleDescription: "box" }),
      positionPrefix: "lower_box",
      endPositionPrefix: "upper_box",
      extraEncoding: fiveSummaryTooltipEncoding
    }),
    ...makeBoxPlotMidTick({
      partName: "median",
      mark: Object.assign(Object.assign(Object.assign({ type: "tick", invalid: null }, isObject2(config.boxplot.median) && config.boxplot.median.color ? { color: config.boxplot.median.color } : {}), sizeValue ? { size: sizeValue } : {}), { orient: ticksOrient, aria: false }),
      positionPrefix: "mid_box",
      extraEncoding: fiveSummaryTooltipEncoding
    })
  ];
  if (boxPlotType === "min-max") {
    return Object.assign(Object.assign({}, outerSpec), { transform: ((_b = outerSpec.transform) !== null && _b !== void 0 ? _b : []).concat(transform), layer: boxLayers });
  }
  const lowerBoxExpr = `datum["lower_box_${continuousAxisChannelDef.field}"]`;
  const upperBoxExpr = `datum["upper_box_${continuousAxisChannelDef.field}"]`;
  const iqrExpr = `(${upperBoxExpr} - ${lowerBoxExpr})`;
  const lowerWhiskerExpr = `${lowerBoxExpr} - ${extent} * ${iqrExpr}`;
  const upperWhiskerExpr = `${upperBoxExpr} + ${extent} * ${iqrExpr}`;
  const fieldExpr2 = `datum["${continuousAxisChannelDef.field}"]`;
  const joinaggregateTransform = {
    joinaggregate: boxParamsQuartiles(continuousAxisChannelDef.field),
    groupby
  };
  const filteredWhiskerSpec = {
    transform: [
      {
        filter: `(${lowerWhiskerExpr} <= ${fieldExpr2}) && (${fieldExpr2} <= ${upperWhiskerExpr})`
      },
      {
        aggregate: [
          {
            op: "min",
            field: continuousAxisChannelDef.field,
            as: `lower_whisker_${continuousAxisChannelDef.field}`
          },
          {
            op: "max",
            field: continuousAxisChannelDef.field,
            as: `upper_whisker_${continuousAxisChannelDef.field}`
          },
          {
            op: "min",
            field: `lower_box_${continuousAxisChannelDef.field}`,
            as: `lower_box_${continuousAxisChannelDef.field}`
          },
          {
            op: "max",
            field: `upper_box_${continuousAxisChannelDef.field}`,
            as: `upper_box_${continuousAxisChannelDef.field}`
          },
          ...aggregate
        ],
        groupby
      }
    ],
    layer: whiskerLayers
  };
  const { tooltip: tooltip2 } = encodingWithoutSizeColorAndContinuousAxis, encodingWithoutSizeColorContinuousAxisAndTooltip = __rest7(encodingWithoutSizeColorAndContinuousAxis, ["tooltip"]);
  const { scale, axis } = continuousAxisChannelDef;
  const title2 = getTitle(continuousAxisChannelDef);
  const axisWithoutTitle = omit(axis, ["title"]);
  const outlierLayersMixins = partLayerMixins(markDef, "outliers", config.boxplot, {
    transform: [{ filter: `(${fieldExpr2} < ${lowerWhiskerExpr}) || (${fieldExpr2} > ${upperWhiskerExpr})` }],
    mark: "point",
    encoding: Object.assign(Object.assign(Object.assign({ [continuousAxis]: Object.assign(Object.assign(Object.assign({ field: continuousAxisChannelDef.field, type: continuousAxisChannelDef.type }, title2 !== void 0 ? { title: title2 } : {}), scale !== void 0 ? { scale } : {}), isEmpty(axisWithoutTitle) ? {} : { axis: axisWithoutTitle }) }, encodingWithoutSizeColorContinuousAxisAndTooltip), color2 ? { color: color2 } : {}), customTooltipWithoutAggregatedField ? { tooltip: customTooltipWithoutAggregatedField } : {})
  })[0];
  let filteredLayersMixins;
  const filteredLayersMixinsTransforms = [...bins2, ...timeUnits, joinaggregateTransform];
  if (outlierLayersMixins) {
    filteredLayersMixins = {
      transform: filteredLayersMixinsTransforms,
      layer: [outlierLayersMixins, filteredWhiskerSpec]
    };
  } else {
    filteredLayersMixins = filteredWhiskerSpec;
    filteredLayersMixins.transform.unshift(...filteredLayersMixinsTransforms);
  }
  return Object.assign(Object.assign({}, outerSpec), { layer: [
    filteredLayersMixins,
    {
      transform,
      layer: boxLayers
    }
  ] });
}
function boxParamsQuartiles(continousAxisField) {
  return [
    {
      op: "q1",
      field: continousAxisField,
      as: `lower_box_${continousAxisField}`
    },
    {
      op: "q3",
      field: continousAxisField,
      as: `upper_box_${continousAxisField}`
    }
  ];
}
function boxParams(spec, extent, config) {
  const orient2 = compositeMarkOrient(spec, BOXPLOT);
  const { continuousAxisChannelDef, continuousAxis } = compositeMarkContinuousAxis(spec, orient2, BOXPLOT);
  const continuousFieldName = continuousAxisChannelDef.field;
  const boxPlotType = getBoxPlotType(extent);
  const boxplotSpecificAggregate = [
    ...boxParamsQuartiles(continuousFieldName),
    {
      op: "median",
      field: continuousFieldName,
      as: `mid_box_${continuousFieldName}`
    },
    {
      op: "min",
      field: continuousFieldName,
      as: (boxPlotType === "min-max" ? "lower_whisker_" : "min_") + continuousFieldName
    },
    {
      op: "max",
      field: continuousFieldName,
      as: (boxPlotType === "min-max" ? "upper_whisker_" : "max_") + continuousFieldName
    }
  ];
  const postAggregateCalculates = boxPlotType === "min-max" || boxPlotType === "tukey" ? [] : [
    {
      calculate: `datum["upper_box_${continuousFieldName}"] - datum["lower_box_${continuousFieldName}"]`,
      as: `iqr_${continuousFieldName}`
    },
    {
      calculate: `min(datum["upper_box_${continuousFieldName}"] + datum["iqr_${continuousFieldName}"] * ${extent}, datum["max_${continuousFieldName}"])`,
      as: `upper_whisker_${continuousFieldName}`
    },
    {
      calculate: `max(datum["lower_box_${continuousFieldName}"] - datum["iqr_${continuousFieldName}"] * ${extent}, datum["min_${continuousFieldName}"])`,
      as: `lower_whisker_${continuousFieldName}`
    }
  ];
  const _a = spec.encoding, _b = continuousAxis, oldContinuousAxisChannelDef = _a[_b], oldEncodingWithoutContinuousAxis = __rest7(_a, [typeof _b === "symbol" ? _b : _b + ""]);
  const { customTooltipWithoutAggregatedField, filteredEncoding } = filterTooltipWithAggregatedField(oldEncodingWithoutContinuousAxis);
  const { bins: bins2, timeUnits, aggregate, groupby, encoding: encodingWithoutContinuousAxis } = extractTransformsFromEncoding(filteredEncoding, config);
  const ticksOrient = orient2 === "vertical" ? "horizontal" : "vertical";
  const boxOrient = orient2;
  const transform = [
    ...bins2,
    ...timeUnits,
    {
      aggregate: [...aggregate, ...boxplotSpecificAggregate],
      groupby
    },
    ...postAggregateCalculates
  ];
  return {
    bins: bins2,
    timeUnits,
    transform,
    groupby,
    aggregate,
    continuousAxisChannelDef,
    continuousAxis,
    encodingWithoutContinuousAxis,
    ticksOrient,
    boxOrient,
    customTooltipWithoutAggregatedField
  };
}

// node_modules/vega-lite/build/src/compositemark/errorbar.js
var __rest8 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var ERRORBAR = "errorbar";
var ERRORBAR_PARTS = ["ticks", "rule"];
var errorBarNormalizer = new CompositeMarkNormalizer(ERRORBAR, normalizeErrorBar);
function normalizeErrorBar(spec, { config }) {
  spec = Object.assign(Object.assign({}, spec), { encoding: normalizeEncoding(spec.encoding, config) });
  const { transform, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, ticksOrient, markDef, outerSpec, tooltipEncoding } = errorBarParams(spec, ERRORBAR, config);
  delete encodingWithoutContinuousAxis["size"];
  const makeErrorBarPart = makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorbar);
  const thickness = markDef.thickness;
  const size = markDef.size;
  const tick2 = Object.assign(Object.assign({ type: "tick", orient: ticksOrient, aria: false }, thickness !== void 0 ? { thickness } : {}), size !== void 0 ? { size } : {});
  const layer = [
    ...makeErrorBarPart({
      partName: "ticks",
      mark: tick2,
      positionPrefix: "lower",
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBarPart({
      partName: "ticks",
      mark: tick2,
      positionPrefix: "upper",
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBarPart({
      partName: "rule",
      mark: Object.assign({ type: "rule", ariaRoleDescription: "errorbar" }, thickness !== void 0 ? { size: thickness } : {}),
      positionPrefix: "lower",
      endPositionPrefix: "upper",
      extraEncoding: tooltipEncoding
    })
  ];
  return Object.assign(Object.assign(Object.assign({}, outerSpec), { transform }), layer.length > 1 ? { layer } : Object.assign({}, layer[0]));
}
function errorBarOrientAndInputType(spec, compositeMark) {
  const { encoding } = spec;
  if (errorBarIsInputTypeRaw(encoding)) {
    return {
      orient: compositeMarkOrient(spec, compositeMark),
      inputType: "raw"
    };
  }
  const isTypeAggregatedUpperLower = errorBarIsInputTypeAggregatedUpperLower(encoding);
  const isTypeAggregatedError = errorBarIsInputTypeAggregatedError(encoding);
  const x = encoding.x;
  const y = encoding.y;
  if (isTypeAggregatedUpperLower) {
    if (isTypeAggregatedError) {
      throw new Error(`${compositeMark} cannot be both type aggregated-upper-lower and aggregated-error`);
    }
    const x2 = encoding.x2;
    const y2 = encoding.y2;
    if (isFieldOrDatumDef(x2) && isFieldOrDatumDef(y2)) {
      throw new Error(`${compositeMark} cannot have both x2 and y2`);
    } else if (isFieldOrDatumDef(x2)) {
      if (isContinuousFieldOrDatumDef(x)) {
        return { orient: "horizontal", inputType: "aggregated-upper-lower" };
      } else {
        throw new Error(`Both x and x2 have to be quantitative in ${compositeMark}`);
      }
    } else if (isFieldOrDatumDef(y2)) {
      if (isContinuousFieldOrDatumDef(y)) {
        return { orient: "vertical", inputType: "aggregated-upper-lower" };
      } else {
        throw new Error(`Both y and y2 have to be quantitative in ${compositeMark}`);
      }
    }
    throw new Error("No ranged axis");
  } else {
    const xError = encoding.xError;
    const xError2 = encoding.xError2;
    const yError = encoding.yError;
    const yError2 = encoding.yError2;
    if (isFieldOrDatumDef(xError2) && !isFieldOrDatumDef(xError)) {
      throw new Error(`${compositeMark} cannot have xError2 without xError`);
    }
    if (isFieldOrDatumDef(yError2) && !isFieldOrDatumDef(yError)) {
      throw new Error(`${compositeMark} cannot have yError2 without yError`);
    }
    if (isFieldOrDatumDef(xError) && isFieldOrDatumDef(yError)) {
      throw new Error(`${compositeMark} cannot have both xError and yError with both are quantiative`);
    } else if (isFieldOrDatumDef(xError)) {
      if (isContinuousFieldOrDatumDef(x)) {
        return { orient: "horizontal", inputType: "aggregated-error" };
      } else {
        throw new Error("All x, xError, and xError2 (if exist) have to be quantitative");
      }
    } else if (isFieldOrDatumDef(yError)) {
      if (isContinuousFieldOrDatumDef(y)) {
        return { orient: "vertical", inputType: "aggregated-error" };
      } else {
        throw new Error("All y, yError, and yError2 (if exist) have to be quantitative");
      }
    }
    throw new Error("No ranged axis");
  }
}
function errorBarIsInputTypeRaw(encoding) {
  return (isFieldOrDatumDef(encoding.x) || isFieldOrDatumDef(encoding.y)) && !isFieldOrDatumDef(encoding.x2) && !isFieldOrDatumDef(encoding.y2) && !isFieldOrDatumDef(encoding.xError) && !isFieldOrDatumDef(encoding.xError2) && !isFieldOrDatumDef(encoding.yError) && !isFieldOrDatumDef(encoding.yError2);
}
function errorBarIsInputTypeAggregatedUpperLower(encoding) {
  return isFieldOrDatumDef(encoding.x2) || isFieldOrDatumDef(encoding.y2);
}
function errorBarIsInputTypeAggregatedError(encoding) {
  return isFieldOrDatumDef(encoding.xError) || isFieldOrDatumDef(encoding.xError2) || isFieldOrDatumDef(encoding.yError) || isFieldOrDatumDef(encoding.yError2);
}
function errorBarParams(spec, compositeMark, config) {
  var _a;
  const { mark: mark3, encoding, params, projection: _p } = spec, outerSpec = __rest8(spec, ["mark", "encoding", "params", "projection"]);
  const markDef = isMarkDef(mark3) ? mark3 : { type: mark3 };
  if (params) {
    warn(message_exports.selectionNotSupported(compositeMark));
  }
  const { orient: orient2, inputType } = errorBarOrientAndInputType(spec, compositeMark);
  const { continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, continuousAxis } = compositeMarkContinuousAxis(spec, orient2, compositeMark);
  const { errorBarSpecificAggregate, postAggregateCalculates, tooltipSummary, tooltipTitleWithFieldName } = errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config);
  const _b = encoding, _c = continuousAxis, oldContinuousAxisChannelDef = _b[_c], _d = continuousAxis === "x" ? "x2" : "y2", oldContinuousAxisChannelDef2 = _b[_d], _e = continuousAxis === "x" ? "xError" : "yError", oldContinuousAxisChannelDefError = _b[_e], _f = continuousAxis === "x" ? "xError2" : "yError2", oldContinuousAxisChannelDefError2 = _b[_f], oldEncodingWithoutContinuousAxis = __rest8(_b, [typeof _c === "symbol" ? _c : _c + "", typeof _d === "symbol" ? _d : _d + "", typeof _e === "symbol" ? _e : _e + "", typeof _f === "symbol" ? _f : _f + ""]);
  const { bins: bins2, timeUnits, aggregate: oldAggregate, groupby: oldGroupBy, encoding: encodingWithoutContinuousAxis } = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config);
  const aggregate = [...oldAggregate, ...errorBarSpecificAggregate];
  const groupby = inputType !== "raw" ? [] : oldGroupBy;
  const tooltipEncoding = getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, tooltipTitleWithFieldName);
  return {
    transform: [
      ...(_a = outerSpec.transform) !== null && _a !== void 0 ? _a : [],
      ...bins2,
      ...timeUnits,
      ...aggregate.length === 0 ? [] : [{ aggregate, groupby }],
      ...postAggregateCalculates
    ],
    groupby,
    continuousAxisChannelDef,
    continuousAxis,
    encodingWithoutContinuousAxis,
    ticksOrient: orient2 === "vertical" ? "horizontal" : "vertical",
    markDef,
    outerSpec,
    tooltipEncoding
  };
}
function errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config) {
  let errorBarSpecificAggregate = [];
  let postAggregateCalculates = [];
  const continuousFieldName = continuousAxisChannelDef.field;
  let tooltipSummary;
  let tooltipTitleWithFieldName = false;
  if (inputType === "raw") {
    const center = markDef.center ? markDef.center : markDef.extent ? markDef.extent === "iqr" ? "median" : "mean" : config.errorbar.center;
    const extent = markDef.extent ? markDef.extent : center === "mean" ? "stderr" : "iqr";
    if (center === "median" !== (extent === "iqr")) {
      warn(message_exports.errorBarCenterIsUsedWithWrongExtent(center, extent, compositeMark));
    }
    if (extent === "stderr" || extent === "stdev") {
      errorBarSpecificAggregate = [
        { op: extent, field: continuousFieldName, as: `extent_${continuousFieldName}` },
        { op: center, field: continuousFieldName, as: `center_${continuousFieldName}` }
      ];
      postAggregateCalculates = [
        {
          calculate: `datum["center_${continuousFieldName}"] + datum["extent_${continuousFieldName}"]`,
          as: `upper_${continuousFieldName}`
        },
        {
          calculate: `datum["center_${continuousFieldName}"] - datum["extent_${continuousFieldName}"]`,
          as: `lower_${continuousFieldName}`
        }
      ];
      tooltipSummary = [
        { fieldPrefix: "center_", titlePrefix: titleCase(center) },
        { fieldPrefix: "upper_", titlePrefix: getTitlePrefix(center, extent, "+") },
        { fieldPrefix: "lower_", titlePrefix: getTitlePrefix(center, extent, "-") }
      ];
      tooltipTitleWithFieldName = true;
    } else {
      let centerOp;
      let lowerExtentOp;
      let upperExtentOp;
      if (extent === "ci") {
        centerOp = "mean";
        lowerExtentOp = "ci0";
        upperExtentOp = "ci1";
      } else {
        centerOp = "median";
        lowerExtentOp = "q1";
        upperExtentOp = "q3";
      }
      errorBarSpecificAggregate = [
        { op: lowerExtentOp, field: continuousFieldName, as: `lower_${continuousFieldName}` },
        { op: upperExtentOp, field: continuousFieldName, as: `upper_${continuousFieldName}` },
        { op: centerOp, field: continuousFieldName, as: `center_${continuousFieldName}` }
      ];
      tooltipSummary = [
        {
          fieldPrefix: "upper_",
          titlePrefix: title({ field: continuousFieldName, aggregate: upperExtentOp, type: "quantitative" }, config, {
            allowDisabling: false
          })
        },
        {
          fieldPrefix: "lower_",
          titlePrefix: title({ field: continuousFieldName, aggregate: lowerExtentOp, type: "quantitative" }, config, {
            allowDisabling: false
          })
        },
        {
          fieldPrefix: "center_",
          titlePrefix: title({ field: continuousFieldName, aggregate: centerOp, type: "quantitative" }, config, {
            allowDisabling: false
          })
        }
      ];
    }
  } else {
    if (markDef.center || markDef.extent) {
      warn(message_exports.errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));
    }
    if (inputType === "aggregated-upper-lower") {
      tooltipSummary = [];
      postAggregateCalculates = [
        { calculate: `datum["${continuousAxisChannelDef2.field}"]`, as: `upper_${continuousFieldName}` },
        { calculate: `datum["${continuousFieldName}"]`, as: `lower_${continuousFieldName}` }
      ];
    } else if (inputType === "aggregated-error") {
      tooltipSummary = [{ fieldPrefix: "", titlePrefix: continuousFieldName }];
      postAggregateCalculates = [
        {
          calculate: `datum["${continuousFieldName}"] + datum["${continuousAxisChannelDefError.field}"]`,
          as: `upper_${continuousFieldName}`
        }
      ];
      if (continuousAxisChannelDefError2) {
        postAggregateCalculates.push({
          calculate: `datum["${continuousFieldName}"] + datum["${continuousAxisChannelDefError2.field}"]`,
          as: `lower_${continuousFieldName}`
        });
      } else {
        postAggregateCalculates.push({
          calculate: `datum["${continuousFieldName}"] - datum["${continuousAxisChannelDefError.field}"]`,
          as: `lower_${continuousFieldName}`
        });
      }
    }
    for (const postAggregateCalculate of postAggregateCalculates) {
      tooltipSummary.push({
        fieldPrefix: postAggregateCalculate.as.substring(0, 6),
        titlePrefix: replaceAll(replaceAll(postAggregateCalculate.calculate, 'datum["', ""), '"]', "")
      });
    }
  }
  return { postAggregateCalculates, errorBarSpecificAggregate, tooltipSummary, tooltipTitleWithFieldName };
}
function getTitlePrefix(center, extent, operation) {
  return `${titleCase(center)} ${operation} ${extent}`;
}

// node_modules/vega-lite/build/src/compositemark/errorband.js
var ERRORBAND = "errorband";
var ERRORBAND_PARTS = ["band", "borders"];
var errorBandNormalizer = new CompositeMarkNormalizer(ERRORBAND, normalizeErrorBand);
function normalizeErrorBand(spec, { config }) {
  spec = Object.assign(Object.assign({}, spec), { encoding: normalizeEncoding(spec.encoding, config) });
  const { transform, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, markDef, outerSpec, tooltipEncoding } = errorBarParams(spec, ERRORBAND, config);
  const errorBandDef = markDef;
  const makeErrorBandPart = makeCompositeAggregatePartFactory(errorBandDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorband);
  const is2D = spec.encoding.x !== void 0 && spec.encoding.y !== void 0;
  let bandMark = { type: is2D ? "area" : "rect" };
  let bordersMark = { type: is2D ? "line" : "rule" };
  const interpolate2 = Object.assign(Object.assign({}, errorBandDef.interpolate ? { interpolate: errorBandDef.interpolate } : {}), errorBandDef.tension && errorBandDef.interpolate ? { tension: errorBandDef.tension } : {});
  if (is2D) {
    bandMark = Object.assign(Object.assign(Object.assign({}, bandMark), interpolate2), { ariaRoleDescription: "errorband" });
    bordersMark = Object.assign(Object.assign(Object.assign({}, bordersMark), interpolate2), { aria: false });
  } else if (errorBandDef.interpolate) {
    warn(message_exports.errorBand1DNotSupport("interpolate"));
  } else if (errorBandDef.tension) {
    warn(message_exports.errorBand1DNotSupport("tension"));
  }
  return Object.assign(Object.assign({}, outerSpec), { transform, layer: [
    ...makeErrorBandPart({
      partName: "band",
      mark: bandMark,
      positionPrefix: "lower",
      endPositionPrefix: "upper",
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBandPart({
      partName: "borders",
      mark: bordersMark,
      positionPrefix: "lower",
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBandPart({
      partName: "borders",
      mark: bordersMark,
      positionPrefix: "upper",
      extraEncoding: tooltipEncoding
    })
  ] });
}

// node_modules/vega-lite/build/src/compositemark/index.js
var compositeMarkRegistry = {};
function add(mark3, run, parts) {
  const normalizer = new CompositeMarkNormalizer(mark3, run);
  compositeMarkRegistry[mark3] = { normalizer, parts };
}
function getAllCompositeMarks() {
  return keys(compositeMarkRegistry);
}
add(BOXPLOT, normalizeBoxPlot, BOXPLOT_PARTS);
add(ERRORBAR, normalizeErrorBar, ERRORBAR_PARTS);
add(ERRORBAND, normalizeErrorBand, ERRORBAND_PARTS);

// node_modules/vega-lite/build/src/guide.js
var VL_ONLY_LEGEND_CONFIG = [
  "gradientHorizontalMaxLength",
  "gradientHorizontalMinLength",
  "gradientVerticalMaxLength",
  "gradientVerticalMinLength",
  "unselectedOpacity"
];

// node_modules/vega-lite/build/src/header.js
var HEADER_TITLE_PROPERTIES_MAP = {
  titleAlign: "align",
  titleAnchor: "anchor",
  titleAngle: "angle",
  titleBaseline: "baseline",
  titleColor: "color",
  titleFont: "font",
  titleFontSize: "fontSize",
  titleFontStyle: "fontStyle",
  titleFontWeight: "fontWeight",
  titleLimit: "limit",
  titleLineHeight: "lineHeight",
  titleOrient: "orient",
  titlePadding: "offset"
};
var HEADER_LABEL_PROPERTIES_MAP = {
  labelAlign: "align",
  labelAnchor: "anchor",
  labelAngle: "angle",
  labelBaseline: "baseline",
  labelColor: "color",
  labelFont: "font",
  labelFontSize: "fontSize",
  labelFontStyle: "fontStyle",
  labelFontWeight: "fontWeight",
  labelLimit: "limit",
  labelLineHeight: "lineHeight",
  labelOrient: "orient",
  labelPadding: "offset"
};
var HEADER_TITLE_PROPERTIES = keys(HEADER_TITLE_PROPERTIES_MAP);
var HEADER_LABEL_PROPERTIES = keys(HEADER_LABEL_PROPERTIES_MAP);
var HEADER_CONFIGS_INDEX = {
  header: 1,
  headerRow: 1,
  headerColumn: 1,
  headerFacet: 1
};
var HEADER_CONFIGS = keys(HEADER_CONFIGS_INDEX);

// node_modules/vega-lite/build/src/legend.js
var LEGEND_SCALE_CHANNELS = [
  "size",
  "shape",
  "fill",
  "stroke",
  "strokeDash",
  "strokeWidth",
  "opacity"
];
var defaultLegendConfig = {
  gradientHorizontalMaxLength: 200,
  gradientHorizontalMinLength: 100,
  gradientVerticalMaxLength: 200,
  gradientVerticalMinLength: 64,
  unselectedOpacity: 0.35
};
var COMMON_LEGEND_PROPERTY_INDEX = {
  aria: 1,
  clipHeight: 1,
  columnPadding: 1,
  columns: 1,
  cornerRadius: 1,
  description: 1,
  direction: 1,
  fillColor: 1,
  format: 1,
  formatType: 1,
  gradientLength: 1,
  gradientOpacity: 1,
  gradientStrokeColor: 1,
  gradientStrokeWidth: 1,
  gradientThickness: 1,
  gridAlign: 1,
  labelAlign: 1,
  labelBaseline: 1,
  labelColor: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labelSeparation: 1,
  legendX: 1,
  legendY: 1,
  offset: 1,
  orient: 1,
  padding: 1,
  rowPadding: 1,
  strokeColor: 1,
  symbolDash: 1,
  symbolDashOffset: 1,
  symbolFillColor: 1,
  symbolLimit: 1,
  symbolOffset: 1,
  symbolOpacity: 1,
  symbolSize: 1,
  symbolStrokeColor: 1,
  symbolStrokeWidth: 1,
  symbolType: 1,
  tickCount: 1,
  tickMinStep: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titleOrient: 1,
  titlePadding: 1,
  type: 1,
  values: 1,
  zindex: 1
};
var LEGEND_PROPERTIES = keys(COMMON_LEGEND_PROPERTY_INDEX);

// node_modules/vega-lite/build/src/selection.js
var SELECTION_ID = "_vgsid_";
var defaultConfig = {
  point: {
    on: "click",
    fields: [SELECTION_ID],
    toggle: "event.shiftKey",
    resolve: "global",
    clear: "dblclick"
  },
  interval: {
    on: "[mousedown, window:mouseup] > window:mousemove!",
    encodings: ["x", "y"],
    translate: "[mousedown, window:mouseup] > window:mousemove!",
    zoom: "wheel!",
    mark: { fill: "#333", fillOpacity: 0.125, stroke: "white" },
    resolve: "global",
    clear: "dblclick"
  }
};
function isLegendBinding(bind) {
  return !!bind && (bind === "legend" || !!bind.legend);
}
function isLegendStreamBinding(bind) {
  return isLegendBinding(bind) && isObject2(bind);
}
function isSelectionParameter(param) {
  return !!param["select"];
}

// node_modules/vega-lite/build/src/parameter.js
var __rest9 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function assembleParameterSignals(params) {
  const signals = [];
  for (const param of params || []) {
    if (isSelectionParameter(param))
      continue;
    const { expr, bind } = param, rest = __rest9(param, ["expr", "bind"]);
    if (bind && expr) {
      const signal = Object.assign(Object.assign({}, rest), { bind, init: expr });
      signals.push(signal);
    } else {
      const signal = Object.assign(Object.assign(Object.assign({}, rest), expr ? { update: expr } : {}), bind ? { bind } : {});
      signals.push(signal);
    }
  }
  return signals;
}

// node_modules/vega-lite/build/src/spec/concat.js
function isAnyConcatSpec(spec) {
  return isVConcatSpec(spec) || isHConcatSpec(spec) || isConcatSpec(spec);
}
function isConcatSpec(spec) {
  return "concat" in spec;
}
function isVConcatSpec(spec) {
  return "vconcat" in spec;
}
function isHConcatSpec(spec) {
  return "hconcat" in spec;
}

// node_modules/vega-lite/build/src/spec/base.js
function isStep(size) {
  return isObject2(size) && size["step"] !== void 0;
}
function isFrameMixins(o) {
  return o["view"] || o["width"] || o["height"];
}
var DEFAULT_SPACING = 20;
var COMPOSITION_LAYOUT_INDEX = {
  align: 1,
  bounds: 1,
  center: 1,
  columns: 1,
  spacing: 1
};
var COMPOSITION_LAYOUT_PROPERTIES = keys(COMPOSITION_LAYOUT_INDEX);
function extractCompositionLayout(spec, specType, config) {
  var _a, _b;
  const compositionConfig = config[specType];
  const layout = {};
  const { spacing: spacingConfig, columns } = compositionConfig;
  if (spacingConfig !== void 0) {
    layout.spacing = spacingConfig;
  }
  if (columns !== void 0) {
    if (isFacetSpec(spec) && !isFacetMapping(spec.facet) || isConcatSpec(spec)) {
      layout.columns = columns;
    }
  }
  if (isVConcatSpec(spec)) {
    layout.columns = 1;
  }
  for (const prop of COMPOSITION_LAYOUT_PROPERTIES) {
    if (spec[prop] !== void 0) {
      if (prop === "spacing") {
        const spacing = spec[prop];
        layout[prop] = isNumber(spacing) ? spacing : {
          row: (_a = spacing.row) !== null && _a !== void 0 ? _a : spacingConfig,
          column: (_b = spacing.column) !== null && _b !== void 0 ? _b : spacingConfig
        };
      } else {
        layout[prop] = spec[prop];
      }
    }
  }
  return layout;
}

// node_modules/vega-lite/build/src/config.js
var __rest10 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function getViewConfigContinuousSize(viewConfig, channel) {
  var _a;
  return (_a = viewConfig[channel]) !== null && _a !== void 0 ? _a : viewConfig[channel === "width" ? "continuousWidth" : "continuousHeight"];
}
function getViewConfigDiscreteStep(viewConfig, channel) {
  const size = getViewConfigDiscreteSize(viewConfig, channel);
  return isStep(size) ? size.step : DEFAULT_STEP;
}
function getViewConfigDiscreteSize(viewConfig, channel) {
  var _a;
  const size = (_a = viewConfig[channel]) !== null && _a !== void 0 ? _a : viewConfig[channel === "width" ? "discreteWidth" : "discreteHeight"];
  return getFirstDefined(size, { step: viewConfig.step });
}
var DEFAULT_STEP = 20;
var defaultViewConfig = {
  continuousWidth: 200,
  continuousHeight: 200,
  step: DEFAULT_STEP
};
var defaultConfig2 = {
  background: "white",
  padding: 5,
  timeFormat: "%b %d, %Y",
  countTitle: "Count of Records",
  view: defaultViewConfig,
  mark: defaultMarkConfig,
  arc: {},
  area: {},
  bar: defaultBarConfig,
  circle: {},
  geoshape: {},
  image: {},
  line: {},
  point: {},
  rect: defaultRectConfig,
  rule: { color: "black" },
  square: {},
  text: { color: "black" },
  tick: defaultTickConfig,
  trail: {},
  boxplot: {
    size: 14,
    extent: 1.5,
    box: {},
    median: { color: "white" },
    outliers: {},
    rule: {},
    ticks: null
  },
  errorbar: {
    center: "mean",
    rule: true,
    ticks: false
  },
  errorband: {
    band: {
      opacity: 0.3
    },
    borders: false
  },
  scale: defaultScaleConfig,
  projection: {},
  legend: defaultLegendConfig,
  header: { titlePadding: 10, labelPadding: 10 },
  headerColumn: {},
  headerRow: {},
  headerFacet: {},
  selection: defaultConfig,
  style: {},
  title: {},
  facet: { spacing: DEFAULT_SPACING },
  concat: { spacing: DEFAULT_SPACING }
};
var tab10 = [
  "#4c78a8",
  "#f58518",
  "#e45756",
  "#72b7b2",
  "#54a24b",
  "#eeca3b",
  "#b279a2",
  "#ff9da6",
  "#9d755d",
  "#bab0ac"
];
var DEFAULT_FONT_SIZE = {
  text: 11,
  guideLabel: 10,
  guideTitle: 11,
  groupTitle: 13,
  groupSubtitle: 12
};
var DEFAULT_COLOR = {
  blue: tab10[0],
  orange: tab10[1],
  red: tab10[2],
  teal: tab10[3],
  green: tab10[4],
  yellow: tab10[5],
  purple: tab10[6],
  pink: tab10[7],
  brown: tab10[8],
  gray0: "#000",
  gray1: "#111",
  gray2: "#222",
  gray3: "#333",
  gray4: "#444",
  gray5: "#555",
  gray6: "#666",
  gray7: "#777",
  gray8: "#888",
  gray9: "#999",
  gray10: "#aaa",
  gray11: "#bbb",
  gray12: "#ccc",
  gray13: "#ddd",
  gray14: "#eee",
  gray15: "#fff"
};
function colorSignalConfig(color2 = {}) {
  return {
    signals: [
      {
        name: "color",
        value: isObject2(color2) ? Object.assign(Object.assign({}, DEFAULT_COLOR), color2) : DEFAULT_COLOR
      }
    ],
    mark: { color: { signal: "color.blue" } },
    rule: { color: { signal: "color.gray0" } },
    text: {
      color: { signal: "color.gray0" }
    },
    style: {
      "guide-label": {
        fill: { signal: "color.gray0" }
      },
      "guide-title": {
        fill: { signal: "color.gray0" }
      },
      "group-title": {
        fill: { signal: "color.gray0" }
      },
      "group-subtitle": {
        fill: { signal: "color.gray0" }
      },
      cell: {
        stroke: { signal: "color.gray8" }
      }
    },
    axis: {
      domainColor: { signal: "color.gray13" },
      gridColor: { signal: "color.gray8" },
      tickColor: { signal: "color.gray13" }
    },
    range: {
      category: [
        { signal: "color.blue" },
        { signal: "color.orange" },
        { signal: "color.red" },
        { signal: "color.teal" },
        { signal: "color.green" },
        { signal: "color.yellow" },
        { signal: "color.purple" },
        { signal: "color.pink" },
        { signal: "color.brown" },
        { signal: "color.grey8" }
      ]
    }
  };
}
function fontSizeSignalConfig(fontSize) {
  return {
    signals: [
      {
        name: "fontSize",
        value: isObject2(fontSize) ? Object.assign(Object.assign({}, DEFAULT_FONT_SIZE), fontSize) : DEFAULT_FONT_SIZE
      }
    ],
    text: {
      fontSize: { signal: "fontSize.text" }
    },
    style: {
      "guide-label": {
        fontSize: { signal: "fontSize.guideLabel" }
      },
      "guide-title": {
        fontSize: { signal: "fontSize.guideTitle" }
      },
      "group-title": {
        fontSize: { signal: "fontSize.groupTitle" }
      },
      "group-subtitle": {
        fontSize: { signal: "fontSize.groupSubtitle" }
      }
    }
  };
}
function fontConfig(font2) {
  return {
    text: { font: font2 },
    style: {
      "guide-label": { font: font2 },
      "guide-title": { font: font2 },
      "group-title": { font: font2 },
      "group-subtitle": { font: font2 }
    }
  };
}
function getAxisConfigInternal(axisConfig) {
  const props = keys(axisConfig || {});
  const axisConfigInternal = {};
  for (const prop of props) {
    const val = axisConfig[prop];
    axisConfigInternal[prop] = isConditionalAxisValue(val) ? signalOrValueRefWithCondition(val) : signalRefOrValue(val);
  }
  return axisConfigInternal;
}
function getStyleConfigInternal(styleConfig) {
  const props = keys(styleConfig);
  const styleConfigInternal = {};
  for (const prop of props) {
    styleConfigInternal[prop] = getAxisConfigInternal(styleConfig[prop]);
  }
  return styleConfigInternal;
}
var configPropsWithExpr = [
  ...MARK_CONFIGS,
  ...AXIS_CONFIGS,
  ...HEADER_CONFIGS,
  "background",
  "padding",
  "legend",
  "lineBreak",
  "scale",
  "style",
  "title",
  "view"
];
function initConfig(specifiedConfig = {}) {
  const { color: color2, font: font2, fontSize, selection } = specifiedConfig, restConfig = __rest10(specifiedConfig, ["color", "font", "fontSize", "selection"]);
  const mergedConfig = mergeConfig2({}, duplicate(defaultConfig2), font2 ? fontConfig(font2) : {}, color2 ? colorSignalConfig(color2) : {}, fontSize ? fontSizeSignalConfig(fontSize) : {}, restConfig || {});
  if (selection) {
    writeConfig(mergedConfig, "selection", selection, true);
  }
  const outputConfig = omit(mergedConfig, configPropsWithExpr);
  for (const prop of ["background", "lineBreak", "padding"]) {
    if (mergedConfig[prop]) {
      outputConfig[prop] = signalRefOrValue(mergedConfig[prop]);
    }
  }
  for (const markConfigType of MARK_CONFIGS) {
    if (mergedConfig[markConfigType]) {
      outputConfig[markConfigType] = replaceExprRef(mergedConfig[markConfigType]);
    }
  }
  for (const axisConfigType of AXIS_CONFIGS) {
    if (mergedConfig[axisConfigType]) {
      outputConfig[axisConfigType] = getAxisConfigInternal(mergedConfig[axisConfigType]);
    }
  }
  for (const headerConfigType of HEADER_CONFIGS) {
    if (mergedConfig[headerConfigType]) {
      outputConfig[headerConfigType] = replaceExprRef(mergedConfig[headerConfigType]);
    }
  }
  if (mergedConfig.legend) {
    outputConfig.legend = replaceExprRef(mergedConfig.legend);
  }
  if (mergedConfig.scale) {
    outputConfig.scale = replaceExprRef(mergedConfig.scale);
  }
  if (mergedConfig.style) {
    outputConfig.style = getStyleConfigInternal(mergedConfig.style);
  }
  if (mergedConfig.title) {
    outputConfig.title = replaceExprRef(mergedConfig.title);
  }
  if (mergedConfig.view) {
    outputConfig.view = replaceExprRef(mergedConfig.view);
  }
  return outputConfig;
}
var MARK_STYLES = ["view", ...PRIMITIVE_MARKS];
var VL_ONLY_CONFIG_PROPERTIES = [
  "color",
  "fontSize",
  "background",
  "padding",
  "facet",
  "concat",
  "numberFormat",
  "timeFormat",
  "countTitle",
  "header",
  "axisQuantitative",
  "axisTemporal",
  "axisDiscrete",
  "axisPoint",
  "axisXBand",
  "axisXPoint",
  "axisXDiscrete",
  "axisXQuantitative",
  "axisXTemporal",
  "axisYBand",
  "axisYPoint",
  "axisYDiscrete",
  "axisYQuantitative",
  "axisYTemporal",
  "scale",
  "selection",
  "overlay"
];
var VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = Object.assign({ view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"] }, VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX);
function stripAndRedirectConfig(config) {
  config = duplicate(config);
  for (const prop of VL_ONLY_CONFIG_PROPERTIES) {
    delete config[prop];
  }
  if (config.axis) {
    for (const prop in config.axis) {
      if (isConditionalAxisValue(config.axis[prop])) {
        delete config.axis[prop];
      }
    }
  }
  if (config.legend) {
    for (const prop of VL_ONLY_LEGEND_CONFIG) {
      delete config.legend[prop];
    }
  }
  if (config.mark) {
    for (const prop of VL_ONLY_MARK_CONFIG_PROPERTIES) {
      delete config.mark[prop];
    }
    if (config.mark.tooltip && isObject2(config.mark.tooltip)) {
      delete config.mark.tooltip;
    }
  }
  if (config.params) {
    config.signals = (config.signals || []).concat(assembleParameterSignals(config.params));
    delete config.params;
  }
  for (const markType of MARK_STYLES) {
    for (const prop of VL_ONLY_MARK_CONFIG_PROPERTIES) {
      delete config[markType][prop];
    }
    const vlOnlyMarkSpecificConfigs = VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX[markType];
    if (vlOnlyMarkSpecificConfigs) {
      for (const prop of vlOnlyMarkSpecificConfigs) {
        delete config[markType][prop];
      }
    }
    redirectConfigToStyleConfig(config, markType);
  }
  for (const m of getAllCompositeMarks()) {
    delete config[m];
  }
  redirectTitleConfig(config);
  for (const prop in config) {
    if (isObject2(config[prop]) && isEmpty(config[prop])) {
      delete config[prop];
    }
  }
  return isEmpty(config) ? void 0 : config;
}
function redirectTitleConfig(config) {
  const { titleMarkConfig, subtitleMarkConfig, subtitle } = extractTitleConfig(config.title);
  if (!isEmpty(titleMarkConfig)) {
    config.style["group-title"] = Object.assign(Object.assign({}, config.style["group-title"]), titleMarkConfig);
  }
  if (!isEmpty(subtitleMarkConfig)) {
    config.style["group-subtitle"] = Object.assign(Object.assign({}, config.style["group-subtitle"]), subtitleMarkConfig);
  }
  if (!isEmpty(subtitle)) {
    config.title = subtitle;
  } else {
    delete config.title;
  }
}
function redirectConfigToStyleConfig(config, prop, toProp, compositeMarkPart) {
  const propConfig = compositeMarkPart ? config[prop][compositeMarkPart] : config[prop];
  if (prop === "view") {
    toProp = "cell";
  }
  const style = Object.assign(Object.assign({}, propConfig), config.style[toProp !== null && toProp !== void 0 ? toProp : prop]);
  if (!isEmpty(style)) {
    config.style[toProp !== null && toProp !== void 0 ? toProp : prop] = style;
  }
  if (!compositeMarkPart) {
    delete config[prop];
  }
}

// node_modules/vega-lite/build/src/spec/layer.js
function isLayerSpec(spec) {
  return "layer" in spec;
}

// node_modules/vega-lite/build/src/spec/repeat.js
function isRepeatSpec(spec) {
  return "repeat" in spec;
}
function isLayerRepeatSpec(spec) {
  return !isArray2(spec.repeat) && spec.repeat["layer"];
}

// node_modules/vega-lite/build/src/spec/map.js
var __rest11 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var SpecMapper = class {
  map(spec, params) {
    if (isFacetSpec(spec)) {
      return this.mapFacet(spec, params);
    } else if (isRepeatSpec(spec)) {
      return this.mapRepeat(spec, params);
    } else if (isHConcatSpec(spec)) {
      return this.mapHConcat(spec, params);
    } else if (isVConcatSpec(spec)) {
      return this.mapVConcat(spec, params);
    } else if (isConcatSpec(spec)) {
      return this.mapConcat(spec, params);
    } else {
      return this.mapLayerOrUnit(spec, params);
    }
  }
  mapLayerOrUnit(spec, params) {
    if (isLayerSpec(spec)) {
      return this.mapLayer(spec, params);
    } else if (isUnitSpec(spec)) {
      return this.mapUnit(spec, params);
    }
    throw new Error(message_exports.invalidSpec(spec));
  }
  mapLayer(spec, params) {
    return Object.assign(Object.assign({}, spec), { layer: spec.layer.map((subspec) => this.mapLayerOrUnit(subspec, params)) });
  }
  mapHConcat(spec, params) {
    return Object.assign(Object.assign({}, spec), { hconcat: spec.hconcat.map((subspec) => this.map(subspec, params)) });
  }
  mapVConcat(spec, params) {
    return Object.assign(Object.assign({}, spec), { vconcat: spec.vconcat.map((subspec) => this.map(subspec, params)) });
  }
  mapConcat(spec, params) {
    const { concat } = spec, rest = __rest11(spec, ["concat"]);
    return Object.assign(Object.assign({}, rest), { concat: concat.map((subspec) => this.map(subspec, params)) });
  }
  mapFacet(spec, params) {
    return Object.assign(Object.assign({}, spec), {
      spec: this.map(spec.spec, params)
    });
  }
  mapRepeat(spec, params) {
    return Object.assign(Object.assign({}, spec), {
      spec: this.map(spec.spec, params)
    });
  }
};

// node_modules/vega-lite/build/src/stack.js
var STACK_OFFSET_INDEX = {
  zero: 1,
  center: 1,
  normalize: 1
};
function isStackOffset(s) {
  return s in STACK_OFFSET_INDEX;
}
var STACKABLE_MARKS = new Set([ARC, BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT2, TICK]);
var STACK_BY_DEFAULT_MARKS = new Set([BAR, AREA, ARC]);
function isUnbinnedQuantitative(channelDef) {
  return isFieldDef(channelDef) && channelDefType(channelDef) === "quantitative" && !channelDef.bin;
}
function potentialStackedChannel(encoding, x) {
  var _a, _b;
  const y = x === "x" ? "y" : "radius";
  const xDef = encoding[x];
  const yDef = encoding[y];
  if (isFieldDef(xDef) && isFieldDef(yDef)) {
    if (isUnbinnedQuantitative(xDef) && isUnbinnedQuantitative(yDef)) {
      if (xDef.stack) {
        return x;
      } else if (yDef.stack) {
        return y;
      }
      const xAggregate = isFieldDef(xDef) && !!xDef.aggregate;
      const yAggregate = isFieldDef(yDef) && !!yDef.aggregate;
      if (xAggregate !== yAggregate) {
        return xAggregate ? x : y;
      } else {
        const xScale = (_a = xDef.scale) === null || _a === void 0 ? void 0 : _a.type;
        const yScale = (_b = yDef.scale) === null || _b === void 0 ? void 0 : _b.type;
        if (xScale && xScale !== "linear") {
          return y;
        } else if (yScale && yScale !== "linear") {
          return x;
        }
      }
    } else if (isUnbinnedQuantitative(xDef)) {
      return x;
    } else if (isUnbinnedQuantitative(yDef)) {
      return y;
    }
  } else if (isUnbinnedQuantitative(xDef)) {
    return x;
  } else if (isUnbinnedQuantitative(yDef)) {
    return y;
  }
  return void 0;
}
function getDimensionChannel(channel) {
  switch (channel) {
    case "x":
      return "y";
    case "y":
      return "x";
    case "theta":
      return "radius";
    case "radius":
      return "theta";
  }
}
function stack(m, encoding, opt = {}) {
  var _a, _b;
  const mark3 = isMarkDef(m) ? m.type : m;
  if (!STACKABLE_MARKS.has(mark3)) {
    return null;
  }
  const fieldChannel = potentialStackedChannel(encoding, "x") || potentialStackedChannel(encoding, "theta");
  if (!fieldChannel) {
    return null;
  }
  const stackedFieldDef = encoding[fieldChannel];
  const stackedField = isFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : void 0;
  let dimensionChannel = getDimensionChannel(fieldChannel);
  let dimensionDef = encoding[dimensionChannel];
  let dimensionField = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : void 0;
  if (dimensionField === stackedField) {
    dimensionField = void 0;
    dimensionDef = void 0;
    dimensionChannel = void 0;
  }
  const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {
    if (channel !== "tooltip" && channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      for (const cDef of array(channelDef)) {
        const fieldDef = getFieldDef(cDef);
        if (fieldDef.aggregate) {
          continue;
        }
        const f = vgField(fieldDef, {});
        if (!f || f !== dimensionField) {
          sc.push({ channel, fieldDef });
        }
      }
    }
    return sc;
  }, []);
  let offset;
  if (stackedFieldDef.stack !== void 0) {
    if (isBoolean2(stackedFieldDef.stack)) {
      offset = stackedFieldDef.stack ? "zero" : null;
    } else {
      offset = stackedFieldDef.stack;
    }
  } else if (STACK_BY_DEFAULT_MARKS.has(mark3)) {
    offset = "zero";
  }
  if (!offset || !isStackOffset(offset)) {
    return null;
  }
  if (isAggregate(encoding) && stackBy.length === 0) {
    return null;
  }
  if (((_a = stackedFieldDef === null || stackedFieldDef === void 0 ? void 0 : stackedFieldDef.scale) === null || _a === void 0 ? void 0 : _a.type) && ((_b = stackedFieldDef === null || stackedFieldDef === void 0 ? void 0 : stackedFieldDef.scale) === null || _b === void 0 ? void 0 : _b.type) !== ScaleType.LINEAR) {
    if (opt.disallowNonLinearStack) {
      return null;
    } else {
      warn(message_exports.cannotStackNonLinearScale(stackedFieldDef.scale.type));
    }
  }
  if (isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)])) {
    if (stackedFieldDef.stack !== void 0) {
      warn(message_exports.cannotStackRangedMark(fieldChannel));
    }
    return null;
  }
  if (isFieldDef(stackedFieldDef) && stackedFieldDef.aggregate && !contains(SUM_OPS, stackedFieldDef.aggregate)) {
    warn(message_exports.stackNonSummativeAggregate(stackedFieldDef.aggregate));
  }
  return {
    groupbyChannel: dimensionDef ? dimensionChannel : void 0,
    groupbyField: dimensionField,
    fieldChannel,
    impute: stackedFieldDef.impute === null ? false : isPathMark(mark3),
    stackBy,
    offset
  };
}

// node_modules/vega-lite/build/src/normalize/pathoverlay.js
var __rest12 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function dropLineAndPoint(markDef) {
  const { point: _point, line: _line } = markDef, mark3 = __rest12(markDef, ["point", "line"]);
  return keys(mark3).length > 1 ? mark3 : mark3.type;
}
function dropLineAndPointFromConfig(config) {
  for (const mark3 of ["line", "area", "rule", "trail"]) {
    if (config[mark3]) {
      config = Object.assign(Object.assign({}, config), {
        [mark3]: omit(config[mark3], ["point", "line"])
      });
    }
  }
  return config;
}
function getPointOverlay(markDef, markConfig = {}, encoding) {
  if (markDef.point === "transparent") {
    return { opacity: 0 };
  } else if (markDef.point) {
    return isObject2(markDef.point) ? markDef.point : {};
  } else if (markDef.point !== void 0) {
    return null;
  } else {
    if (markConfig.point || encoding.shape) {
      return isObject2(markConfig.point) ? markConfig.point : {};
    }
    return void 0;
  }
}
function getLineOverlay(markDef, markConfig = {}) {
  if (markDef.line) {
    return markDef.line === true ? {} : markDef.line;
  } else if (markDef.line !== void 0) {
    return null;
  } else {
    if (markConfig.line) {
      return markConfig.line === true ? {} : markConfig.line;
    }
    return void 0;
  }
}
var PathOverlayNormalizer = class {
  constructor() {
    this.name = "path-overlay";
  }
  hasMatchingType(spec, config) {
    if (isUnitSpec(spec)) {
      const { mark: mark3, encoding } = spec;
      const markDef = isMarkDef(mark3) ? mark3 : { type: mark3 };
      switch (markDef.type) {
        case "line":
        case "rule":
        case "trail":
          return !!getPointOverlay(markDef, config[markDef.type], encoding);
        case "area":
          return !!getPointOverlay(markDef, config[markDef.type], encoding) || !!getLineOverlay(markDef, config[markDef.type]);
      }
    }
    return false;
  }
  run(spec, normParams, normalize2) {
    const { config } = normParams;
    const { params, projection, mark: mark3, encoding: e2 } = spec, outerSpec = __rest12(spec, ["params", "projection", "mark", "encoding"]);
    const encoding = normalizeEncoding(e2, config);
    const markDef = isMarkDef(mark3) ? mark3 : { type: mark3 };
    const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);
    const lineOverlay = markDef.type === "area" && getLineOverlay(markDef, config[markDef.type]);
    const layer = [
      Object.assign(Object.assign({}, params ? { params } : {}), {
        mark: dropLineAndPoint(Object.assign(Object.assign({}, markDef.type === "area" && markDef.opacity === void 0 && markDef.fillOpacity === void 0 ? { opacity: 0.7 } : {}), markDef)),
        encoding: omit(encoding, ["shape"])
      })
    ];
    const stackProps = stack(markDef, encoding);
    let overlayEncoding = encoding;
    if (stackProps) {
      const { fieldChannel: stackFieldChannel, offset } = stackProps;
      overlayEncoding = Object.assign(Object.assign({}, encoding), { [stackFieldChannel]: Object.assign(Object.assign({}, encoding[stackFieldChannel]), offset ? { stack: offset } : {}) });
    }
    if (lineOverlay) {
      layer.push(Object.assign(Object.assign({}, projection ? { projection } : {}), { mark: Object.assign(Object.assign({ type: "line" }, pick(markDef, ["clip", "interpolate", "tension", "tooltip"])), lineOverlay), encoding: overlayEncoding }));
    }
    if (pointOverlay) {
      layer.push(Object.assign(Object.assign({}, projection ? { projection } : {}), { mark: Object.assign(Object.assign({ type: "point", opacity: 1, filled: true }, pick(markDef, ["clip", "tooltip"])), pointOverlay), encoding: overlayEncoding }));
    }
    return normalize2(Object.assign(Object.assign({}, outerSpec), { layer }), Object.assign(Object.assign({}, normParams), { config: dropLineAndPointFromConfig(config) }));
  }
};

// node_modules/vega-lite/build/src/normalize/repeater.js
var __rest13 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function replaceRepeaterInFacet(facet, repeater) {
  if (!repeater) {
    return facet;
  }
  if (isFacetMapping(facet)) {
    return replaceRepeaterInMapping(facet, repeater);
  }
  return replaceRepeaterInFieldDef(facet, repeater);
}
function replaceRepeaterInEncoding(encoding, repeater) {
  if (!repeater) {
    return encoding;
  }
  return replaceRepeaterInMapping(encoding, repeater);
}
function replaceRepeatInProp(prop, o, repeater) {
  const val = o[prop];
  if (isRepeatRef(val)) {
    if (val.repeat in repeater) {
      return Object.assign(Object.assign({}, o), { [prop]: repeater[val.repeat] });
    } else {
      warn(message_exports.noSuchRepeatedValue(val.repeat));
      return void 0;
    }
  }
  return o;
}
function replaceRepeaterInFieldDef(fieldDef, repeater) {
  fieldDef = replaceRepeatInProp("field", fieldDef, repeater);
  if (fieldDef === void 0) {
    return void 0;
  } else if (fieldDef === null) {
    return null;
  }
  if (isSortableFieldDef(fieldDef) && isSortField(fieldDef.sort)) {
    const sort = replaceRepeatInProp("field", fieldDef.sort, repeater);
    fieldDef = Object.assign(Object.assign({}, fieldDef), sort ? { sort } : {});
  }
  return fieldDef;
}
function replaceRepeaterInFieldOrDatumDef(def, repeater) {
  if (isFieldDef(def)) {
    return replaceRepeaterInFieldDef(def, repeater);
  } else {
    const datumDef = replaceRepeatInProp("datum", def, repeater);
    if (datumDef !== def && !datumDef.type) {
      datumDef.type = "nominal";
    }
    return datumDef;
  }
}
function replaceRepeaterInChannelDef(channelDef, repeater) {
  if (isFieldOrDatumDef(channelDef)) {
    const fd = replaceRepeaterInFieldOrDatumDef(channelDef, repeater);
    if (fd) {
      return fd;
    } else if (isConditionalDef(channelDef)) {
      return { condition: channelDef.condition };
    }
  } else {
    if (hasConditionalFieldOrDatumDef(channelDef)) {
      const fd = replaceRepeaterInFieldOrDatumDef(channelDef.condition, repeater);
      if (fd) {
        return Object.assign(Object.assign({}, channelDef), { condition: fd });
      } else {
        const { condition } = channelDef, channelDefWithoutCondition = __rest13(channelDef, ["condition"]);
        return channelDefWithoutCondition;
      }
    }
    return channelDef;
  }
  return void 0;
}
function replaceRepeaterInMapping(mapping, repeater) {
  const out = {};
  for (const channel in mapping) {
    if (has(mapping, channel)) {
      const channelDef = mapping[channel];
      if (isArray2(channelDef)) {
        out[channel] = channelDef.map((cd) => replaceRepeaterInChannelDef(cd, repeater)).filter((cd) => cd);
      } else {
        const cd = replaceRepeaterInChannelDef(channelDef, repeater);
        if (cd !== void 0) {
          out[channel] = cd;
        }
      }
    }
  }
  return out;
}

// node_modules/vega-lite/build/src/normalize/ruleforrangedline.js
var RuleForRangedLineNormalizer = class {
  constructor() {
    this.name = "RuleForRangedLine";
  }
  hasMatchingType(spec) {
    if (isUnitSpec(spec)) {
      const { encoding, mark: mark3 } = spec;
      if (mark3 === "line" || isMarkDef(mark3) && mark3.type === "line") {
        for (const channel of SECONDARY_RANGE_CHANNEL) {
          const mainChannel = getMainRangeChannel(channel);
          const mainChannelDef = encoding[mainChannel];
          if (encoding[channel]) {
            if (isFieldDef(mainChannelDef) && !isBinned(mainChannelDef.bin) || isDatumDef(mainChannelDef)) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }
  run(spec, params, normalize2) {
    const { encoding, mark: mark3 } = spec;
    warn(message_exports.lineWithRange(!!encoding.x2, !!encoding.y2));
    return normalize2(Object.assign(Object.assign({}, spec), { mark: isObject2(mark3) ? Object.assign(Object.assign({}, mark3), { type: "rule" }) : "rule" }), params);
  }
};

// node_modules/vega-lite/build/src/normalize/core.js
var __rest14 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var CoreNormalizer = class extends SpecMapper {
  constructor() {
    super(...arguments);
    this.nonFacetUnitNormalizers = [
      boxPlotNormalizer,
      errorBarNormalizer,
      errorBandNormalizer,
      new PathOverlayNormalizer(),
      new RuleForRangedLineNormalizer()
    ];
  }
  map(spec, params) {
    if (isUnitSpec(spec)) {
      const hasRow = channelHasField(spec.encoding, ROW);
      const hasColumn = channelHasField(spec.encoding, COLUMN);
      const hasFacet = channelHasField(spec.encoding, FACET);
      if (hasRow || hasColumn || hasFacet) {
        return this.mapFacetedUnit(spec, params);
      }
    }
    return super.map(spec, params);
  }
  mapUnit(spec, params) {
    const { parentEncoding, parentProjection } = params;
    const encoding = replaceRepeaterInEncoding(spec.encoding, params.repeater);
    const specWithReplacedEncoding = Object.assign(Object.assign({}, spec), encoding ? { encoding } : {});
    if (parentEncoding || parentProjection) {
      return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding, params);
    }
    const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);
    for (const unitNormalizer of this.nonFacetUnitNormalizers) {
      if (unitNormalizer.hasMatchingType(specWithReplacedEncoding, params.config)) {
        return unitNormalizer.run(specWithReplacedEncoding, params, normalizeLayerOrUnit);
      }
    }
    return specWithReplacedEncoding;
  }
  mapRepeat(spec, params) {
    if (isLayerRepeatSpec(spec)) {
      return this.mapLayerRepeat(spec, params);
    } else {
      return this.mapNonLayerRepeat(spec, params);
    }
  }
  mapLayerRepeat(spec, params) {
    const { repeat, spec: childSpec } = spec, rest = __rest14(spec, ["repeat", "spec"]);
    const { row, column, layer } = repeat;
    const { repeater = {}, repeaterPrefix = "" } = params;
    if (row || column) {
      return this.mapRepeat(Object.assign(Object.assign({}, spec), { repeat: Object.assign(Object.assign({}, row ? { row } : {}), column ? { column } : {}), spec: {
        repeat: { layer },
        spec: childSpec
      } }), params);
    } else {
      return Object.assign(Object.assign({}, rest), { layer: layer.map((layerValue) => {
        const childRepeater = Object.assign(Object.assign({}, repeater), { layer: layerValue });
        const childName = `${(childSpec.name || "") + repeaterPrefix}child__layer_${varName(layerValue)}`;
        const child = this.mapLayerOrUnit(childSpec, Object.assign(Object.assign({}, params), { repeater: childRepeater, repeaterPrefix: childName }));
        child.name = childName;
        return child;
      }) });
    }
  }
  mapNonLayerRepeat(spec, params) {
    var _a;
    const { repeat, spec: childSpec, data } = spec, remainingProperties = __rest14(spec, ["repeat", "spec", "data"]);
    if (!isArray2(repeat) && spec.columns) {
      spec = omit(spec, ["columns"]);
      warn(message_exports.columnsNotSupportByRowCol("repeat"));
    }
    const concat = [];
    const { repeater = {}, repeaterPrefix = "" } = params;
    const row = !isArray2(repeat) && repeat.row || [repeater ? repeater.row : null];
    const column = !isArray2(repeat) && repeat.column || [repeater ? repeater.column : null];
    const repeatValues = isArray2(repeat) && repeat || [repeater ? repeater.repeat : null];
    for (const repeatValue of repeatValues) {
      for (const rowValue of row) {
        for (const columnValue of column) {
          const childRepeater = {
            repeat: repeatValue,
            row: rowValue,
            column: columnValue,
            layer: repeater.layer
          };
          const childName = (childSpec.name || "") + repeaterPrefix + "child__" + (isArray2(repeat) ? `${varName(repeatValue)}` : (repeat.row ? `row_${varName(rowValue)}` : "") + (repeat.column ? `column_${varName(columnValue)}` : ""));
          const child = this.map(childSpec, Object.assign(Object.assign({}, params), { repeater: childRepeater, repeaterPrefix: childName }));
          child.name = childName;
          concat.push(omit(child, ["data"]));
        }
      }
    }
    const columns = isArray2(repeat) ? spec.columns : repeat.column ? repeat.column.length : 1;
    return Object.assign(Object.assign({ data: (_a = childSpec.data) !== null && _a !== void 0 ? _a : data, align: "all" }, remainingProperties), {
      columns,
      concat
    });
  }
  mapFacet(spec, params) {
    const { facet } = spec;
    if (isFacetMapping(facet) && spec.columns) {
      spec = omit(spec, ["columns"]);
      warn(message_exports.columnsNotSupportByRowCol("facet"));
    }
    return super.mapFacet(spec, params);
  }
  mapUnitWithParentEncodingOrProjection(spec, params) {
    const { encoding, projection } = spec;
    const { parentEncoding, parentProjection, config } = params;
    const mergedProjection = mergeProjection({ parentProjection, projection });
    const mergedEncoding = mergeEncoding({
      parentEncoding,
      encoding: replaceRepeaterInEncoding(encoding, params.repeater)
    });
    return this.mapUnit(Object.assign(Object.assign(Object.assign({}, spec), mergedProjection ? { projection: mergedProjection } : {}), mergedEncoding ? { encoding: mergedEncoding } : {}), { config });
  }
  mapFacetedUnit(spec, normParams) {
    const _a = spec.encoding, { row, column, facet } = _a, encoding = __rest14(_a, ["row", "column", "facet"]);
    const { mark: mark3, width, projection, height, view, params, encoding: _ } = spec, outerSpec = __rest14(spec, ["mark", "width", "projection", "height", "view", "params", "encoding"]);
    const { facetMapping, layout } = this.getFacetMappingAndLayout({ row, column, facet }, normParams);
    const newEncoding = replaceRepeaterInEncoding(encoding, normParams.repeater);
    return this.mapFacet(Object.assign(Object.assign(Object.assign({}, outerSpec), layout), {
      facet: facetMapping,
      spec: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, width ? { width } : {}), height ? { height } : {}), view ? { view } : {}), projection ? { projection } : {}), { mark: mark3, encoding: newEncoding }), params ? { params } : {})
    }), normParams);
  }
  getFacetMappingAndLayout(facets, params) {
    var _a;
    const { row, column, facet } = facets;
    if (row || column) {
      if (facet) {
        warn(message_exports.facetChannelDropped([...row ? [ROW] : [], ...column ? [COLUMN] : []]));
      }
      const facetMapping = {};
      const layout = {};
      for (const channel of [ROW, COLUMN]) {
        const def = facets[channel];
        if (def) {
          const { align: align2, center, spacing, columns } = def, defWithoutLayout = __rest14(def, ["align", "center", "spacing", "columns"]);
          facetMapping[channel] = defWithoutLayout;
          for (const prop of ["align", "center", "spacing"]) {
            if (def[prop] !== void 0) {
              (_a = layout[prop]) !== null && _a !== void 0 ? _a : layout[prop] = {};
              layout[prop][channel] = def[prop];
            }
          }
        }
      }
      return { facetMapping, layout };
    } else {
      const { align: align2, center, spacing, columns } = facet, facetMapping = __rest14(facet, ["align", "center", "spacing", "columns"]);
      return {
        facetMapping: replaceRepeaterInFacet(facetMapping, params.repeater),
        layout: Object.assign(Object.assign(Object.assign(Object.assign({}, align2 ? { align: align2 } : {}), center ? { center } : {}), spacing ? { spacing } : {}), columns ? { columns } : {})
      };
    }
  }
  mapLayer(spec, _a) {
    var { parentEncoding, parentProjection } = _a, otherParams = __rest14(_a, ["parentEncoding", "parentProjection"]);
    const { encoding, projection } = spec, rest = __rest14(spec, ["encoding", "projection"]);
    const params = Object.assign(Object.assign({}, otherParams), { parentEncoding: mergeEncoding({ parentEncoding, encoding, layer: true }), parentProjection: mergeProjection({ parentProjection, projection }) });
    return super.mapLayer(rest, params);
  }
};
function mergeEncoding({ parentEncoding, encoding = {}, layer }) {
  let merged = {};
  if (parentEncoding) {
    const channels = new Set([...keys(parentEncoding), ...keys(encoding)]);
    for (const channel of channels) {
      const channelDef = encoding[channel];
      const parentChannelDef = parentEncoding[channel];
      if (isFieldOrDatumDef(channelDef)) {
        const mergedChannelDef = Object.assign(Object.assign({}, parentChannelDef), channelDef);
        merged[channel] = mergedChannelDef;
      } else if (hasConditionalFieldOrDatumDef(channelDef)) {
        merged[channel] = Object.assign(Object.assign({}, channelDef), { condition: Object.assign(Object.assign({}, parentChannelDef), channelDef.condition) });
      } else if (channelDef || channelDef === null) {
        merged[channel] = channelDef;
      } else if (layer || isValueDef(parentChannelDef) || isSignalRef(parentChannelDef) || isFieldOrDatumDef(parentChannelDef) || isArray2(parentChannelDef)) {
        merged[channel] = parentChannelDef;
      }
    }
  } else {
    merged = encoding;
  }
  return !merged || isEmpty(merged) ? void 0 : merged;
}
function mergeProjection(opt) {
  const { parentProjection, projection } = opt;
  if (parentProjection && projection) {
    warn(message_exports.projectionOverridden({ parentProjection, projection }));
  }
  return projection !== null && projection !== void 0 ? projection : parentProjection;
}

// node_modules/vega-lite/build/src/transform.js
function isFilter(t2) {
  return "filter" in t2;
}
function isImputeSequence(t2) {
  return (t2 === null || t2 === void 0 ? void 0 : t2["stop"]) !== void 0;
}
function isLookup(t2) {
  return "lookup" in t2;
}
function isLookupData(from) {
  return "data" in from;
}
function isLookupSelection(from) {
  return "param" in from;
}
function isPivot(t2) {
  return "pivot" in t2;
}
function isDensity(t2) {
  return "density" in t2;
}
function isQuantile(t2) {
  return "quantile" in t2;
}
function isRegression(t2) {
  return "regression" in t2;
}
function isLoess(t2) {
  return "loess" in t2;
}
function isSample(t2) {
  return "sample" in t2;
}
function isWindow(t2) {
  return "window" in t2;
}
function isJoinAggregate(t2) {
  return "joinaggregate" in t2;
}
function isFlatten(t2) {
  return "flatten" in t2;
}
function isCalculate(t2) {
  return "calculate" in t2;
}
function isBin(t2) {
  return "bin" in t2;
}
function isImpute(t2) {
  return "impute" in t2;
}
function isTimeUnit(t2) {
  return "timeUnit" in t2;
}
function isAggregate2(t2) {
  return "aggregate" in t2;
}
function isStack(t2) {
  return "stack" in t2;
}
function isFold(t2) {
  return "fold" in t2;
}
function normalizeTransform(transform) {
  return transform.map((t2) => {
    if (isFilter(t2)) {
      return {
        filter: normalizeLogicalComposition(t2.filter, normalizePredicate)
      };
    }
    return t2;
  });
}

// node_modules/vega-lite/build/src/normalize/selectioncompat.js
var __rest15 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var SelectionCompatibilityNormalizer = class extends SpecMapper {
  map(spec, normParams) {
    var _a, _b;
    (_a = normParams.emptySelections) !== null && _a !== void 0 ? _a : normParams.emptySelections = {};
    (_b = normParams.selectionPredicates) !== null && _b !== void 0 ? _b : normParams.selectionPredicates = {};
    spec = normalizeTransforms(spec, normParams);
    return super.map(spec, normParams);
  }
  mapLayerOrUnit(spec, normParams) {
    spec = normalizeTransforms(spec, normParams);
    if (spec.encoding) {
      const encoding = {};
      for (const [channel, enc] of entries(spec.encoding)) {
        encoding[channel] = normalizeChannelDef(enc, normParams);
      }
      spec = Object.assign(Object.assign({}, spec), { encoding });
    }
    return super.mapLayerOrUnit(spec, normParams);
  }
  mapUnit(spec, normParams) {
    const _a = spec, { selection } = _a, rest = __rest15(_a, ["selection"]);
    if (selection) {
      return Object.assign(Object.assign({}, rest), { params: entries(selection).map(([name5, selDef]) => {
        var _a2;
        const _b = selDef, { init: value, bind, empty } = _b, select = __rest15(_b, ["init", "bind", "empty"]);
        if (select.type === "single") {
          select.type = "point";
          select.toggle = false;
        } else if (select.type === "multi") {
          select.type = "point";
        }
        normParams.emptySelections[name5] = empty !== "none";
        for (const pred of vals((_a2 = normParams.selectionPredicates[name5]) !== null && _a2 !== void 0 ? _a2 : {})) {
          pred.empty = empty !== "none";
        }
        return { name: name5, value, select, bind };
      }) });
    }
    return spec;
  }
};
function normalizeTransforms(spec, normParams) {
  const { transform: tx } = spec, rest = __rest15(spec, ["transform"]);
  if (tx) {
    const transform = tx.map((t2) => {
      if (isFilter(t2)) {
        return { filter: normalizePredicate2(t2, normParams) };
      } else if (isBin(t2) && isBinParams(t2.bin)) {
        return Object.assign(Object.assign({}, t2), { bin: normalizeBinExtent(t2.bin) });
      } else if (isLookup(t2)) {
        const _a = t2.from, { selection: param } = _a, from = __rest15(_a, ["selection"]);
        return param ? Object.assign(Object.assign({}, t2), { from: Object.assign({ param }, from) }) : t2;
      }
      return t2;
    });
    return Object.assign(Object.assign({}, rest), { transform });
  }
  return spec;
}
function normalizeChannelDef(obj, normParams) {
  var _a, _b;
  const enc = duplicate(obj);
  if (isFieldDef(enc) && isBinParams(enc.bin)) {
    enc.bin = normalizeBinExtent(enc.bin);
  }
  if (isScaleFieldDef(enc) && ((_b = (_a = enc.scale) === null || _a === void 0 ? void 0 : _a.domain) === null || _b === void 0 ? void 0 : _b.selection)) {
    const _c = enc.scale.domain, { selection: param } = _c, domain2 = __rest15(_c, ["selection"]);
    enc.scale.domain = Object.assign(Object.assign({}, domain2), param ? { param } : {});
  }
  if (isConditionalDef(enc)) {
    if (isArray(enc.condition)) {
      enc.condition = enc.condition.map((c) => {
        const { selection, param, test } = c, cond = __rest15(c, ["selection", "param", "test"]);
        return param ? c : Object.assign(Object.assign({}, cond), { test: normalizePredicate2(c, normParams) });
      });
    } else {
      const _d = normalizeChannelDef(enc.condition, normParams), { selection, param, test } = _d, cond = __rest15(_d, ["selection", "param", "test"]);
      enc.condition = param ? enc.condition : Object.assign(Object.assign({}, cond), { test: normalizePredicate2(enc.condition, normParams) });
    }
  }
  return enc;
}
function normalizeBinExtent(bin2) {
  const ext = bin2.extent;
  if (ext === null || ext === void 0 ? void 0 : ext.selection) {
    const { selection: param } = ext, rest = __rest15(ext, ["selection"]);
    return Object.assign(Object.assign({}, bin2), { extent: Object.assign(Object.assign({}, rest), { param }) });
  }
  return bin2;
}
function normalizePredicate2(op, normParams) {
  const normalizeSelectionComposition = (o) => {
    return normalizeLogicalComposition(o, (param) => {
      var _a, _b;
      var _c;
      const empty = (_a = normParams.emptySelections[param]) !== null && _a !== void 0 ? _a : true;
      const pred = { param, empty };
      (_b = (_c = normParams.selectionPredicates)[param]) !== null && _b !== void 0 ? _b : _c[param] = [];
      normParams.selectionPredicates[param].push(pred);
      return pred;
    });
  };
  return op.selection ? normalizeSelectionComposition(op.selection) : normalizeLogicalComposition(op.test || op.filter, (o) => o.selection ? normalizeSelectionComposition(o.selection) : o);
}

// node_modules/vega-lite/build/src/normalize/toplevelselection.js
var TopLevelSelectionsNormalizer = class extends SpecMapper {
  map(spec, normParams) {
    var _a;
    const selections = (_a = normParams.selections) !== null && _a !== void 0 ? _a : [];
    if (spec.params && !isUnitSpec(spec)) {
      const params = [];
      for (const param of spec.params) {
        if (isSelectionParameter(param)) {
          selections.push(param);
        } else {
          params.push(param);
        }
      }
      spec.params = params;
    }
    normParams.selections = selections;
    return super.map(spec, addSpecNameToParams(spec, normParams));
  }
  mapUnit(spec, normParams) {
    var _a;
    const selections = normParams.selections;
    if (!selections || !selections.length)
      return spec;
    const path = ((_a = normParams.path) !== null && _a !== void 0 ? _a : []).concat(spec.name);
    const params = [];
    for (const selection of selections) {
      if (!selection.views || !selection.views.length) {
        params.push(selection);
      } else {
        for (const view of selection.views) {
          if (isString(view) && (view === spec.name || path.indexOf(view) >= 0) || isArray(view) && view.map((v) => path.indexOf(v)).every((v, i, arr) => v !== -1 && (i === 0 || v > arr[i - 1]))) {
            params.push(selection);
          }
        }
      }
    }
    if (params.length)
      spec.params = params;
    return spec;
  }
};
for (const method of ["mapFacet", "mapRepeat", "mapHConcat", "mapVConcat", "mapLayer"]) {
  const proto = TopLevelSelectionsNormalizer.prototype[method];
  TopLevelSelectionsNormalizer.prototype[method] = function(spec, params) {
    return proto.call(this, spec, addSpecNameToParams(spec, params));
  };
}
function addSpecNameToParams(spec, params) {
  var _a;
  return spec.name ? Object.assign(Object.assign({}, params), { path: ((_a = params.path) !== null && _a !== void 0 ? _a : []).concat(spec.name) }) : params;
}

// node_modules/vega-lite/build/src/normalize/index.js
function normalize(spec, config) {
  if (config === void 0) {
    config = initConfig(spec.config);
  }
  const normalizedSpec = normalizeGenericSpec(spec, config);
  const { width, height } = spec;
  const autosize = normalizeAutoSize(normalizedSpec, { width, height, autosize: spec.autosize }, config);
  return Object.assign(Object.assign({}, normalizedSpec), autosize ? { autosize } : {});
}
var coreNormalizer = new CoreNormalizer();
var selectionCompatNormalizer = new SelectionCompatibilityNormalizer();
var topLevelSelectionNormalizer = new TopLevelSelectionsNormalizer();
function normalizeGenericSpec(spec, config = {}) {
  const normParams = { config };
  return topLevelSelectionNormalizer.map(coreNormalizer.map(selectionCompatNormalizer.map(spec, normParams), normParams), normParams);
}
function _normalizeAutoSize(autosize) {
  return isString2(autosize) ? { type: autosize } : autosize !== null && autosize !== void 0 ? autosize : {};
}
function normalizeAutoSize(spec, sizeInfo, config) {
  let { width, height } = sizeInfo;
  const isFitCompatible = isUnitSpec(spec) || isLayerSpec(spec);
  const autosizeDefault = {};
  if (!isFitCompatible) {
    if (width == "container") {
      warn(message_exports.containerSizeNonSingle("width"));
      width = void 0;
    }
    if (height == "container") {
      warn(message_exports.containerSizeNonSingle("height"));
      height = void 0;
    }
  } else {
    if (width == "container" && height == "container") {
      autosizeDefault.type = "fit";
      autosizeDefault.contains = "padding";
    } else if (width == "container") {
      autosizeDefault.type = "fit-x";
      autosizeDefault.contains = "padding";
    } else if (height == "container") {
      autosizeDefault.type = "fit-y";
      autosizeDefault.contains = "padding";
    }
  }
  const autosize = Object.assign(Object.assign(Object.assign({ type: "pad" }, autosizeDefault), config ? _normalizeAutoSize(config.autosize) : {}), _normalizeAutoSize(spec.autosize));
  if (autosize.type === "fit" && !isFitCompatible) {
    warn(message_exports.FIT_NON_SINGLE);
    autosize.type = "pad";
  }
  if (width == "container" && !(autosize.type == "fit" || autosize.type == "fit-x")) {
    warn(message_exports.containerSizeNotCompatibleWithAutosize("width"));
  }
  if (height == "container" && !(autosize.type == "fit" || autosize.type == "fit-y")) {
    warn(message_exports.containerSizeNotCompatibleWithAutosize("height"));
  }
  if (deepEqual(autosize, { type: "pad" })) {
    return void 0;
  }
  return autosize;
}

// node_modules/vega-lite/build/src/spec/toplevel.js
function isFitType(autoSizeType) {
  return autoSizeType === "fit" || autoSizeType === "fit-x" || autoSizeType === "fit-y";
}
function getFitType(sizeType) {
  return sizeType ? `fit-${getPositionScaleChannel(sizeType)}` : "fit";
}
var TOP_LEVEL_PROPERTIES = [
  "background",
  "padding"
];
function extractTopLevelProperties(t2, includeParams) {
  const o = {};
  for (const p of TOP_LEVEL_PROPERTIES) {
    if (t2 && t2[p] !== void 0) {
      o[p] = signalRefOrValue(t2[p]);
    }
  }
  if (includeParams) {
    o.params = t2.params;
  }
  return o;
}

// node_modules/vega-lite/build/src/compile/split.js
var Split = class {
  constructor(explicit = {}, implicit = {}) {
    this.explicit = explicit;
    this.implicit = implicit;
  }
  clone() {
    return new Split(duplicate(this.explicit), duplicate(this.implicit));
  }
  combine() {
    return Object.assign(Object.assign({}, this.explicit), this.implicit);
  }
  get(key) {
    return getFirstDefined(this.explicit[key], this.implicit[key]);
  }
  getWithExplicit(key) {
    if (this.explicit[key] !== void 0) {
      return { explicit: true, value: this.explicit[key] };
    } else if (this.implicit[key] !== void 0) {
      return { explicit: false, value: this.implicit[key] };
    }
    return { explicit: false, value: void 0 };
  }
  setWithExplicit(key, { value, explicit }) {
    if (value !== void 0) {
      this.set(key, value, explicit);
    }
  }
  set(key, value, explicit) {
    delete this[explicit ? "implicit" : "explicit"][key];
    this[explicit ? "explicit" : "implicit"][key] = value;
    return this;
  }
  copyKeyFromSplit(key, { explicit, implicit }) {
    if (explicit[key] !== void 0) {
      this.set(key, explicit[key], true);
    } else if (implicit[key] !== void 0) {
      this.set(key, implicit[key], false);
    }
  }
  copyKeyFromObject(key, s) {
    if (s[key] !== void 0) {
      this.set(key, s[key], true);
    }
  }
  copyAll(other) {
    for (const key of keys(other.combine())) {
      const val = other.getWithExplicit(key);
      this.setWithExplicit(key, val);
    }
  }
};
function makeExplicit(value) {
  return {
    explicit: true,
    value
  };
}
function makeImplicit(value) {
  return {
    explicit: false,
    value
  };
}
function tieBreakByComparing(compare3) {
  return (v1, v2, property, propertyOf) => {
    const diff = compare3(v1.value, v2.value);
    if (diff > 0) {
      return v1;
    } else if (diff < 0) {
      return v2;
    }
    return defaultTieBreaker(v1, v2, property, propertyOf);
  };
}
function defaultTieBreaker(v1, v2, property, propertyOf) {
  if (v1.explicit && v2.explicit) {
    warn(message_exports.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));
  }
  return v1;
}
function mergeValuesWithExplicit(v1, v2, property, propertyOf, tieBreaker = defaultTieBreaker) {
  if (v1 === void 0 || v1.value === void 0) {
    return v2;
  }
  if (v1.explicit && !v2.explicit) {
    return v1;
  } else if (v2.explicit && !v1.explicit) {
    return v2;
  } else if (deepEqual(v1.value, v2.value)) {
    return v1;
  } else {
    return tieBreaker(v1, v2, property, propertyOf);
  }
}

// node_modules/vega-lite/build/src/compile/data/index.js
var AncestorParse = class extends Split {
  constructor(explicit = {}, implicit = {}, parseNothing = false) {
    super(explicit, implicit);
    this.explicit = explicit;
    this.implicit = implicit;
    this.parseNothing = parseNothing;
  }
  clone() {
    const clone = super.clone();
    clone.parseNothing = this.parseNothing;
    return clone;
  }
};

// node_modules/vega-lite/build/src/data.js
function isUrlData(data) {
  return "url" in data;
}
function isInlineData(data) {
  return "values" in data;
}
function isNamedData(data) {
  return "name" in data && !isUrlData(data) && !isInlineData(data) && !isGenerator(data);
}
function isGenerator(data) {
  return data && (isSequenceGenerator(data) || isSphereGenerator(data) || isGraticuleGenerator(data));
}
function isSequenceGenerator(data) {
  return "sequence" in data;
}
function isSphereGenerator(data) {
  return "sphere" in data;
}
function isGraticuleGenerator(data) {
  return "graticule" in data;
}
var DataSourceType;
(function(DataSourceType2) {
  DataSourceType2[DataSourceType2["Raw"] = 0] = "Raw";
  DataSourceType2[DataSourceType2["Main"] = 1] = "Main";
  DataSourceType2[DataSourceType2["Row"] = 2] = "Row";
  DataSourceType2[DataSourceType2["Column"] = 3] = "Column";
  DataSourceType2[DataSourceType2["Lookup"] = 4] = "Lookup";
})(DataSourceType || (DataSourceType = {}));

// node_modules/vega-lite/node_modules/vega-event-selector/build/vega-event-selector.module.js
var VIEW = "view";
var LBRACK = "[";
var RBRACK = "]";
var LBRACE = "{";
var RBRACE = "}";
var COLON = ":";
var COMMA = ",";
var NAME = "@";
var GT = ">";
var ILLEGAL = /[[\]{}]/;
var DEFAULT_MARKS = {
  "*": 1,
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
var DEFAULT_SOURCE;
var MARKS;
function eventSelector(selector, source2, marks) {
  DEFAULT_SOURCE = source2 || VIEW;
  MARKS = marks || DEFAULT_MARKS;
  return parseMerge(selector.trim()).map(parseSelector);
}
function isMarkType(type) {
  return MARKS[type];
}
function find(s, i, endChar, pushChar, popChar) {
  const n = s.length;
  let count = 0, c;
  for (; i < n; ++i) {
    c = s[i];
    if (!count && c === endChar)
      return i;
    else if (popChar && popChar.indexOf(c) >= 0)
      --count;
    else if (pushChar && pushChar.indexOf(c) >= 0)
      ++count;
  }
  return i;
}
function parseMerge(s) {
  const output = [], n = s.length;
  let start = 0, i = 0;
  while (i < n) {
    i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);
    output.push(s.substring(start, i).trim());
    start = ++i;
  }
  if (output.length === 0) {
    throw "Empty event selector: " + s;
  }
  return output;
}
function parseSelector(s) {
  return s[0] === "[" ? parseBetween(s) : parseStream(s);
}
function parseBetween(s) {
  const n = s.length;
  let i = 1, b;
  i = find(s, i, RBRACK, LBRACK, RBRACK);
  if (i === n) {
    throw "Empty between selector: " + s;
  }
  b = parseMerge(s.substring(1, i));
  if (b.length !== 2) {
    throw "Between selector must have two elements: " + s;
  }
  s = s.slice(i + 1).trim();
  if (s[0] !== GT) {
    throw "Expected '>' after between selector: " + s;
  }
  b = b.map(parseSelector);
  const stream = parseSelector(s.slice(1).trim());
  if (stream.between) {
    return {
      between: b,
      stream
    };
  } else {
    stream.between = b;
  }
  return stream;
}
function parseStream(s) {
  const stream = {
    source: DEFAULT_SOURCE
  }, source2 = [];
  let throttle = [0, 0], markname = 0, start = 0, n = s.length, i = 0, j, filter;
  if (s[n - 1] === RBRACE) {
    i = s.lastIndexOf(LBRACE);
    if (i >= 0) {
      try {
        throttle = parseThrottle(s.substring(i + 1, n - 1));
      } catch (e2) {
        throw "Invalid throttle specification: " + s;
      }
      s = s.slice(0, i).trim();
      n = s.length;
    } else
      throw "Unmatched right brace: " + s;
    i = 0;
  }
  if (!n)
    throw s;
  if (s[0] === NAME)
    markname = ++i;
  j = find(s, i, COLON);
  if (j < n) {
    source2.push(s.substring(start, j).trim());
    start = i = ++j;
  }
  i = find(s, i, LBRACK);
  if (i === n) {
    source2.push(s.substring(start, n).trim());
  } else {
    source2.push(s.substring(start, i).trim());
    filter = [];
    start = ++i;
    if (start === n)
      throw "Unmatched left bracket: " + s;
  }
  while (i < n) {
    i = find(s, i, RBRACK);
    if (i === n)
      throw "Unmatched left bracket: " + s;
    filter.push(s.substring(start, i).trim());
    if (i < n - 1 && s[++i] !== LBRACK)
      throw "Expected left bracket: " + s;
    start = ++i;
  }
  if (!(n = source2.length) || ILLEGAL.test(source2[n - 1])) {
    throw "Invalid event selector: " + s;
  }
  if (n > 1) {
    stream.type = source2[1];
    if (markname) {
      stream.markname = source2[0].slice(1);
    } else if (isMarkType(source2[0])) {
      stream.marktype = source2[0];
    } else {
      stream.source = source2[0];
    }
  } else {
    stream.type = source2[0];
  }
  if (stream.type.slice(-1) === "!") {
    stream.consume = true;
    stream.type = stream.type.slice(0, -1);
  }
  if (filter != null)
    stream.filter = filter;
  if (throttle[0])
    stream.throttle = throttle[0];
  if (throttle[1])
    stream.debounce = throttle[1];
  return stream;
}
function parseThrottle(s) {
  const a = s.split(COMMA);
  if (!s.length || a.length > 2)
    throw s;
  return a.map((_) => {
    const x = +_;
    if (x !== x)
      throw s;
    return x;
  });
}

// node_modules/vega-lite/build/src/compile/selection/assemble.js
var __rest16 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function assembleInit(init, isExpr = true, wrap2 = identity) {
  if (isArray2(init)) {
    const assembled = init.map((v) => assembleInit(v, isExpr, wrap2));
    return isExpr ? `[${assembled.join(", ")}]` : assembled;
  } else if (isDateTime(init)) {
    if (isExpr) {
      return wrap2(dateTimeToExpr(init));
    } else {
      return wrap2(dateTimeToTimestamp(init));
    }
  }
  return isExpr ? wrap2(stringify(init)) : init;
}
function assembleUnitSelectionSignals(model, signals) {
  var _a;
  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {
    const name5 = selCmpt.name;
    let modifyExpr = `${name5}${TUPLE}, ${selCmpt.resolve === "global" ? "true" : `{unit: ${unitName(model)}}`}`;
    for (const c of selectionCompilers) {
      if (!c.defined(selCmpt))
        continue;
      if (c.signals)
        signals = c.signals(model, selCmpt, signals);
      if (c.modifyExpr)
        modifyExpr = c.modifyExpr(model, selCmpt, modifyExpr);
    }
    signals.push({
      name: name5 + MODIFY,
      on: [
        {
          events: { signal: selCmpt.name + TUPLE },
          update: `modify(${$(selCmpt.name + STORE)}, ${modifyExpr})`
        }
      ]
    });
  }
  return cleanupEmptyOnArray(signals);
}
function assembleFacetSignals(model, signals) {
  if (model.component.selection && keys(model.component.selection).length) {
    const name5 = $(model.getName("cell"));
    signals.unshift({
      name: "facet",
      value: {},
      on: [
        {
          events: eventSelector("mousemove", "scope"),
          update: `isTuple(facet) ? facet : group(${name5}).datum`
        }
      ]
    });
  }
  return cleanupEmptyOnArray(signals);
}
function assembleTopLevelSignals(model, signals) {
  var _a;
  let hasSelections = false;
  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {
    const name5 = selCmpt.name;
    const store = $(name5 + STORE);
    const hasSg = signals.filter((s) => s.name === name5);
    if (hasSg.length === 0) {
      const resolve = selCmpt.resolve === "global" ? "union" : selCmpt.resolve;
      const isPoint = selCmpt.type === "point" ? ", true, true)" : ")";
      signals.push({
        name: selCmpt.name,
        update: `${VL_SELECTION_RESOLVE}(${store}, ${$(resolve)}${isPoint}`
      });
    }
    hasSelections = true;
    for (const c of selectionCompilers) {
      if (c.defined(selCmpt) && c.topLevelSignals) {
        signals = c.topLevelSignals(model, selCmpt, signals);
      }
    }
  }
  if (hasSelections) {
    const hasUnit = signals.filter((s) => s.name === "unit");
    if (hasUnit.length === 0) {
      signals.unshift({
        name: "unit",
        value: {},
        on: [{ events: "mousemove", update: "isTuple(group()) ? group() : unit" }]
      });
    }
  }
  return cleanupEmptyOnArray(signals);
}
function assembleUnitSelectionData(model, data) {
  var _a;
  const dataCopy = [...data];
  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {
    const init = { name: selCmpt.name + STORE };
    if (selCmpt.init) {
      const fields = selCmpt.project.items.map((proj) => {
        const { signals } = proj, rest = __rest16(proj, ["signals"]);
        return rest;
      });
      init.values = selCmpt.init.map((i) => ({
        unit: unitName(model, { escape: false }),
        fields,
        values: assembleInit(i, false)
      }));
    }
    const contains2 = dataCopy.filter((d) => d.name === selCmpt.name + STORE);
    if (!contains2.length) {
      dataCopy.push(init);
    }
  }
  return dataCopy;
}
function assembleUnitSelectionMarks(model, marks) {
  var _a;
  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {
    for (const c of selectionCompilers) {
      if (c.defined(selCmpt) && c.marks) {
        marks = c.marks(model, selCmpt, marks);
      }
    }
  }
  return marks;
}
function assembleLayerSelectionMarks(model, marks) {
  for (const child of model.children) {
    if (isUnitModel(child)) {
      marks = assembleUnitSelectionMarks(child, marks);
    }
  }
  return marks;
}
function assembleSelectionScaleDomain(model, extent, scaleCmpt, domain2) {
  const parsedExtent = parseSelectionExtent(model, extent.param, extent);
  return {
    signal: hasContinuousDomain(scaleCmpt.get("type")) && isArray2(domain2) && domain2[0] > domain2[1] ? `isValid(${parsedExtent}) && reverse(${parsedExtent})` : parsedExtent
  };
}
function cleanupEmptyOnArray(signals) {
  return signals.map((s) => {
    if (s.on && !s.on.length)
      delete s.on;
    return s;
  });
}

// node_modules/vega-lite/build/src/compile/data/dataflow.js
var DataFlowNode = class {
  constructor(parent, debugName) {
    this.debugName = debugName;
    this._children = [];
    this._parent = null;
    if (parent) {
      this.parent = parent;
    }
  }
  clone() {
    throw new Error("Cannot clone node");
  }
  get parent() {
    return this._parent;
  }
  set parent(parent) {
    this._parent = parent;
    if (parent) {
      parent.addChild(this);
    }
  }
  get children() {
    return this._children;
  }
  numChildren() {
    return this._children.length;
  }
  addChild(child, loc) {
    if (this._children.includes(child)) {
      warn(message_exports.ADD_SAME_CHILD_TWICE);
      return;
    }
    if (loc !== void 0) {
      this._children.splice(loc, 0, child);
    } else {
      this._children.push(child);
    }
  }
  removeChild(oldChild) {
    const loc = this._children.indexOf(oldChild);
    this._children.splice(loc, 1);
    return loc;
  }
  remove() {
    let loc = this._parent.removeChild(this);
    for (const child of this._children) {
      child._parent = this._parent;
      this._parent.addChild(child, loc++);
    }
  }
  insertAsParentOf(other) {
    const parent = other.parent;
    parent.removeChild(this);
    this.parent = parent;
    other.parent = this;
  }
  swapWithParent() {
    const parent = this._parent;
    const newParent = parent.parent;
    for (const child of this._children) {
      child.parent = parent;
    }
    this._children = [];
    parent.removeChild(this);
    parent.parent.removeChild(parent);
    this.parent = newParent;
    parent.parent = this;
  }
};
var OutputNode = class extends DataFlowNode {
  constructor(parent, source2, type, refCounts) {
    super(parent, source2);
    this.type = type;
    this.refCounts = refCounts;
    this._source = this._name = source2;
    if (this.refCounts && !(this._name in this.refCounts)) {
      this.refCounts[this._name] = 0;
    }
  }
  clone() {
    const cloneObj = new this.constructor();
    cloneObj.debugName = `clone_${this.debugName}`;
    cloneObj._source = this._source;
    cloneObj._name = `clone_${this._name}`;
    cloneObj.type = this.type;
    cloneObj.refCounts = this.refCounts;
    cloneObj.refCounts[cloneObj._name] = 0;
    return cloneObj;
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {
    return new Set();
  }
  hash() {
    if (this._hash === void 0) {
      this._hash = `Output ${uniqueId()}`;
    }
    return this._hash;
  }
  getSource() {
    this.refCounts[this._name]++;
    return this._source;
  }
  isRequired() {
    return !!this.refCounts[this._name];
  }
  setSource(source2) {
    this._source = source2;
  }
};

// node_modules/vega-lite/build/src/compile/data/timeunit.js
var __rest17 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var TimeUnitNode = class extends DataFlowNode {
  constructor(parent, formula) {
    super(parent);
    this.formula = formula;
  }
  clone() {
    return new TimeUnitNode(null, duplicate(this.formula));
  }
  static makeFromEncoding(parent, model) {
    const formula = model.reduceFieldDef((timeUnitComponent, fieldDef) => {
      const { field, timeUnit } = fieldDef;
      if (timeUnit) {
        const as = vgField(fieldDef, { forAs: true });
        timeUnitComponent[hash({
          as,
          field,
          timeUnit
        })] = {
          as,
          field,
          timeUnit
        };
      }
      return timeUnitComponent;
    }, {});
    if (isEmpty(formula)) {
      return null;
    }
    return new TimeUnitNode(parent, formula);
  }
  static makeFromTransform(parent, t2) {
    const _a = Object.assign({}, t2), { timeUnit } = _a, other = __rest17(_a, ["timeUnit"]);
    const normalizedTimeUnit = normalizeTimeUnit(timeUnit);
    const component = Object.assign(Object.assign({}, other), { timeUnit: normalizedTimeUnit });
    return new TimeUnitNode(parent, {
      [hash(component)]: component
    });
  }
  merge(other) {
    this.formula = Object.assign({}, this.formula);
    for (const key in other.formula) {
      if (!this.formula[key]) {
        this.formula[key] = other.formula[key];
      }
    }
    for (const child of other.children) {
      other.removeChild(child);
      child.parent = this;
    }
    other.remove();
  }
  removeFormulas(fields) {
    const newFormula = {};
    for (const [key, timeUnit] of entries(this.formula)) {
      if (!fields.has(timeUnit.as)) {
        newFormula[key] = timeUnit;
      }
    }
    this.formula = newFormula;
  }
  producedFields() {
    return new Set(vals(this.formula).map((f) => f.as));
  }
  dependentFields() {
    return new Set(vals(this.formula).map((f) => f.field));
  }
  hash() {
    return `TimeUnit ${hash(this.formula)}`;
  }
  assemble() {
    const transforms = [];
    for (const f of vals(this.formula)) {
      const { field, as, timeUnit } = f;
      const _a = normalizeTimeUnit(timeUnit), { unit, utc } = _a, params = __rest17(_a, ["unit", "utc"]);
      transforms.push(Object.assign(Object.assign(Object.assign(Object.assign({ field: replacePathInField(field), type: "timeunit" }, unit ? { units: getTimeUnitParts(unit) } : {}), utc ? { timezone: "utc" } : {}), params), { as: [as, `${as}_end`] }));
    }
    return transforms;
  }
};

// node_modules/vega-lite/build/src/compile/selection/project.js
var __rest18 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var TUPLE_FIELDS = "_tuple_fields";
var SelectionProjectionComponent = class {
  constructor(...items) {
    this.items = items;
    this.hasChannel = {};
    this.hasField = {};
  }
};
var project = {
  defined: () => {
    return true;
  },
  parse: (model, selCmpt, selDef) => {
    var _a;
    const name5 = selCmpt.name;
    const proj = (_a = selCmpt.project) !== null && _a !== void 0 ? _a : selCmpt.project = new SelectionProjectionComponent();
    const parsed = {};
    const timeUnits = {};
    const signals = new Set();
    const signalName = (p, range2) => {
      const suffix = range2 === "visual" ? p.channel : p.field;
      let sg = varName(`${name5}_${suffix}`);
      for (let counter = 1; signals.has(sg); counter++) {
        sg = varName(`${name5}_${suffix}_${counter}`);
      }
      signals.add(sg);
      return { [range2]: sg };
    };
    const type = selCmpt.type;
    const cfg = model.config.selection[type];
    const init = selDef.value !== void 0 ? array(selDef.value) : null;
    let { fields, encodings } = isObject2(selDef.select) ? selDef.select : {};
    if (!fields && !encodings && init) {
      for (const initVal of init) {
        if (!isObject2(initVal)) {
          continue;
        }
        for (const key of keys(initVal)) {
          if (isSingleDefUnitChannel(key)) {
            (encodings || (encodings = [])).push(key);
          } else {
            if (type === "interval") {
              warn(message_exports.INTERVAL_INITIALIZED_WITH_X_Y);
              encodings = cfg.encodings;
            } else {
              (fields || (fields = [])).push(key);
            }
          }
        }
      }
    }
    if (!fields && !encodings) {
      encodings = cfg.encodings;
      if ("fields" in cfg) {
        fields = cfg.fields;
      }
    }
    for (const channel of encodings !== null && encodings !== void 0 ? encodings : []) {
      const fieldDef = model.fieldDef(channel);
      if (fieldDef) {
        let field = fieldDef.field;
        if (fieldDef.aggregate) {
          warn(message_exports.cannotProjectAggregate(channel, fieldDef.aggregate));
          continue;
        } else if (!field) {
          warn(message_exports.cannotProjectOnChannelWithoutField(channel));
          continue;
        }
        if (fieldDef.timeUnit) {
          field = model.vgField(channel);
          const component = {
            timeUnit: fieldDef.timeUnit,
            as: field,
            field: fieldDef.field
          };
          timeUnits[hash(component)] = component;
        }
        if (!parsed[field]) {
          let tplType = "E";
          if (type === "interval") {
            const scaleType2 = model.getScaleComponent(channel).get("type");
            if (hasContinuousDomain(scaleType2)) {
              tplType = "R";
            }
          } else if (fieldDef.bin) {
            tplType = "R-RE";
          }
          const p = { field, channel, type: tplType };
          p.signals = Object.assign(Object.assign({}, signalName(p, "data")), signalName(p, "visual"));
          proj.items.push(parsed[field] = p);
          proj.hasField[field] = proj.hasChannel[channel] = parsed[field];
        }
      } else {
        warn(message_exports.cannotProjectOnChannelWithoutField(channel));
      }
    }
    for (const field of fields !== null && fields !== void 0 ? fields : []) {
      if (proj.hasField[field])
        continue;
      const p = { type: "E", field };
      p.signals = Object.assign({}, signalName(p, "data"));
      proj.items.push(p);
      proj.hasField[field] = p;
    }
    if (init) {
      selCmpt.init = init.map((v) => {
        return proj.items.map((p) => isObject2(v) ? v[p.channel] !== void 0 ? v[p.channel] : v[p.field] : v);
      });
    }
    if (!isEmpty(timeUnits)) {
      proj.timeUnit = new TimeUnitNode(null, timeUnits);
    }
  },
  signals: (model, selCmpt, allSignals) => {
    const name5 = selCmpt.name + TUPLE_FIELDS;
    const hasSignal = allSignals.filter((s) => s.name === name5);
    return hasSignal.length > 0 ? allSignals : allSignals.concat({
      name: name5,
      value: selCmpt.project.items.map((proj) => {
        const { signals, hasLegend } = proj, rest = __rest18(proj, ["signals", "hasLegend"]);
        rest.field = replacePathInField(rest.field);
        return rest;
      })
    });
  }
};
var project_default = project;

// node_modules/vega-lite/build/src/compile/selection/scales.js
var scaleBindings = {
  defined: (selCmpt) => {
    return selCmpt.type === "interval" && selCmpt.resolve === "global" && selCmpt.bind && selCmpt.bind === "scales";
  },
  parse: (model, selCmpt) => {
    const bound = selCmpt.scales = [];
    for (const proj of selCmpt.project.items) {
      const channel = proj.channel;
      if (!isScaleChannel(channel)) {
        continue;
      }
      const scale = model.getScaleComponent(channel);
      const scaleType2 = scale ? scale.get("type") : void 0;
      if (!scale || !hasContinuousDomain(scaleType2)) {
        warn(message_exports.SCALE_BINDINGS_CONTINUOUS);
        continue;
      }
      scale.set("selectionExtent", { param: selCmpt.name, field: proj.field }, true);
      bound.push(proj);
    }
  },
  topLevelSignals: (model, selCmpt, signals) => {
    const bound = selCmpt.scales.filter((proj) => signals.filter((s) => s.name === proj.signals.data).length === 0);
    if (!model.parent || isTopLevelLayer(model) || bound.length === 0) {
      return signals;
    }
    const namedSg = signals.filter((s) => s.name === selCmpt.name)[0];
    let update = namedSg.update;
    if (update.indexOf(VL_SELECTION_RESOLVE) >= 0) {
      namedSg.update = `{${bound.map((proj) => `${$(replacePathInField(proj.field))}: ${proj.signals.data}`).join(", ")}}`;
    } else {
      for (const proj of bound) {
        const mapping = `${$(replacePathInField(proj.field))}: ${proj.signals.data}`;
        if (!update.includes(mapping)) {
          update = `${update.substring(0, update.length - 1)}, ${mapping}}`;
        }
      }
      namedSg.update = update;
    }
    return signals.concat(bound.map((proj) => ({ name: proj.signals.data })));
  },
  signals: (model, selCmpt, signals) => {
    if (model.parent && !isTopLevelLayer(model)) {
      for (const proj of selCmpt.scales) {
        const signal = signals.filter((s) => s.name === proj.signals.data)[0];
        signal.push = "outer";
        delete signal.value;
        delete signal.update;
      }
    }
    return signals;
  }
};
var scales_default = scaleBindings;
function domain(model, channel) {
  const scale = $(model.scaleName(channel));
  return `domain(${scale})`;
}
function isTopLevelLayer(model) {
  var _a;
  return model.parent && isLayerModel(model.parent) && ((_a = !model.parent.parent) !== null && _a !== void 0 ? _a : isTopLevelLayer(model.parent.parent));
}

// node_modules/vega-lite/build/src/compile/selection/interval.js
var __rest19 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var BRUSH = "_brush";
var SCALE_TRIGGER = "_scale_trigger";
var interval = {
  defined: (selCmpt) => selCmpt.type === "interval",
  signals: (model, selCmpt, signals) => {
    const name5 = selCmpt.name;
    const fieldsSg = name5 + TUPLE_FIELDS;
    const hasScales = scales_default.defined(selCmpt);
    const init = selCmpt.init ? selCmpt.init[0] : null;
    const dataSignals = [];
    const scaleTriggers = [];
    if (selCmpt.translate && !hasScales) {
      const filterExpr = `!event.item || event.item.mark.name !== ${$(name5 + BRUSH)}`;
      events(selCmpt, (on, evt) => {
        var _a;
        var _b;
        const filters = array((_a = (_b = evt.between[0]).filter) !== null && _a !== void 0 ? _a : _b.filter = []);
        if (!filters.includes(filterExpr)) {
          filters.push(filterExpr);
        }
        return on;
      });
    }
    selCmpt.project.items.forEach((proj, i) => {
      const channel = proj.channel;
      if (channel !== X && channel !== Y) {
        warn("Interval selections only support x and y encoding channels.");
        return;
      }
      const val = init ? init[i] : null;
      const cs = channelSignals(model, selCmpt, proj, val);
      const dname = proj.signals.data;
      const vname = proj.signals.visual;
      const scaleName = $(model.scaleName(channel));
      const scaleType2 = model.getScaleComponent(channel).get("type");
      const toNum = hasContinuousDomain(scaleType2) ? "+" : "";
      signals.push(...cs);
      dataSignals.push(dname);
      scaleTriggers.push({
        scaleName: model.scaleName(channel),
        expr: `(!isArray(${dname}) || (${toNum}invert(${scaleName}, ${vname})[0] === ${toNum}${dname}[0] && ${toNum}invert(${scaleName}, ${vname})[1] === ${toNum}${dname}[1]))`
      });
    });
    if (!hasScales && scaleTriggers.length) {
      signals.push({
        name: name5 + SCALE_TRIGGER,
        value: {},
        on: [
          {
            events: scaleTriggers.map((t2) => ({ scale: t2.scaleName })),
            update: `${scaleTriggers.map((t2) => t2.expr).join(" && ")} ? ${name5 + SCALE_TRIGGER} : {}`
          }
        ]
      });
    }
    const update = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;
    return signals.concat(Object.assign(Object.assign({ name: name5 + TUPLE }, init ? { init: `{${update}: ${assembleInit(init)}}` } : {}), dataSignals.length ? {
      on: [
        {
          events: [{ signal: dataSignals.join(" || ") }],
          update: `${dataSignals.join(" && ")} ? {${update}: [${dataSignals}]} : null`
        }
      ]
    } : {}));
  },
  marks: (model, selCmpt, marks) => {
    const name5 = selCmpt.name;
    const { x, y } = selCmpt.project.hasChannel;
    const xvname = x && x.signals.visual;
    const yvname = y && y.signals.visual;
    const store = `data(${$(selCmpt.name + STORE)})`;
    if (scales_default.defined(selCmpt) || !x && !y) {
      return marks;
    }
    const update = {
      x: x !== void 0 ? { signal: `${xvname}[0]` } : { value: 0 },
      y: y !== void 0 ? { signal: `${yvname}[0]` } : { value: 0 },
      x2: x !== void 0 ? { signal: `${xvname}[1]` } : { field: { group: "width" } },
      y2: y !== void 0 ? { signal: `${yvname}[1]` } : { field: { group: "height" } }
    };
    if (selCmpt.resolve === "global") {
      for (const key of keys(update)) {
        update[key] = [
          Object.assign({ test: `${store}.length && ${store}[0].unit === ${unitName(model)}` }, update[key]),
          { value: 0 }
        ];
      }
    }
    const _a = selCmpt.mark, { fill, fillOpacity, cursor: cursor2 } = _a, stroke = __rest19(_a, ["fill", "fillOpacity", "cursor"]);
    const vgStroke = keys(stroke).reduce((def, k) => {
      def[k] = [
        {
          test: [x !== void 0 && `${xvname}[0] !== ${xvname}[1]`, y !== void 0 && `${yvname}[0] !== ${yvname}[1]`].filter((t2) => t2).join(" && "),
          value: stroke[k]
        },
        { value: null }
      ];
      return def;
    }, {});
    return [
      {
        name: `${name5 + BRUSH}_bg`,
        type: "rect",
        clip: true,
        encode: {
          enter: {
            fill: { value: fill },
            fillOpacity: { value: fillOpacity }
          },
          update
        }
      },
      ...marks,
      {
        name: name5 + BRUSH,
        type: "rect",
        clip: true,
        encode: {
          enter: Object.assign(Object.assign({}, cursor2 ? { cursor: { value: cursor2 } } : {}), { fill: { value: "transparent" } }),
          update: Object.assign(Object.assign({}, update), vgStroke)
        }
      }
    ];
  }
};
var interval_default = interval;
function channelSignals(model, selCmpt, proj, init) {
  const channel = proj.channel;
  const vname = proj.signals.visual;
  const dname = proj.signals.data;
  const hasScales = scales_default.defined(selCmpt);
  const scaleName = $(model.scaleName(channel));
  const scale = model.getScaleComponent(channel);
  const scaleType2 = scale ? scale.get("type") : void 0;
  const scaled = (str) => `scale(${scaleName}, ${str})`;
  const size = model.getSizeSignalRef(channel === X ? "width" : "height").signal;
  const coord = `${channel}(unit)`;
  const on = events(selCmpt, (def, evt) => {
    return [
      ...def,
      { events: evt.between[0], update: `[${coord}, ${coord}]` },
      { events: evt, update: `[${vname}[0], clamp(${coord}, 0, ${size})]` }
    ];
  });
  on.push({
    events: { signal: selCmpt.name + SCALE_TRIGGER },
    update: hasContinuousDomain(scaleType2) ? `[${scaled(`${dname}[0]`)}, ${scaled(`${dname}[1]`)}]` : `[0, 0]`
  });
  return hasScales ? [{ name: dname, on: [] }] : [
    Object.assign(Object.assign({ name: vname }, init ? { init: assembleInit(init, true, scaled) } : { value: [] }), { on }),
    Object.assign(Object.assign({ name: dname }, init ? { init: assembleInit(init) } : {}), { on: [
      {
        events: { signal: vname },
        update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`
      }
    ] })
  ];
}
function events(selCmpt, cb) {
  return selCmpt.events.reduce((on, evt) => {
    if (!evt.between) {
      warn(`${evt} is not an ordered event stream for interval selections.`);
      return on;
    }
    return cb(on, evt);
  }, []);
}

// node_modules/vega-lite/build/src/compile/selection/point.js
var point = {
  defined: (selCmpt) => selCmpt.type === "point",
  signals: (model, selCmpt, signals) => {
    var _a;
    const name5 = selCmpt.name;
    const fieldsSg = name5 + TUPLE_FIELDS;
    const project2 = selCmpt.project;
    const datum = "(item().isVoronoi ? datum.datum : datum)";
    const values4 = project2.items.map((p) => {
      const fieldDef = model.fieldDef(p.channel);
      return (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) ? `[${datum}[${$(model.vgField(p.channel, {}))}], ${datum}[${$(model.vgField(p.channel, { binSuffix: "end" }))}]]` : `${datum}[${$(p.field)}]`;
    }).join(", ");
    const update = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;
    const events2 = selCmpt.events;
    const brushes = vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {}).reduce((acc, cmpt) => {
      return cmpt.type === "interval" ? acc.concat(cmpt.name + BRUSH) : acc;
    }, []).map((b) => `indexof(item().mark.name, '${b}') < 0`).join(" && ");
    const test = `datum && item().mark.marktype !== 'group'` + (brushes ? ` && ${brushes}` : "");
    return signals.concat([
      {
        name: name5 + TUPLE,
        on: events2 ? [
          {
            events: events2,
            update: `${test} ? {${update}: [${values4}]} : null`,
            force: true
          }
        ] : []
      }
    ]);
  }
};
var point_default = point;

// node_modules/vega-lite/build/src/compile/mark/encode/conditional.js
function wrapCondition(model, channelDef, vgChannel, refFn) {
  const condition = isConditionalDef(channelDef) && channelDef.condition;
  const valueRef = refFn(channelDef);
  if (condition) {
    const conditions = array(condition);
    const vgConditions = conditions.map((c) => {
      const conditionValueRef = refFn(c);
      if (isConditionalParameter(c)) {
        const { param, empty } = c;
        const test = parseSelectionPredicate(model, { param, empty });
        return Object.assign({ test }, conditionValueRef);
      } else {
        const test = expression2(model, c.test);
        return Object.assign({ test }, conditionValueRef);
      }
    });
    return {
      [vgChannel]: [...vgConditions, ...valueRef !== void 0 ? [valueRef] : []]
    };
  } else {
    return valueRef !== void 0 ? { [vgChannel]: valueRef } : {};
  }
}

// node_modules/vega-lite/build/src/compile/mark/encode/text.js
function text(model, channel = "text") {
  const channelDef = model.encoding[channel];
  return wrapCondition(model, channelDef, channel, (cDef) => textRef(cDef, model.config));
}
function textRef(channelDef, config, expr = "datum") {
  if (channelDef) {
    if (isValueDef(channelDef)) {
      return signalOrValueRef(channelDef.value);
    }
    if (isFieldOrDatumDef(channelDef)) {
      const { format, formatType } = getFormatMixins(channelDef);
      return formatSignalRef({ fieldOrDatumDef: channelDef, format, formatType, expr, config });
    }
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/mark/encode/tooltip.js
function tooltip(model, opt = {}) {
  const { encoding, markDef, config, stack: stack2 } = model;
  const channelDef = encoding.tooltip;
  if (isArray2(channelDef)) {
    return { tooltip: tooltipRefForEncoding({ tooltip: channelDef }, stack2, config, opt) };
  } else {
    const datum = opt.reactiveGeom ? "datum.datum" : "datum";
    return wrapCondition(model, channelDef, "tooltip", (cDef) => {
      const tooltipRefFromChannelDef = textRef(cDef, config, datum);
      if (tooltipRefFromChannelDef) {
        return tooltipRefFromChannelDef;
      }
      if (cDef === null) {
        return void 0;
      }
      let markTooltip = getMarkPropOrConfig("tooltip", markDef, config);
      if (markTooltip === true) {
        markTooltip = { content: "encoding" };
      }
      if (isString2(markTooltip)) {
        return { value: markTooltip };
      } else if (isObject2(markTooltip)) {
        if (isSignalRef(markTooltip)) {
          return markTooltip;
        } else if (markTooltip.content === "encoding") {
          return tooltipRefForEncoding(encoding, stack2, config, opt);
        } else {
          return { signal: datum };
        }
      }
      return void 0;
    });
  }
}
function tooltipData(encoding, stack2, config, { reactiveGeom } = {}) {
  const toSkip = {};
  const expr = reactiveGeom ? "datum.datum" : "datum";
  const tuples = [];
  function add2(fDef, channel) {
    const mainChannel = getMainRangeChannel(channel);
    const fieldDef = isTypedFieldDef(fDef) ? fDef : Object.assign(Object.assign({}, fDef), {
      type: encoding[mainChannel].type
    });
    const title2 = fieldDef.title || defaultTitle(fieldDef, config);
    const key = array(title2).join(", ");
    let value;
    if (isXorY(channel)) {
      const channel2 = channel === "x" ? "x2" : "y2";
      const fieldDef2 = getFieldDef(encoding[channel2]);
      if (isBinned(fieldDef.bin) && fieldDef2) {
        const startField = vgField(fieldDef, { expr });
        const endField = vgField(fieldDef2, { expr });
        const { format, formatType } = getFormatMixins(fieldDef);
        value = binFormatExpression(startField, endField, format, formatType, config);
        toSkip[channel2] = true;
      } else if (stack2 && stack2.fieldChannel === channel && stack2.offset === "normalize") {
        const { format, formatType } = getFormatMixins(fieldDef);
        value = formatSignalRef({
          fieldOrDatumDef: fieldDef,
          format,
          formatType,
          expr,
          config,
          normalizeStack: true
        }).signal;
      }
    }
    value !== null && value !== void 0 ? value : value = textRef(fieldDef, config, expr).signal;
    tuples.push({ channel, key, value });
  }
  forEach(encoding, (channelDef, channel) => {
    if (isFieldDef(channelDef)) {
      add2(channelDef, channel);
    } else if (hasConditionalFieldDef(channelDef)) {
      add2(channelDef.condition, channel);
    }
  });
  const out = {};
  for (const { channel, key, value } of tuples) {
    if (!toSkip[channel] && !out[key]) {
      out[key] = value;
    }
  }
  return out;
}
function tooltipRefForEncoding(encoding, stack2, config, { reactiveGeom } = {}) {
  const data = tooltipData(encoding, stack2, config, { reactiveGeom });
  const keyValues = entries(data).map(([key, value]) => `"${key}": ${value}`);
  return keyValues.length > 0 ? { signal: `{${keyValues.join(", ")}}` } : void 0;
}

// node_modules/vega-lite/build/src/compile/mark/encode/aria.js
function aria(model) {
  const { markDef, config } = model;
  const enableAria = getMarkPropOrConfig("aria", markDef, config);
  if (enableAria === false) {
    return {};
  }
  return Object.assign(Object.assign(Object.assign({}, enableAria ? { aria: enableAria } : {}), ariaRoleDescription(model)), description2(model));
}
function ariaRoleDescription(model) {
  const { mark: mark3, markDef, config } = model;
  if (config.aria === false) {
    return {};
  }
  const ariaRoleDesc = getMarkPropOrConfig("ariaRoleDescription", markDef, config);
  if (ariaRoleDesc != null) {
    return { ariaRoleDescription: { value: ariaRoleDesc } };
  }
  return mark3 in VG_MARK_INDEX ? {} : { ariaRoleDescription: { value: mark3 } };
}
function description2(model) {
  const { encoding, markDef, config, stack: stack2 } = model;
  const channelDef = encoding.description;
  if (channelDef) {
    return wrapCondition(model, channelDef, "description", (cDef) => textRef(cDef, model.config));
  }
  const descriptionValue = getMarkPropOrConfig("description", markDef, config);
  if (descriptionValue != null) {
    return {
      description: signalOrValueRef(descriptionValue)
    };
  }
  if (config.aria === false) {
    return {};
  }
  const data = tooltipData(encoding, stack2, config);
  if (isEmpty(data)) {
    return void 0;
  }
  return {
    description: {
      signal: entries(data).map(([key, value], index2) => `"${index2 > 0 ? "; " : ""}${key}: " + (${value})`).join(" + ")
    }
  };
}

// node_modules/vega-lite/build/src/compile/mark/encode/nonposition.js
function nonPosition(channel, model, opt = {}) {
  const { markDef, encoding, config } = model;
  const { vgChannel } = opt;
  let { defaultRef, defaultValue } = opt;
  if (defaultRef === void 0) {
    defaultValue !== null && defaultValue !== void 0 ? defaultValue : defaultValue = getMarkPropOrConfig(channel, markDef, config, { vgChannel, ignoreVgConfig: true });
    if (defaultValue !== void 0) {
      defaultRef = signalOrValueRef(defaultValue);
    }
  }
  const channelDef = encoding[channel];
  return wrapCondition(model, channelDef, vgChannel !== null && vgChannel !== void 0 ? vgChannel : channel, (cDef) => {
    return midPoint({
      channel,
      channelDef: cDef,
      markDef,
      config,
      scaleName: model.scaleName(channel),
      scale: model.getScaleComponent(channel),
      stack: null,
      defaultRef
    });
  });
}

// node_modules/vega-lite/build/src/compile/mark/encode/color.js
function color(model, opt = { filled: void 0 }) {
  var _a, _b, _c, _d;
  const { markDef, encoding, config } = model;
  const { type: markType } = markDef;
  const filled = (_a = opt.filled) !== null && _a !== void 0 ? _a : getMarkPropOrConfig("filled", markDef, config);
  const transparentIfNeeded = contains(["bar", "point", "circle", "square", "geoshape"], markType) ? "transparent" : void 0;
  const defaultFill = (_c = (_b = getMarkPropOrConfig(filled === true ? "color" : void 0, markDef, config, { vgChannel: "fill" })) !== null && _b !== void 0 ? _b : config.mark[filled === true && "color"]) !== null && _c !== void 0 ? _c : transparentIfNeeded;
  const defaultStroke = (_d = getMarkPropOrConfig(filled === false ? "color" : void 0, markDef, config, { vgChannel: "stroke" })) !== null && _d !== void 0 ? _d : config.mark[filled === false && "color"];
  const colorVgChannel = filled ? "fill" : "stroke";
  const fillStrokeMarkDefAndConfig = Object.assign(Object.assign({}, defaultFill ? { fill: signalOrValueRef(defaultFill) } : {}), defaultStroke ? { stroke: signalOrValueRef(defaultStroke) } : {});
  if (markDef.color && (filled ? markDef.fill : markDef.stroke)) {
    warn(message_exports.droppingColor("property", { fill: "fill" in markDef, stroke: "stroke" in markDef }));
  }
  return Object.assign(Object.assign(Object.assign(Object.assign({}, fillStrokeMarkDefAndConfig), nonPosition("color", model, {
    vgChannel: colorVgChannel,
    defaultValue: filled ? defaultFill : defaultStroke
  })), nonPosition("fill", model, {
    defaultValue: encoding.fill ? defaultFill : void 0
  })), nonPosition("stroke", model, {
    defaultValue: encoding.stroke ? defaultStroke : void 0
  }));
}

// node_modules/vega-lite/build/src/compile/mark/encode/zindex.js
function zindex(model) {
  const { encoding, mark: mark3 } = model;
  const order = encoding.order;
  if (!isPathMark(mark3) && isValueDef(order)) {
    return wrapCondition(model, order, "zindex", (cd) => signalOrValueRef(cd.value));
  }
  return {};
}

// node_modules/vega-lite/build/src/compile/mark/encode/offset.js
function getOffset(channel, markDef) {
  const offsetChannel = getOffsetChannel(channel);
  const markDefOffsetValue = markDef[offsetChannel];
  if (markDefOffsetValue) {
    return markDefOffsetValue;
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/mark/encode/position-point.js
function pointPosition(channel, model, { defaultPos, vgChannel }) {
  const { encoding, markDef, config, stack: stack2 } = model;
  const channelDef = encoding[channel];
  const channel2Def = encoding[getSecondaryRangeChannel(channel)];
  const scaleName = model.scaleName(channel);
  const scale = model.getScaleComponent(channel);
  const offset = getOffset(channel, markDef);
  const defaultRef = pointPositionDefaultRef({
    model,
    defaultPos,
    channel,
    scaleName,
    scale
  });
  const valueRef = !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude) ? { field: model.getName(channel) } : positionRef({
    channel,
    channelDef,
    channel2Def,
    markDef,
    config,
    scaleName,
    scale,
    stack: stack2,
    offset,
    defaultRef
  });
  return valueRef ? { [vgChannel || channel]: valueRef } : void 0;
}
function positionRef(params) {
  const { channel, channelDef, scaleName, stack: stack2, offset, markDef } = params;
  if (isFieldOrDatumDef(channelDef) && stack2 && channel === stack2.fieldChannel) {
    if (isFieldDef(channelDef)) {
      let bandPosition = channelDef.bandPosition;
      if (bandPosition === void 0 && markDef.type === "text" && (channel === "radius" || channel === "theta")) {
        bandPosition = 0.5;
      }
      if (bandPosition !== void 0) {
        return interpolatedSignalRef({
          scaleName,
          fieldOrDatumDef: channelDef,
          startSuffix: "start",
          bandPosition,
          offset
        });
      }
    }
    return valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: "end" }, { offset });
  }
  return midPointRefWithPositionInvalidTest(params);
}
function pointPositionDefaultRef({ model, defaultPos, channel, scaleName, scale }) {
  const { markDef, config } = model;
  return () => {
    const mainChannel = getMainRangeChannel(channel);
    const vgChannel = getVgPositionChannel(channel);
    const definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, { vgChannel });
    if (definedValueOrConfig !== void 0) {
      return widthHeightValueOrSignalRef(channel, definedValueOrConfig);
    }
    switch (defaultPos) {
      case "zeroOrMin":
      case "zeroOrMax":
        if (scaleName) {
          const scaleType2 = scale.get("type");
          if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType2)) {
          } else {
            if (scale.domainDefinitelyIncludesZero()) {
              return {
                scale: scaleName,
                value: 0
              };
            }
          }
        }
        if (defaultPos === "zeroOrMin") {
          return mainChannel === "y" ? { field: { group: "height" } } : { value: 0 };
        } else {
          switch (mainChannel) {
            case "radius":
              return {
                signal: `min(${model.width.signal},${model.height.signal})/2`
              };
            case "theta":
              return { signal: "2*PI" };
            case "x":
              return { field: { group: "width" } };
            case "y":
              return { value: 0 };
          }
        }
        break;
      case "mid": {
        const sizeRef = model[getSizeChannel(channel)];
        return Object.assign(Object.assign({}, sizeRef), { mult: 0.5 });
      }
    }
    return void 0;
  };
}

// node_modules/vega-lite/build/src/compile/mark/encode/position-align.js
var ALIGNED_X_CHANNEL = {
  left: "x",
  center: "xc",
  right: "x2"
};
var BASELINED_Y_CHANNEL = {
  top: "y",
  middle: "yc",
  bottom: "y2"
};
function vgAlignedPositionChannel(channel, markDef, config, defaultAlign = "middle") {
  if (channel === "radius" || channel === "theta") {
    return getVgPositionChannel(channel);
  }
  const alignChannel = channel === "x" ? "align" : "baseline";
  const align2 = getMarkPropOrConfig(alignChannel, markDef, config);
  let alignExcludingSignal;
  if (isSignalRef(align2)) {
    warn(message_exports.rangeMarkAlignmentCannotBeExpression(alignChannel));
    alignExcludingSignal = void 0;
  } else {
    alignExcludingSignal = align2;
  }
  if (channel === "x") {
    return ALIGNED_X_CHANNEL[alignExcludingSignal || (defaultAlign === "top" ? "left" : "center")];
  } else {
    return BASELINED_Y_CHANNEL[alignExcludingSignal || defaultAlign];
  }
}

// node_modules/vega-lite/build/src/compile/mark/encode/position-range.js
function pointOrRangePosition(channel, model, { defaultPos, defaultPos2, range: range2 }) {
  if (range2) {
    return rangePosition(channel, model, { defaultPos, defaultPos2 });
  }
  return pointPosition(channel, model, { defaultPos });
}
function rangePosition(channel, model, { defaultPos, defaultPos2 }) {
  const { markDef, config } = model;
  const channel2 = getSecondaryRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);
  const vgChannel = pos2Mixins[sizeChannel] ? vgAlignedPositionChannel(channel, markDef, config) : getVgPositionChannel(channel);
  return Object.assign(Object.assign({}, pointPosition(channel, model, { defaultPos, vgChannel })), pos2Mixins);
}
function pointPosition2OrSize(model, defaultPos, channel) {
  const { encoding, mark: mark3, markDef, stack: stack2, config } = model;
  const baseChannel = getMainRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  const channelDef = encoding[baseChannel];
  const scaleName = model.scaleName(baseChannel);
  const scale = model.getScaleComponent(baseChannel);
  const offset = channel in encoding || channel in markDef ? getOffset(channel, model.markDef) : getOffset(baseChannel, model.markDef);
  if (!channelDef && (channel === "x2" || channel === "y2") && (encoding.latitude || encoding.longitude)) {
    const vgSizeChannel = getSizeChannel(channel);
    const size = model.markDef[vgSizeChannel];
    if (size != null) {
      return {
        [vgSizeChannel]: { value: size }
      };
    } else {
      return {
        [vgChannel]: { field: model.getName(channel) }
      };
    }
  }
  const valueRef = position2Ref({
    channel,
    channelDef,
    channel2Def: encoding[channel],
    markDef,
    config,
    scaleName,
    scale,
    stack: stack2,
    offset,
    defaultRef: void 0
  });
  if (valueRef !== void 0) {
    return { [vgChannel]: valueRef };
  }
  return position2orSize(channel, markDef) || position2orSize(channel, {
    [channel]: getMarkStyleConfig(channel, markDef, config.style),
    [sizeChannel]: getMarkStyleConfig(sizeChannel, markDef, config.style)
  }) || position2orSize(channel, config[mark3]) || position2orSize(channel, config.mark) || {
    [vgChannel]: pointPositionDefaultRef({
      model,
      defaultPos,
      channel,
      scaleName,
      scale
    })()
  };
}
function position2Ref({ channel, channelDef, channel2Def, markDef, config, scaleName, scale, stack: stack2, offset, defaultRef }) {
  if (isFieldOrDatumDef(channelDef) && stack2 && channel.charAt(0) === stack2.fieldChannel.charAt(0)) {
    return valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: "start" }, { offset });
  }
  return midPointRefWithPositionInvalidTest({
    channel,
    channelDef: channel2Def,
    scaleName,
    scale,
    stack: stack2,
    markDef,
    config,
    offset,
    defaultRef
  });
}
function position2orSize(channel, markDef) {
  const sizeChannel = getSizeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  if (markDef[vgChannel] !== void 0) {
    return { [vgChannel]: widthHeightValueOrSignalRef(channel, markDef[vgChannel]) };
  } else if (markDef[channel] !== void 0) {
    return { [vgChannel]: widthHeightValueOrSignalRef(channel, markDef[channel]) };
  } else if (markDef[sizeChannel]) {
    const dimensionSize = markDef[sizeChannel];
    if (isRelativeBandSize(dimensionSize)) {
      warn(message_exports.relativeBandSizeNotSupported(sizeChannel));
    } else {
      return { [sizeChannel]: widthHeightValueOrSignalRef(channel, dimensionSize) };
    }
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/mark/encode/position-rect.js
function rectPosition(model, channel, mark3) {
  var _a, _b, _c, _d;
  const { config, encoding, markDef } = model;
  const channel2 = getSecondaryRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const channelDef = encoding[channel];
  const channelDef2 = encoding[channel2];
  const scale = model.getScaleComponent(channel);
  const scaleType2 = scale ? scale.get("type") : void 0;
  const scaleName = model.scaleName(channel);
  const orient2 = markDef.orient;
  const hasSizeDef = (_b = (_a = encoding[sizeChannel]) !== null && _a !== void 0 ? _a : encoding.size) !== null && _b !== void 0 ? _b : getMarkPropOrConfig("size", markDef, config, { vgChannel: sizeChannel });
  const isBarBand = mark3 === "bar" && (channel === "x" ? orient2 === "vertical" : orient2 === "horizontal");
  if (isFieldDef(channelDef) && (isBinning(channelDef.bin) || isBinned(channelDef.bin) || channelDef.timeUnit && !channelDef2) && !(hasSizeDef && !isRelativeBandSize(hasSizeDef)) && !hasDiscreteDomain(scaleType2)) {
    const bandSize = getBandSize({ channel, fieldDef: channelDef, markDef, config, scaleType: scaleType2 });
    const axis = (_c = model.component.axes[channel]) === null || _c === void 0 ? void 0 : _c[0];
    const axisTranslate = (_d = axis === null || axis === void 0 ? void 0 : axis.get("translate")) !== null && _d !== void 0 ? _d : 0.5;
    return rectBinPosition({
      fieldDef: channelDef,
      fieldDef2: channelDef2,
      channel,
      markDef,
      scaleName,
      bandSize,
      axisTranslate,
      spacing: isXorY(channel) ? getMarkPropOrConfig("binSpacing", markDef, config) : void 0,
      reverse: scale.get("reverse"),
      config
    });
  } else if ((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType2) || isBarBand) && !channelDef2) {
    return positionAndSize(channelDef, channel, model);
  } else {
    return rangePosition(channel, model, { defaultPos: "zeroOrMax", defaultPos2: "zeroOrMin" });
  }
}
function defaultSizeRef(sizeChannel, scaleName, scale, config, bandSize) {
  if (isRelativeBandSize(bandSize)) {
    if (scale) {
      const scaleType2 = scale.get("type");
      if (scaleType2 === "band") {
        return { scale: scaleName, band: bandSize.band };
      } else if (bandSize.band !== 1) {
        warn(message_exports.cannotUseRelativeBandSizeWithNonBandScale(scaleType2));
        bandSize = void 0;
      }
    } else {
      return {
        mult: bandSize.band,
        field: { group: sizeChannel }
      };
    }
  } else if (isSignalRef(bandSize)) {
    return bandSize;
  } else if (bandSize) {
    return { value: bandSize };
  }
  if (scale) {
    const scaleRange = scale.get("range");
    if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {
      return { value: scaleRange.step - 2 };
    }
  }
  const defaultStep = getViewConfigDiscreteStep(config.view, sizeChannel);
  return { value: defaultStep - 2 };
}
function positionAndSize(fieldDef, channel, model) {
  const { markDef, encoding, config, stack: stack2 } = model;
  const orient2 = markDef.orient;
  const scaleName = model.scaleName(channel);
  const scale = model.getScaleComponent(channel);
  const vgSizeChannel = getSizeChannel(channel);
  const channel2 = getSecondaryRangeChannel(channel);
  const useVlSizeChannel = orient2 === "horizontal" && channel === "y" || orient2 === "vertical" && channel === "x";
  let sizeMixins;
  if (encoding.size || markDef.size) {
    if (useVlSizeChannel) {
      sizeMixins = nonPosition("size", model, {
        vgChannel: vgSizeChannel,
        defaultRef: signalOrValueRef(markDef.size)
      });
    } else {
      warn(message_exports.cannotApplySizeToNonOrientedMark(markDef.type));
    }
  }
  const bandSize = getBandSize({ channel, fieldDef, markDef, config, scaleType: scale === null || scale === void 0 ? void 0 : scale.get("type"), useVlSizeChannel });
  sizeMixins = sizeMixins || { [vgSizeChannel]: defaultSizeRef(vgSizeChannel, scaleName, scale, config, bandSize) };
  const defaultBandAlign = (scale === null || scale === void 0 ? void 0 : scale.get("type")) !== "band" || !("band" in sizeMixins[vgSizeChannel]) ? "middle" : "top";
  const vgChannel = vgAlignedPositionChannel(channel, markDef, config, defaultBandAlign);
  const center = vgChannel === "xc" || vgChannel === "yc";
  const offset = getOffset(channel, markDef);
  const posRef = midPointRefWithPositionInvalidTest({
    channel,
    channelDef: fieldDef,
    markDef,
    config,
    scaleName,
    scale,
    stack: stack2,
    offset,
    defaultRef: pointPositionDefaultRef({ model, defaultPos: "mid", channel, scaleName, scale }),
    bandPosition: center ? 0.5 : isSignalRef(bandSize) ? { signal: `(1-${bandSize})/2` } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0
  });
  if (vgSizeChannel) {
    return Object.assign({ [vgChannel]: posRef }, sizeMixins);
  } else {
    const vgChannel2 = getVgPositionChannel(channel2);
    const sizeRef = sizeMixins[vgSizeChannel];
    const sizeOffset = offset ? Object.assign(Object.assign({}, sizeRef), { offset }) : sizeRef;
    return {
      [vgChannel]: posRef,
      [vgChannel2]: isArray2(posRef) ? [posRef[0], Object.assign(Object.assign({}, posRef[1]), { offset: sizeOffset })] : Object.assign(Object.assign({}, posRef), { offset: sizeOffset })
    };
  }
}
function getBinSpacing(channel, spacing, reverse2, translate2, offset) {
  if (isPolarPositionChannel(channel)) {
    return 0;
  }
  const spacingOffset = channel === "x" || channel === "y2" ? -spacing / 2 : spacing / 2;
  if (isSignalRef(reverse2) || isSignalRef(offset) || isSignalRef(translate2)) {
    const reverseExpr = signalOrStringValue(reverse2);
    const offsetExpr = signalOrStringValue(offset);
    const translateExpr = signalOrStringValue(translate2);
    const t2 = translateExpr ? `${translateExpr} + ` : "";
    const r = reverseExpr ? `(${reverseExpr} ? -1 : 1) * ` : "";
    const o = offsetExpr ? `(${offsetExpr} + ${spacingOffset})` : spacingOffset;
    return {
      signal: t2 + r + o
    };
  } else {
    offset = offset || 0;
    return translate2 + (reverse2 ? -offset - spacingOffset : +offset + spacingOffset);
  }
}
function rectBinPosition({ fieldDef, fieldDef2, channel, bandSize, scaleName, markDef, spacing = 0, axisTranslate, reverse: reverse2, config }) {
  const channel2 = getSecondaryRangeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  const vgChannel2 = getVgPositionChannel(channel2);
  const offset = getOffset(channel, markDef);
  const bandPosition = isSignalRef(bandSize) ? { signal: `(1-${bandSize.signal})/2` } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0.5;
  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {
    return {
      [vgChannel2]: rectBinRef({
        channel,
        fieldDef,
        scaleName,
        markDef,
        bandPosition,
        offset: getBinSpacing(channel2, spacing, reverse2, axisTranslate, offset),
        config
      }),
      [vgChannel]: rectBinRef({
        channel,
        fieldDef,
        scaleName,
        markDef,
        bandPosition: isSignalRef(bandPosition) ? { signal: `1-${bandPosition.signal}` } : 1 - bandPosition,
        offset: getBinSpacing(channel, spacing, reverse2, axisTranslate, offset),
        config
      })
    };
  } else if (isBinned(fieldDef.bin)) {
    const startRef = valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, { offset: getBinSpacing(channel2, spacing, reverse2, axisTranslate, offset) });
    if (isFieldDef(fieldDef2)) {
      return {
        [vgChannel2]: startRef,
        [vgChannel]: valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, { offset: getBinSpacing(channel, spacing, reverse2, axisTranslate, offset) })
      };
    } else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {
      return {
        [vgChannel2]: startRef,
        [vgChannel]: {
          signal: `scale("${scaleName}", ${vgField(fieldDef, { expr: "datum" })} + ${fieldDef.bin.step})`,
          offset: getBinSpacing(channel, spacing, reverse2, axisTranslate, offset)
        }
      };
    }
  }
  warn(message_exports.channelRequiredForBinned(channel2));
  return void 0;
}
function rectBinRef({ channel, fieldDef, scaleName, markDef, bandPosition, offset, config }) {
  const r = interpolatedSignalRef({
    scaleName,
    fieldOrDatumDef: fieldDef,
    bandPosition,
    offset
  });
  return wrapPositionInvalidTest({
    fieldDef,
    channel,
    markDef,
    ref: r,
    config
  });
}

// node_modules/vega-lite/build/src/compile/mark/encode/base.js
var ALWAYS_IGNORE = new Set(["aria", "width", "height"]);
function baseEncodeEntry(model, ignore) {
  const { fill = void 0, stroke = void 0 } = ignore.color === "include" ? color(model) : {};
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, markDefProperties(model.markDef, ignore)), wrapAllFieldsInvalid(model, "fill", fill)), wrapAllFieldsInvalid(model, "stroke", stroke)), nonPosition("opacity", model)), nonPosition("fillOpacity", model)), nonPosition("strokeOpacity", model)), nonPosition("strokeWidth", model)), nonPosition("strokeDash", model)), zindex(model)), tooltip(model)), text(model, "href")), aria(model));
}
function wrapAllFieldsInvalid(model, channel, valueRef) {
  const { config, mark: mark3, markDef } = model;
  const invalid = getMarkPropOrConfig("invalid", markDef, config);
  if (invalid === "hide" && valueRef && !isPathMark(mark3)) {
    const test = allFieldsInvalidPredicate(model, { invalid: true, channels: SCALE_CHANNELS });
    if (test) {
      return {
        [channel]: [
          { test, value: null },
          ...array(valueRef)
        ]
      };
    }
  }
  return valueRef ? { [channel]: valueRef } : {};
}
function markDefProperties(mark3, ignore) {
  return VG_MARK_CONFIGS.reduce((m, prop) => {
    if (!ALWAYS_IGNORE.has(prop) && mark3[prop] !== void 0 && ignore[prop] !== "ignore") {
      m[prop] = signalOrValueRef(mark3[prop]);
    }
    return m;
  }, {});
}
function allFieldsInvalidPredicate(model, { invalid = false, channels }) {
  const filterIndex = channels.reduce((aggregator, channel) => {
    const scaleComponent = model.getScaleComponent(channel);
    if (scaleComponent) {
      const scaleType2 = scaleComponent.get("type");
      const field = model.vgField(channel, { expr: "datum" });
      if (field && hasContinuousDomain(scaleType2)) {
        aggregator[field] = true;
      }
    }
    return aggregator;
  }, {});
  const fields = keys(filterIndex);
  if (fields.length > 0) {
    const op = invalid ? "||" : "&&";
    return fields.map((field) => fieldInvalidPredicate(field, invalid)).join(` ${op} `);
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/mark/encode/defined.js
function defined(model) {
  const { config, markDef } = model;
  const invalid = getMarkPropOrConfig("invalid", markDef, config);
  if (invalid) {
    const signal = allFieldsInvalidPredicate2(model, { channels: POSITION_SCALE_CHANNELS });
    if (signal) {
      return { defined: { signal } };
    }
  }
  return {};
}
function allFieldsInvalidPredicate2(model, { invalid = false, channels }) {
  const filterIndex = channels.reduce((aggregator, channel) => {
    const scaleComponent = model.getScaleComponent(channel);
    if (scaleComponent) {
      const scaleType2 = scaleComponent.get("type");
      const field = model.vgField(channel, { expr: "datum" });
      if (field && hasContinuousDomain(scaleType2)) {
        aggregator[field] = true;
      }
    }
    return aggregator;
  }, {});
  const fields = keys(filterIndex);
  if (fields.length > 0) {
    const op = invalid ? "||" : "&&";
    return fields.map((field) => fieldInvalidPredicate(field, invalid)).join(` ${op} `);
  }
  return void 0;
}
function valueIfDefined(prop, value) {
  if (value !== void 0) {
    return { [prop]: signalOrValueRef(value) };
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/selection/nearest.js
var VORONOI = "voronoi";
var nearest = {
  defined: (selCmpt) => {
    return selCmpt.type === "point" && selCmpt.nearest;
  },
  parse: (model, selCmpt) => {
    if (selCmpt.events) {
      for (const s of selCmpt.events) {
        s.markname = model.getName(VORONOI);
      }
    }
  },
  marks: (model, selCmpt, marks) => {
    const { x, y } = selCmpt.project.hasChannel;
    const markType = model.mark;
    if (isPathMark(markType)) {
      warn(message_exports.nearestNotSupportForContinuous(markType));
      return marks;
    }
    const cellDef = {
      name: model.getName(VORONOI),
      type: "path",
      interactive: true,
      from: { data: model.getName("marks") },
      encode: {
        update: Object.assign({ fill: { value: "transparent" }, strokeWidth: { value: 0.35 }, stroke: { value: "transparent" }, isVoronoi: { value: true } }, tooltip(model, { reactiveGeom: true }))
      },
      transform: [
        {
          type: "voronoi",
          x: { expr: x || !y ? "datum.datum.x || 0" : "0" },
          y: { expr: y || !x ? "datum.datum.y || 0" : "0" },
          size: [model.getSizeSignalRef("width"), model.getSizeSignalRef("height")]
        }
      ]
    };
    let index2 = 0;
    let exists = false;
    marks.forEach((mark3, i) => {
      var _a;
      const name5 = (_a = mark3.name) !== null && _a !== void 0 ? _a : "";
      if (name5 === model.component.mark[0].name) {
        index2 = i;
      } else if (name5.indexOf(VORONOI) >= 0) {
        exists = true;
      }
    });
    if (!exists) {
      marks.splice(index2 + 1, 0, cellDef);
    }
    return marks;
  }
};
var nearest_default = nearest;

// node_modules/vega-lite/build/src/compile/selection/inputs.js
var inputBindings = {
  defined: (selCmpt) => {
    return selCmpt.type === "point" && selCmpt.resolve === "global" && selCmpt.bind && selCmpt.bind !== "scales" && !isLegendBinding(selCmpt.bind);
  },
  parse: (model, selCmpt, selDef) => disableDirectManipulation(selCmpt, selDef),
  topLevelSignals: (model, selCmpt, signals) => {
    const name5 = selCmpt.name;
    const proj = selCmpt.project;
    const bind = selCmpt.bind;
    const init = selCmpt.init && selCmpt.init[0];
    const datum = nearest_default.defined(selCmpt) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
    proj.items.forEach((p, i) => {
      var _a, _b;
      const sgname = varName(`${name5}_${p.field}`);
      const hasSignal = signals.filter((s) => s.name === sgname);
      if (!hasSignal.length) {
        signals.unshift(Object.assign(Object.assign({ name: sgname }, init ? { init: assembleInit(init[i]) } : { value: null }), { on: selCmpt.events ? [
          {
            events: selCmpt.events,
            update: `datum && item().mark.marktype !== 'group' ? ${datum}[${$(p.field)}] : null`
          }
        ] : [], bind: (_b = (_a = bind[p.field]) !== null && _a !== void 0 ? _a : bind[p.channel]) !== null && _b !== void 0 ? _b : bind }));
      }
    });
    return signals;
  },
  signals: (model, selCmpt, signals) => {
    const name5 = selCmpt.name;
    const proj = selCmpt.project;
    const signal = signals.filter((s) => s.name === name5 + TUPLE)[0];
    const fields = name5 + TUPLE_FIELDS;
    const values4 = proj.items.map((p) => varName(`${name5}_${p.field}`));
    const valid = values4.map((v) => `${v} !== null`).join(" && ");
    if (values4.length) {
      signal.update = `${valid} ? {fields: ${fields}, values: [${values4.join(", ")}]} : null`;
    }
    delete signal.value;
    delete signal.on;
    return signals;
  }
};
var inputs_default = inputBindings;

// node_modules/vega-lite/build/src/compile/selection/toggle.js
var TOGGLE = "_toggle";
var toggle = {
  defined: (selCmpt) => {
    return selCmpt.type === "point" && !!selCmpt.toggle;
  },
  signals: (model, selCmpt, signals) => {
    return signals.concat({
      name: selCmpt.name + TOGGLE,
      value: false,
      on: [{ events: selCmpt.events, update: selCmpt.toggle }]
    });
  },
  modifyExpr: (model, selCmpt) => {
    const tpl = selCmpt.name + TUPLE;
    const signal = selCmpt.name + TOGGLE;
    return `${signal} ? null : ${tpl}, ` + (selCmpt.resolve === "global" ? `${signal} ? null : true, ` : `${signal} ? null : {unit: ${unitName(model)}}, `) + `${signal} ? ${tpl} : null`;
  }
};
var toggle_default = toggle;

// node_modules/vega-lite/build/src/compile/selection/clear.js
var clear = {
  defined: (selCmpt) => {
    return selCmpt.clear !== void 0 && selCmpt.clear !== false;
  },
  parse: (model, selCmpt) => {
    if (selCmpt.clear) {
      selCmpt.clear = isString2(selCmpt.clear) ? eventSelector(selCmpt.clear, "view") : selCmpt.clear;
    }
  },
  topLevelSignals: (model, selCmpt, signals) => {
    if (inputs_default.defined(selCmpt)) {
      for (const proj of selCmpt.project.items) {
        const idx = signals.findIndex((n) => n.name === varName(`${selCmpt.name}_${proj.field}`));
        if (idx !== -1) {
          signals[idx].on.push({ events: selCmpt.clear, update: "null" });
        }
      }
    }
    return signals;
  },
  signals: (model, selCmpt, signals) => {
    function addClear(idx, update) {
      if (idx !== -1 && signals[idx].on) {
        signals[idx].on.push({ events: selCmpt.clear, update });
      }
    }
    if (selCmpt.type === "interval") {
      for (const proj of selCmpt.project.items) {
        const vIdx = signals.findIndex((n) => n.name === proj.signals.visual);
        addClear(vIdx, "[0, 0]");
        if (vIdx === -1) {
          const dIdx = signals.findIndex((n) => n.name === proj.signals.data);
          addClear(dIdx, "null");
        }
      }
    } else {
      let tIdx = signals.findIndex((n) => n.name === selCmpt.name + TUPLE);
      addClear(tIdx, "null");
      if (toggle_default.defined(selCmpt)) {
        tIdx = signals.findIndex((n) => n.name === selCmpt.name + TOGGLE);
        addClear(tIdx, "false");
      }
    }
    return signals;
  }
};
var clear_default = clear;

// node_modules/vega-lite/build/src/compile/selection/legends.js
var legendBindings = {
  defined: (selCmpt) => {
    const spec = selCmpt.resolve === "global" && selCmpt.bind && isLegendBinding(selCmpt.bind);
    const projLen = selCmpt.project.items.length === 1 && selCmpt.project.items[0].field !== SELECTION_ID;
    if (spec && !projLen) {
      warn(message_exports.LEGEND_BINDINGS_MUST_HAVE_PROJECTION);
    }
    return spec && projLen;
  },
  parse: (model, selCmpt, selDef) => {
    var _a;
    const selDef_ = duplicate(selDef);
    selDef_.select = isString2(selDef_.select) ? { type: selDef_.select, toggle: selCmpt.toggle } : Object.assign(Object.assign({}, selDef_.select), { toggle: selCmpt.toggle });
    disableDirectManipulation(selCmpt, selDef_);
    if (isObject(selDef.select) && (selDef.select.on || selDef.select.clear)) {
      const legendFilter = 'event.item && indexof(event.item.mark.role, "legend") < 0';
      for (const evt2 of selCmpt.events) {
        evt2.filter = array((_a = evt2.filter) !== null && _a !== void 0 ? _a : []);
        if (!evt2.filter.includes(legendFilter)) {
          evt2.filter.push(legendFilter);
        }
      }
    }
    const evt = isLegendStreamBinding(selCmpt.bind) ? selCmpt.bind.legend : "click";
    const stream = isString2(evt) ? eventSelector(evt, "view") : array(evt);
    selCmpt.bind = { legend: { merge: stream } };
  },
  topLevelSignals: (model, selCmpt, signals) => {
    const selName = selCmpt.name;
    const stream = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend;
    const markName = (name5) => (s) => {
      const ds = duplicate(s);
      ds.markname = name5;
      return ds;
    };
    for (const proj of selCmpt.project.items) {
      if (!proj.hasLegend)
        continue;
      const prefix = `${varName(proj.field)}_legend`;
      const sgName = `${selName}_${prefix}`;
      const hasSignal = signals.filter((s) => s.name === sgName);
      if (hasSignal.length === 0) {
        const events2 = stream.merge.map(markName(`${prefix}_symbols`)).concat(stream.merge.map(markName(`${prefix}_labels`))).concat(stream.merge.map(markName(`${prefix}_entries`)));
        signals.unshift(Object.assign(Object.assign({ name: sgName }, !selCmpt.init ? { value: null } : {}), { on: [
          { events: events2, update: "datum.value || item().items[0].items[0].datum.value", force: true },
          { events: stream.merge, update: `!event.item || !datum ? null : ${sgName}`, force: true }
        ] }));
      }
    }
    return signals;
  },
  signals: (model, selCmpt, signals) => {
    const name5 = selCmpt.name;
    const proj = selCmpt.project;
    const tuple = signals.find((s) => s.name === name5 + TUPLE);
    const fields = name5 + TUPLE_FIELDS;
    const values4 = proj.items.filter((p) => p.hasLegend).map((p) => varName(`${name5}_${varName(p.field)}_legend`));
    const valid = values4.map((v) => `${v} !== null`).join(" && ");
    const update = `${valid} ? {fields: ${fields}, values: [${values4.join(", ")}]} : null`;
    if (selCmpt.events && values4.length > 0) {
      tuple.on.push({
        events: values4.map((signal) => ({ signal })),
        update
      });
    } else if (values4.length > 0) {
      tuple.update = update;
      delete tuple.value;
      delete tuple.on;
    }
    const toggle2 = signals.find((s) => s.name === name5 + TOGGLE);
    const events2 = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend;
    if (toggle2) {
      if (!selCmpt.events)
        toggle2.on[0].events = events2;
      else
        toggle2.on.push(Object.assign(Object.assign({}, toggle2.on[0]), { events: events2 }));
    }
    return signals;
  }
};
var legends_default = legendBindings;
function parseInteractiveLegend(model, channel, legendCmpt) {
  var _a, _b, _c, _d;
  const field = (_a = model.fieldDef(channel)) === null || _a === void 0 ? void 0 : _a.field;
  for (const selCmpt of vals((_b = model.component.selection) !== null && _b !== void 0 ? _b : {})) {
    const proj = (_c = selCmpt.project.hasField[field]) !== null && _c !== void 0 ? _c : selCmpt.project.hasChannel[channel];
    if (proj && legendBindings.defined(selCmpt)) {
      const legendSelections = (_d = legendCmpt.get("selections")) !== null && _d !== void 0 ? _d : [];
      legendSelections.push(selCmpt.name);
      legendCmpt.set("selections", legendSelections, false);
      proj.hasLegend = true;
    }
  }
}

// node_modules/vega-lite/build/src/compile/selection/translate.js
var ANCHOR = "_translate_anchor";
var DELTA = "_translate_delta";
var translate = {
  defined: (selCmpt) => {
    return selCmpt.type === "interval" && selCmpt.translate;
  },
  signals: (model, selCmpt, signals) => {
    const name5 = selCmpt.name;
    const hasScales = scales_default.defined(selCmpt);
    const anchor = name5 + ANCHOR;
    const { x, y } = selCmpt.project.hasChannel;
    let events2 = eventSelector(selCmpt.translate, "scope");
    if (!hasScales) {
      events2 = events2.map((e2) => (e2.between[0].markname = name5 + BRUSH, e2));
    }
    signals.push({
      name: anchor,
      value: {},
      on: [
        {
          events: events2.map((e2) => e2.between[0]),
          update: "{x: x(unit), y: y(unit)" + (x !== void 0 ? `, extent_x: ${hasScales ? domain(model, X) : `slice(${x.signals.visual})`}` : "") + (y !== void 0 ? `, extent_y: ${hasScales ? domain(model, Y) : `slice(${y.signals.visual})`}` : "") + "}"
        }
      ]
    }, {
      name: name5 + DELTA,
      value: {},
      on: [
        {
          events: events2,
          update: `{x: ${anchor}.x - x(unit), y: ${anchor}.y - y(unit)}`
        }
      ]
    });
    if (x !== void 0) {
      onDelta(model, selCmpt, x, "width", signals);
    }
    if (y !== void 0) {
      onDelta(model, selCmpt, y, "height", signals);
    }
    return signals;
  }
};
var translate_default = translate;
function onDelta(model, selCmpt, proj, size, signals) {
  var _a, _b;
  const name5 = selCmpt.name;
  const anchor = name5 + ANCHOR;
  const delta = name5 + DELTA;
  const channel = proj.channel;
  const hasScales = scales_default.defined(selCmpt);
  const signal = signals.filter((s) => s.name === proj.signals[hasScales ? "data" : "visual"])[0];
  const sizeSg = model.getSizeSignalRef(size).signal;
  const scaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = scaleCmpt.get("type");
  const reversed = scaleCmpt.get("reverse");
  const sign = !hasScales ? "" : channel === X ? reversed ? "" : "-" : reversed ? "-" : "";
  const extent = `${anchor}.extent_${channel}`;
  const offset = `${sign}${delta}.${channel} / ${hasScales ? `${sizeSg}` : `span(${extent})`}`;
  const panFn = !hasScales ? "panLinear" : scaleType2 === "log" ? "panLog" : scaleType2 === "symlog" ? "panSymlog" : scaleType2 === "pow" ? "panPow" : "panLinear";
  const arg = !hasScales ? "" : scaleType2 === "pow" ? `, ${(_a = scaleCmpt.get("exponent")) !== null && _a !== void 0 ? _a : 1}` : scaleType2 === "symlog" ? `, ${(_b = scaleCmpt.get("constant")) !== null && _b !== void 0 ? _b : 1}` : "";
  const update = `${panFn}(${extent}, ${offset}${arg})`;
  signal.on.push({
    events: { signal: delta },
    update: hasScales ? update : `clampRange(${update}, 0, ${sizeSg})`
  });
}

// node_modules/vega-lite/build/src/compile/selection/zoom.js
var ANCHOR2 = "_zoom_anchor";
var DELTA2 = "_zoom_delta";
var zoom = {
  defined: (selCmpt) => {
    return selCmpt.type === "interval" && selCmpt.zoom;
  },
  signals: (model, selCmpt, signals) => {
    const name5 = selCmpt.name;
    const hasScales = scales_default.defined(selCmpt);
    const delta = name5 + DELTA2;
    const { x, y } = selCmpt.project.hasChannel;
    const sx = $(model.scaleName(X));
    const sy = $(model.scaleName(Y));
    let events2 = eventSelector(selCmpt.zoom, "scope");
    if (!hasScales) {
      events2 = events2.map((e2) => (e2.markname = name5 + BRUSH, e2));
    }
    signals.push({
      name: name5 + ANCHOR2,
      on: [
        {
          events: events2,
          update: !hasScales ? `{x: x(unit), y: y(unit)}` : "{" + [sx ? `x: invert(${sx}, x(unit))` : "", sy ? `y: invert(${sy}, y(unit))` : ""].filter((expr) => !!expr).join(", ") + "}"
        }
      ]
    }, {
      name: delta,
      on: [
        {
          events: events2,
          force: true,
          update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
        }
      ]
    });
    if (x !== void 0) {
      onDelta2(model, selCmpt, x, "width", signals);
    }
    if (y !== void 0) {
      onDelta2(model, selCmpt, y, "height", signals);
    }
    return signals;
  }
};
var zoom_default = zoom;
function onDelta2(model, selCmpt, proj, size, signals) {
  var _a, _b;
  const name5 = selCmpt.name;
  const channel = proj.channel;
  const hasScales = scales_default.defined(selCmpt);
  const signal = signals.filter((s) => s.name === proj.signals[hasScales ? "data" : "visual"])[0];
  const sizeSg = model.getSizeSignalRef(size).signal;
  const scaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = scaleCmpt.get("type");
  const base = hasScales ? domain(model, channel) : signal.name;
  const delta = name5 + DELTA2;
  const anchor = `${name5}${ANCHOR2}.${channel}`;
  const zoomFn = !hasScales ? "zoomLinear" : scaleType2 === "log" ? "zoomLog" : scaleType2 === "symlog" ? "zoomSymlog" : scaleType2 === "pow" ? "zoomPow" : "zoomLinear";
  const arg = !hasScales ? "" : scaleType2 === "pow" ? `, ${(_a = scaleCmpt.get("exponent")) !== null && _a !== void 0 ? _a : 1}` : scaleType2 === "symlog" ? `, ${(_b = scaleCmpt.get("constant")) !== null && _b !== void 0 ? _b : 1}` : "";
  const update = `${zoomFn}(${base}, ${anchor}, ${delta}${arg})`;
  signal.on.push({
    events: { signal: delta },
    update: hasScales ? update : `clampRange(${update}, 0, ${sizeSg})`
  });
}

// node_modules/vega-lite/build/src/compile/selection/index.js
var STORE = "_store";
var TUPLE = "_tuple";
var MODIFY = "_modify";
var VL_SELECTION_RESOLVE = "vlSelectionResolve";
var selectionCompilers = [
  point_default,
  interval_default,
  project_default,
  toggle_default,
  inputs_default,
  scales_default,
  legends_default,
  clear_default,
  translate_default,
  zoom_default,
  nearest_default
];
function getFacetModel(model) {
  let parent = model.parent;
  while (parent) {
    if (isFacetModel(parent))
      break;
    parent = parent.parent;
  }
  return parent;
}
function unitName(model, { escape: escape2 } = { escape: true }) {
  let name5 = escape2 ? $(model.name) : model.name;
  const facetModel = getFacetModel(model);
  if (facetModel) {
    const { facet } = facetModel;
    for (const channel of FACET_CHANNELS) {
      if (facet[channel]) {
        name5 += ` + '__facet_${channel}_' + (facet[${$(facetModel.vgField(channel))}])`;
      }
    }
  }
  return name5;
}
function requiresSelectionId(model) {
  var _a;
  return vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {}).reduce((identifier, selCmpt) => {
    return identifier || selCmpt.project.items.some((proj) => proj.field === SELECTION_ID);
  }, false);
}
function disableDirectManipulation(selCmpt, selDef) {
  if (isString(selDef.select) || !selDef.select.on)
    delete selCmpt.events;
  if (isString(selDef.select) || !selDef.select.clear)
    delete selCmpt.clear;
  if (isString(selDef.select) || !selDef.select.toggle)
    delete selCmpt.toggle;
}

// node_modules/vega-lite/node_modules/vega-expression/build/vega-expression.module.js
var RawCode = "RawCode";
var Literal = "Literal";
var Property = "Property";
var Identifier = "Identifier";
var ArrayExpression = "ArrayExpression";
var BinaryExpression = "BinaryExpression";
var CallExpression = "CallExpression";
var ConditionalExpression = "ConditionalExpression";
var LogicalExpression = "LogicalExpression";
var MemberExpression = "MemberExpression";
var ObjectExpression = "ObjectExpression";
var UnaryExpression = "UnaryExpression";
function ASTNode(type) {
  this.type = type;
}
ASTNode.prototype.visit = function(visitor) {
  let c, i, n;
  if (visitor(this))
    return 1;
  for (c = children(this), i = 0, n = c.length; i < n; ++i) {
    if (c[i].visit(visitor))
      return 1;
  }
};
function children(node) {
  switch (node.type) {
    case ArrayExpression:
      return node.elements;
    case BinaryExpression:
    case LogicalExpression:
      return [node.left, node.right];
    case CallExpression:
      return [node.callee].concat(node.arguments);
    case ConditionalExpression:
      return [node.test, node.consequent, node.alternate];
    case MemberExpression:
      return [node.object, node.property];
    case ObjectExpression:
      return node.properties;
    case Property:
      return [node.key, node.value];
    case UnaryExpression:
      return [node.argument];
    case Identifier:
    case Literal:
    case RawCode:
    default:
      return [];
  }
}
var TokenName;
var source;
var index;
var length;
var lookahead;
var TokenBooleanLiteral = 1;
var TokenEOF = 2;
var TokenIdentifier = 3;
var TokenKeyword = 4;
var TokenNullLiteral = 5;
var TokenNumericLiteral = 6;
var TokenPunctuator = 7;
var TokenStringLiteral = 8;
var TokenRegularExpression = 9;
TokenName = {};
TokenName[TokenBooleanLiteral] = "Boolean";
TokenName[TokenEOF] = "<end>";
TokenName[TokenIdentifier] = "Identifier";
TokenName[TokenKeyword] = "Keyword";
TokenName[TokenNullLiteral] = "Null";
TokenName[TokenNumericLiteral] = "Numeric";
TokenName[TokenPunctuator] = "Punctuator";
TokenName[TokenStringLiteral] = "String";
TokenName[TokenRegularExpression] = "RegularExpression";
var SyntaxArrayExpression = "ArrayExpression";
var SyntaxBinaryExpression = "BinaryExpression";
var SyntaxCallExpression = "CallExpression";
var SyntaxConditionalExpression = "ConditionalExpression";
var SyntaxIdentifier = "Identifier";
var SyntaxLiteral = "Literal";
var SyntaxLogicalExpression = "LogicalExpression";
var SyntaxMemberExpression = "MemberExpression";
var SyntaxObjectExpression = "ObjectExpression";
var SyntaxProperty = "Property";
var SyntaxUnaryExpression = "UnaryExpression";
var MessageUnexpectedToken = "Unexpected token %0";
var MessageUnexpectedNumber = "Unexpected number";
var MessageUnexpectedString = "Unexpected string";
var MessageUnexpectedIdentifier = "Unexpected identifier";
var MessageUnexpectedReserved = "Unexpected reserved word";
var MessageUnexpectedEOS = "Unexpected end of input";
var MessageInvalidRegExp = "Invalid regular expression";
var MessageUnterminatedRegExp = "Invalid regular expression: missing /";
var MessageStrictOctalLiteral = "Octal literals are not allowed in strict mode.";
var MessageStrictDuplicateProperty = "Duplicate data property in object literal not allowed in strict mode";
var ILLEGAL2 = "ILLEGAL";
var DISABLED = "Disabled.";
var RegexNonAsciiIdentifierStart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
var RegexNonAsciiIdentifierPart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
function assert(condition, message) {
  if (!condition) {
    throw new Error("ASSERT: " + message);
  }
}
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
function isHexDigit(ch) {
  return "0123456789abcdefABCDEF".indexOf(ch) >= 0;
}
function isOctalDigit(ch) {
  return "01234567".indexOf(ch) >= 0;
}
function isWhiteSpace(ch) {
  return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(ch) >= 0;
}
function isLineTerminator(ch) {
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
}
function isIdentifierStart(ch) {
  return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch === 92 || ch >= 128 && RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch));
}
function isIdentifierPart(ch) {
  return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 48 && ch <= 57 || ch === 92 || ch >= 128 && RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch));
}
var keywords = {
  "if": 1,
  "in": 1,
  "do": 1,
  "var": 1,
  "for": 1,
  "new": 1,
  "try": 1,
  "let": 1,
  "this": 1,
  "else": 1,
  "case": 1,
  "void": 1,
  "with": 1,
  "enum": 1,
  "while": 1,
  "break": 1,
  "catch": 1,
  "throw": 1,
  "const": 1,
  "yield": 1,
  "class": 1,
  "super": 1,
  "return": 1,
  "typeof": 1,
  "delete": 1,
  "switch": 1,
  "export": 1,
  "import": 1,
  "public": 1,
  "static": 1,
  "default": 1,
  "finally": 1,
  "extends": 1,
  "package": 1,
  "private": 1,
  "function": 1,
  "continue": 1,
  "debugger": 1,
  "interface": 1,
  "protected": 1,
  "instanceof": 1,
  "implements": 1
};
function skipComment() {
  while (index < length) {
    const ch = source.charCodeAt(index);
    if (isWhiteSpace(ch) || isLineTerminator(ch)) {
      ++index;
    } else {
      break;
    }
  }
}
function scanHexEscape(prefix) {
  var i, len, ch, code = 0;
  len = prefix === "u" ? 4 : 2;
  for (i = 0; i < len; ++i) {
    if (index < length && isHexDigit(source[index])) {
      ch = source[index++];
      code = code * 16 + "0123456789abcdef".indexOf(ch.toLowerCase());
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL2);
    }
  }
  return String.fromCharCode(code);
}
function scanUnicodeCodePointEscape() {
  var ch, code, cu1, cu2;
  ch = source[index];
  code = 0;
  if (ch === "}") {
    throwError({}, MessageUnexpectedToken, ILLEGAL2);
  }
  while (index < length) {
    ch = source[index++];
    if (!isHexDigit(ch)) {
      break;
    }
    code = code * 16 + "0123456789abcdef".indexOf(ch.toLowerCase());
  }
  if (code > 1114111 || ch !== "}") {
    throwError({}, MessageUnexpectedToken, ILLEGAL2);
  }
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  cu1 = (code - 65536 >> 10) + 55296;
  cu2 = (code - 65536 & 1023) + 56320;
  return String.fromCharCode(cu1, cu2);
}
function getEscapedIdentifier() {
  var ch, id;
  ch = source.charCodeAt(index++);
  id = String.fromCharCode(ch);
  if (ch === 92) {
    if (source.charCodeAt(index) !== 117) {
      throwError({}, MessageUnexpectedToken, ILLEGAL2);
    }
    ++index;
    ch = scanHexEscape("u");
    if (!ch || ch === "\\" || !isIdentifierStart(ch.charCodeAt(0))) {
      throwError({}, MessageUnexpectedToken, ILLEGAL2);
    }
    id = ch;
  }
  while (index < length) {
    ch = source.charCodeAt(index);
    if (!isIdentifierPart(ch)) {
      break;
    }
    ++index;
    id += String.fromCharCode(ch);
    if (ch === 92) {
      id = id.substr(0, id.length - 1);
      if (source.charCodeAt(index) !== 117) {
        throwError({}, MessageUnexpectedToken, ILLEGAL2);
      }
      ++index;
      ch = scanHexEscape("u");
      if (!ch || ch === "\\" || !isIdentifierPart(ch.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL2);
      }
      id += ch;
    }
  }
  return id;
}
function getIdentifier() {
  var start, ch;
  start = index++;
  while (index < length) {
    ch = source.charCodeAt(index);
    if (ch === 92) {
      index = start;
      return getEscapedIdentifier();
    }
    if (isIdentifierPart(ch)) {
      ++index;
    } else {
      break;
    }
  }
  return source.slice(start, index);
}
function scanIdentifier() {
  var start, id, type;
  start = index;
  id = source.charCodeAt(index) === 92 ? getEscapedIdentifier() : getIdentifier();
  if (id.length === 1) {
    type = TokenIdentifier;
  } else if (keywords.hasOwnProperty(id)) {
    type = TokenKeyword;
  } else if (id === "null") {
    type = TokenNullLiteral;
  } else if (id === "true" || id === "false") {
    type = TokenBooleanLiteral;
  } else {
    type = TokenIdentifier;
  }
  return {
    type,
    value: id,
    start,
    end: index
  };
}
function scanPunctuator() {
  var start = index, code = source.charCodeAt(index), code2, ch1 = source[index], ch2, ch3, ch4;
  switch (code) {
    case 46:
    case 40:
    case 41:
    case 59:
    case 44:
    case 123:
    case 125:
    case 91:
    case 93:
    case 58:
    case 63:
    case 126:
      ++index;
      return {
        type: TokenPunctuator,
        value: String.fromCharCode(code),
        start,
        end: index
      };
    default:
      code2 = source.charCodeAt(index + 1);
      if (code2 === 61) {
        switch (code) {
          case 43:
          case 45:
          case 47:
          case 60:
          case 62:
          case 94:
          case 124:
          case 37:
          case 38:
          case 42:
            index += 2;
            return {
              type: TokenPunctuator,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              start,
              end: index
            };
          case 33:
          case 61:
            index += 2;
            if (source.charCodeAt(index) === 61) {
              ++index;
            }
            return {
              type: TokenPunctuator,
              value: source.slice(start, index),
              start,
              end: index
            };
        }
      }
  }
  ch4 = source.substr(index, 4);
  if (ch4 === ">>>=") {
    index += 4;
    return {
      type: TokenPunctuator,
      value: ch4,
      start,
      end: index
    };
  }
  ch3 = ch4.substr(0, 3);
  if (ch3 === ">>>" || ch3 === "<<=" || ch3 === ">>=") {
    index += 3;
    return {
      type: TokenPunctuator,
      value: ch3,
      start,
      end: index
    };
  }
  ch2 = ch3.substr(0, 2);
  if (ch1 === ch2[1] && "+-<>&|".indexOf(ch1) >= 0 || ch2 === "=>") {
    index += 2;
    return {
      type: TokenPunctuator,
      value: ch2,
      start,
      end: index
    };
  }
  if (ch2 === "//") {
    throwError({}, MessageUnexpectedToken, ILLEGAL2);
  }
  if ("<>=!+-*%&|^/".indexOf(ch1) >= 0) {
    ++index;
    return {
      type: TokenPunctuator,
      value: ch1,
      start,
      end: index
    };
  }
  throwError({}, MessageUnexpectedToken, ILLEGAL2);
}
function scanHexLiteral(start) {
  let number = "";
  while (index < length) {
    if (!isHexDigit(source[index])) {
      break;
    }
    number += source[index++];
  }
  if (number.length === 0) {
    throwError({}, MessageUnexpectedToken, ILLEGAL2);
  }
  if (isIdentifierStart(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL2);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt("0x" + number, 16),
    start,
    end: index
  };
}
function scanOctalLiteral(start) {
  let number = "0" + source[index++];
  while (index < length) {
    if (!isOctalDigit(source[index])) {
      break;
    }
    number += source[index++];
  }
  if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL2);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt(number, 8),
    octal: true,
    start,
    end: index
  };
}
function scanNumericLiteral() {
  var number, start, ch;
  ch = source[index];
  assert(isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
  start = index;
  number = "";
  if (ch !== ".") {
    number = source[index++];
    ch = source[index];
    if (number === "0") {
      if (ch === "x" || ch === "X") {
        ++index;
        return scanHexLiteral(start);
      }
      if (isOctalDigit(ch)) {
        return scanOctalLiteral(start);
      }
      if (ch && isDecimalDigit(ch.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL2);
      }
    }
    while (isDecimalDigit(source.charCodeAt(index))) {
      number += source[index++];
    }
    ch = source[index];
  }
  if (ch === ".") {
    number += source[index++];
    while (isDecimalDigit(source.charCodeAt(index))) {
      number += source[index++];
    }
    ch = source[index];
  }
  if (ch === "e" || ch === "E") {
    number += source[index++];
    ch = source[index];
    if (ch === "+" || ch === "-") {
      number += source[index++];
    }
    if (isDecimalDigit(source.charCodeAt(index))) {
      while (isDecimalDigit(source.charCodeAt(index))) {
        number += source[index++];
      }
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL2);
    }
  }
  if (isIdentifierStart(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL2);
  }
  return {
    type: TokenNumericLiteral,
    value: parseFloat(number),
    start,
    end: index
  };
}
function scanStringLiteral() {
  var str = "", quote, start, ch, code, octal = false;
  quote = source[index];
  assert(quote === "'" || quote === '"', "String literal must starts with a quote");
  start = index;
  ++index;
  while (index < length) {
    ch = source[index++];
    if (ch === quote) {
      quote = "";
      break;
    } else if (ch === "\\") {
      ch = source[index++];
      if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
        switch (ch) {
          case "u":
          case "x":
            if (source[index] === "{") {
              ++index;
              str += scanUnicodeCodePointEscape();
            } else {
              str += scanHexEscape(ch);
            }
            break;
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            if (isOctalDigit(ch)) {
              code = "01234567".indexOf(ch);
              if (code !== 0) {
                octal = true;
              }
              if (index < length && isOctalDigit(source[index])) {
                octal = true;
                code = code * 8 + "01234567".indexOf(source[index++]);
                if ("0123".indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {
                  code = code * 8 + "01234567".indexOf(source[index++]);
                }
              }
              str += String.fromCharCode(code);
            } else {
              str += ch;
            }
            break;
        }
      } else {
        if (ch === "\r" && source[index] === "\n") {
          ++index;
        }
      }
    } else if (isLineTerminator(ch.charCodeAt(0))) {
      break;
    } else {
      str += ch;
    }
  }
  if (quote !== "") {
    throwError({}, MessageUnexpectedToken, ILLEGAL2);
  }
  return {
    type: TokenStringLiteral,
    value: str,
    octal,
    start,
    end: index
  };
}
function testRegExp(pattern, flags) {
  let tmp = pattern;
  if (flags.indexOf("u") >= 0) {
    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, ($0, $1) => {
      if (parseInt($1, 16) <= 1114111) {
        return "x";
      }
      throwError({}, MessageInvalidRegExp);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
  }
  try {
    new RegExp(tmp);
  } catch (e2) {
    throwError({}, MessageInvalidRegExp);
  }
  try {
    return new RegExp(pattern, flags);
  } catch (exception) {
    return null;
  }
}
function scanRegExpBody() {
  var ch, str, classMarker, terminated, body;
  ch = source[index];
  assert(ch === "/", "Regular expression literal must start with a slash");
  str = source[index++];
  classMarker = false;
  terminated = false;
  while (index < length) {
    ch = source[index++];
    str += ch;
    if (ch === "\\") {
      ch = source[index++];
      if (isLineTerminator(ch.charCodeAt(0))) {
        throwError({}, MessageUnterminatedRegExp);
      }
      str += ch;
    } else if (isLineTerminator(ch.charCodeAt(0))) {
      throwError({}, MessageUnterminatedRegExp);
    } else if (classMarker) {
      if (ch === "]") {
        classMarker = false;
      }
    } else {
      if (ch === "/") {
        terminated = true;
        break;
      } else if (ch === "[") {
        classMarker = true;
      }
    }
  }
  if (!terminated) {
    throwError({}, MessageUnterminatedRegExp);
  }
  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}
function scanRegExpFlags() {
  var ch, str, flags;
  str = "";
  flags = "";
  while (index < length) {
    ch = source[index];
    if (!isIdentifierPart(ch.charCodeAt(0))) {
      break;
    }
    ++index;
    if (ch === "\\" && index < length) {
      throwError({}, MessageUnexpectedToken, ILLEGAL2);
    } else {
      flags += ch;
      str += ch;
    }
  }
  if (flags.search(/[^gimuy]/g) >= 0) {
    throwError({}, MessageInvalidRegExp, flags);
  }
  return {
    value: flags,
    literal: str
  };
}
function scanRegExp() {
  var start, body, flags, value;
  lookahead = null;
  skipComment();
  start = index;
  body = scanRegExpBody();
  flags = scanRegExpFlags();
  value = testRegExp(body.value, flags.value);
  return {
    literal: body.literal + flags.literal,
    value,
    regex: {
      pattern: body.value,
      flags: flags.value
    },
    start,
    end: index
  };
}
function isIdentifierName(token) {
  return token.type === TokenIdentifier || token.type === TokenKeyword || token.type === TokenBooleanLiteral || token.type === TokenNullLiteral;
}
function advance() {
  skipComment();
  if (index >= length) {
    return {
      type: TokenEOF,
      start: index,
      end: index
    };
  }
  const ch = source.charCodeAt(index);
  if (isIdentifierStart(ch)) {
    return scanIdentifier();
  }
  if (ch === 40 || ch === 41 || ch === 59) {
    return scanPunctuator();
  }
  if (ch === 39 || ch === 34) {
    return scanStringLiteral();
  }
  if (ch === 46) {
    if (isDecimalDigit(source.charCodeAt(index + 1))) {
      return scanNumericLiteral();
    }
    return scanPunctuator();
  }
  if (isDecimalDigit(ch)) {
    return scanNumericLiteral();
  }
  return scanPunctuator();
}
function lex() {
  const token = lookahead;
  index = token.end;
  lookahead = advance();
  index = token.end;
  return token;
}
function peek() {
  const pos = index;
  lookahead = advance();
  index = pos;
}
function finishArrayExpression(elements) {
  const node = new ASTNode(SyntaxArrayExpression);
  node.elements = elements;
  return node;
}
function finishBinaryExpression(operator, left, right) {
  const node = new ASTNode(operator === "||" || operator === "&&" ? SyntaxLogicalExpression : SyntaxBinaryExpression);
  node.operator = operator;
  node.left = left;
  node.right = right;
  return node;
}
function finishCallExpression(callee, args) {
  const node = new ASTNode(SyntaxCallExpression);
  node.callee = callee;
  node.arguments = args;
  return node;
}
function finishConditionalExpression(test, consequent, alternate) {
  const node = new ASTNode(SyntaxConditionalExpression);
  node.test = test;
  node.consequent = consequent;
  node.alternate = alternate;
  return node;
}
function finishIdentifier(name5) {
  const node = new ASTNode(SyntaxIdentifier);
  node.name = name5;
  return node;
}
function finishLiteral(token) {
  const node = new ASTNode(SyntaxLiteral);
  node.value = token.value;
  node.raw = source.slice(token.start, token.end);
  if (token.regex) {
    if (node.raw === "//") {
      node.raw = "/(?:)/";
    }
    node.regex = token.regex;
  }
  return node;
}
function finishMemberExpression(accessor, object, property) {
  const node = new ASTNode(SyntaxMemberExpression);
  node.computed = accessor === "[";
  node.object = object;
  node.property = property;
  if (!node.computed)
    property.member = true;
  return node;
}
function finishObjectExpression(properties) {
  const node = new ASTNode(SyntaxObjectExpression);
  node.properties = properties;
  return node;
}
function finishProperty(kind, key, value) {
  const node = new ASTNode(SyntaxProperty);
  node.key = key;
  node.value = value;
  node.kind = kind;
  return node;
}
function finishUnaryExpression(operator, argument) {
  const node = new ASTNode(SyntaxUnaryExpression);
  node.operator = operator;
  node.argument = argument;
  node.prefix = true;
  return node;
}
function throwError(token, messageFormat) {
  var error2, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, (whole, index2) => {
    assert(index2 < args.length, "Message reference must be in range");
    return args[index2];
  });
  error2 = new Error(msg);
  error2.index = index;
  error2.description = msg;
  throw error2;
}
function throwUnexpected(token) {
  if (token.type === TokenEOF) {
    throwError(token, MessageUnexpectedEOS);
  }
  if (token.type === TokenNumericLiteral) {
    throwError(token, MessageUnexpectedNumber);
  }
  if (token.type === TokenStringLiteral) {
    throwError(token, MessageUnexpectedString);
  }
  if (token.type === TokenIdentifier) {
    throwError(token, MessageUnexpectedIdentifier);
  }
  if (token.type === TokenKeyword) {
    throwError(token, MessageUnexpectedReserved);
  }
  throwError(token, MessageUnexpectedToken, token.value);
}
function expect(value) {
  const token = lex();
  if (token.type !== TokenPunctuator || token.value !== value) {
    throwUnexpected(token);
  }
}
function match(value) {
  return lookahead.type === TokenPunctuator && lookahead.value === value;
}
function matchKeyword(keyword) {
  return lookahead.type === TokenKeyword && lookahead.value === keyword;
}
function parseArrayInitialiser() {
  const elements = [];
  index = lookahead.start;
  expect("[");
  while (!match("]")) {
    if (match(",")) {
      lex();
      elements.push(null);
    } else {
      elements.push(parseConditionalExpression());
      if (!match("]")) {
        expect(",");
      }
    }
  }
  lex();
  return finishArrayExpression(elements);
}
function parseObjectPropertyKey() {
  index = lookahead.start;
  const token = lex();
  if (token.type === TokenStringLiteral || token.type === TokenNumericLiteral) {
    if (token.octal) {
      throwError(token, MessageStrictOctalLiteral);
    }
    return finishLiteral(token);
  }
  return finishIdentifier(token.value);
}
function parseObjectProperty() {
  var token, key, id, value;
  index = lookahead.start;
  token = lookahead;
  if (token.type === TokenIdentifier) {
    id = parseObjectPropertyKey();
    expect(":");
    value = parseConditionalExpression();
    return finishProperty("init", id, value);
  }
  if (token.type === TokenEOF || token.type === TokenPunctuator) {
    throwUnexpected(token);
  } else {
    key = parseObjectPropertyKey();
    expect(":");
    value = parseConditionalExpression();
    return finishProperty("init", key, value);
  }
}
function parseObjectInitialiser() {
  var properties = [], property, name5, key, map = {}, toString = String;
  index = lookahead.start;
  expect("{");
  while (!match("}")) {
    property = parseObjectProperty();
    if (property.key.type === SyntaxIdentifier) {
      name5 = property.key.name;
    } else {
      name5 = toString(property.key.value);
    }
    key = "$" + name5;
    if (Object.prototype.hasOwnProperty.call(map, key)) {
      throwError({}, MessageStrictDuplicateProperty);
    } else {
      map[key] = true;
    }
    properties.push(property);
    if (!match("}")) {
      expect(",");
    }
  }
  expect("}");
  return finishObjectExpression(properties);
}
function parseGroupExpression() {
  expect("(");
  const expr = parseExpression();
  expect(")");
  return expr;
}
var legalKeywords = {
  "if": 1
};
function parsePrimaryExpression() {
  var type, token, expr;
  if (match("(")) {
    return parseGroupExpression();
  }
  if (match("[")) {
    return parseArrayInitialiser();
  }
  if (match("{")) {
    return parseObjectInitialiser();
  }
  type = lookahead.type;
  index = lookahead.start;
  if (type === TokenIdentifier || legalKeywords[lookahead.value]) {
    expr = finishIdentifier(lex().value);
  } else if (type === TokenStringLiteral || type === TokenNumericLiteral) {
    if (lookahead.octal) {
      throwError(lookahead, MessageStrictOctalLiteral);
    }
    expr = finishLiteral(lex());
  } else if (type === TokenKeyword) {
    throw new Error(DISABLED);
  } else if (type === TokenBooleanLiteral) {
    token = lex();
    token.value = token.value === "true";
    expr = finishLiteral(token);
  } else if (type === TokenNullLiteral) {
    token = lex();
    token.value = null;
    expr = finishLiteral(token);
  } else if (match("/") || match("/=")) {
    expr = finishLiteral(scanRegExp());
    peek();
  } else {
    throwUnexpected(lex());
  }
  return expr;
}
function parseArguments() {
  const args = [];
  expect("(");
  if (!match(")")) {
    while (index < length) {
      args.push(parseConditionalExpression());
      if (match(")")) {
        break;
      }
      expect(",");
    }
  }
  expect(")");
  return args;
}
function parseNonComputedProperty() {
  index = lookahead.start;
  const token = lex();
  if (!isIdentifierName(token)) {
    throwUnexpected(token);
  }
  return finishIdentifier(token.value);
}
function parseNonComputedMember() {
  expect(".");
  return parseNonComputedProperty();
}
function parseComputedMember() {
  expect("[");
  const expr = parseExpression();
  expect("]");
  return expr;
}
function parseLeftHandSideExpressionAllowCall() {
  var expr, args, property;
  expr = parsePrimaryExpression();
  for (; ; ) {
    if (match(".")) {
      property = parseNonComputedMember();
      expr = finishMemberExpression(".", expr, property);
    } else if (match("(")) {
      args = parseArguments();
      expr = finishCallExpression(expr, args);
    } else if (match("[")) {
      property = parseComputedMember();
      expr = finishMemberExpression("[", expr, property);
    } else {
      break;
    }
  }
  return expr;
}
function parsePostfixExpression() {
  const expr = parseLeftHandSideExpressionAllowCall();
  if (lookahead.type === TokenPunctuator) {
    if (match("++") || match("--")) {
      throw new Error(DISABLED);
    }
  }
  return expr;
}
function parseUnaryExpression() {
  var token, expr;
  if (lookahead.type !== TokenPunctuator && lookahead.type !== TokenKeyword) {
    expr = parsePostfixExpression();
  } else if (match("++") || match("--")) {
    throw new Error(DISABLED);
  } else if (match("+") || match("-") || match("~") || match("!")) {
    token = lex();
    expr = parseUnaryExpression();
    expr = finishUnaryExpression(token.value, expr);
  } else if (matchKeyword("delete") || matchKeyword("void") || matchKeyword("typeof")) {
    throw new Error(DISABLED);
  } else {
    expr = parsePostfixExpression();
  }
  return expr;
}
function binaryPrecedence(token) {
  let prec = 0;
  if (token.type !== TokenPunctuator && token.type !== TokenKeyword) {
    return 0;
  }
  switch (token.value) {
    case "||":
      prec = 1;
      break;
    case "&&":
      prec = 2;
      break;
    case "|":
      prec = 3;
      break;
    case "^":
      prec = 4;
      break;
    case "&":
      prec = 5;
      break;
    case "==":
    case "!=":
    case "===":
    case "!==":
      prec = 6;
      break;
    case "<":
    case ">":
    case "<=":
    case ">=":
    case "instanceof":
    case "in":
      prec = 7;
      break;
    case "<<":
    case ">>":
    case ">>>":
      prec = 8;
      break;
    case "+":
    case "-":
      prec = 9;
      break;
    case "*":
    case "/":
    case "%":
      prec = 11;
      break;
  }
  return prec;
}
function parseBinaryExpression() {
  var marker, markers, expr, token, prec, stack2, right, operator, left, i;
  marker = lookahead;
  left = parseUnaryExpression();
  token = lookahead;
  prec = binaryPrecedence(token);
  if (prec === 0) {
    return left;
  }
  token.prec = prec;
  lex();
  markers = [marker, lookahead];
  right = parseUnaryExpression();
  stack2 = [left, token, right];
  while ((prec = binaryPrecedence(lookahead)) > 0) {
    while (stack2.length > 2 && prec <= stack2[stack2.length - 2].prec) {
      right = stack2.pop();
      operator = stack2.pop().value;
      left = stack2.pop();
      markers.pop();
      expr = finishBinaryExpression(operator, left, right);
      stack2.push(expr);
    }
    token = lex();
    token.prec = prec;
    stack2.push(token);
    markers.push(lookahead);
    expr = parseUnaryExpression();
    stack2.push(expr);
  }
  i = stack2.length - 1;
  expr = stack2[i];
  markers.pop();
  while (i > 1) {
    markers.pop();
    expr = finishBinaryExpression(stack2[i - 1].value, stack2[i - 2], expr);
    i -= 2;
  }
  return expr;
}
function parseConditionalExpression() {
  var expr, consequent, alternate;
  expr = parseBinaryExpression();
  if (match("?")) {
    lex();
    consequent = parseConditionalExpression();
    expect(":");
    alternate = parseConditionalExpression();
    expr = finishConditionalExpression(expr, consequent, alternate);
  }
  return expr;
}
function parseExpression() {
  const expr = parseConditionalExpression();
  if (match(",")) {
    throw new Error(DISABLED);
  }
  return expr;
}
function parser(code) {
  source = code;
  index = 0;
  length = source.length;
  lookahead = null;
  peek();
  const expr = parseExpression();
  if (lookahead.type !== TokenEOF) {
    throw new Error("Unexpect token after expression.");
  }
  return expr;
}

// node_modules/vega-lite/build/src/compile/data/expressions.js
function getName(node) {
  const name5 = [];
  if (node.type === "Identifier") {
    return [node.name];
  }
  if (node.type === "Literal") {
    return [node.value];
  }
  if (node.type === "MemberExpression") {
    name5.push(...getName(node.object));
    name5.push(...getName(node.property));
  }
  return name5;
}
function startsWithDatum(node) {
  if (node.object.type === "MemberExpression") {
    return startsWithDatum(node.object);
  }
  return node.object.name === "datum";
}
function getDependentFields(expression3) {
  const ast = parser(expression3);
  const dependents = new Set();
  ast.visit((node) => {
    if (node.type === "MemberExpression" && startsWithDatum(node)) {
      dependents.add(getName(node).slice(1).join("."));
    }
  });
  return dependents;
}

// node_modules/vega-lite/build/src/compile/data/filter.js
var FilterNode = class extends DataFlowNode {
  constructor(parent, model, filter) {
    super(parent);
    this.model = model;
    this.filter = filter;
    this.expr = expression2(this.model, this.filter, this);
    this._dependentFields = getDependentFields(this.expr);
  }
  clone() {
    return new FilterNode(null, this.model, duplicate(this.filter));
  }
  dependentFields() {
    return this._dependentFields;
  }
  producedFields() {
    return new Set();
  }
  assemble() {
    return {
      type: "filter",
      expr: this.expr
    };
  }
  hash() {
    return `Filter ${this.expr}`;
  }
};

// node_modules/vega-lite/build/src/compile/selection/parse.js
function parseUnitSelection(model, selDefs) {
  var _a;
  const selCmpts = {};
  const selectionConfig = model.config.selection;
  if (!selDefs || !selDefs.length)
    return selCmpts;
  for (const def of selDefs) {
    const name5 = varName(def.name);
    const selDef = def.select;
    const type = isString2(selDef) ? selDef : selDef.type;
    const defaults = isObject2(selDef) ? duplicate(selDef) : { type };
    const cfg = selectionConfig[type];
    for (const key in cfg) {
      if (key === "fields" || key === "encodings") {
        continue;
      }
      if (key === "mark") {
        defaults[key] = Object.assign(Object.assign({}, cfg[key]), defaults[key]);
      }
      if (defaults[key] === void 0 || defaults[key] === true) {
        defaults[key] = (_a = cfg[key]) !== null && _a !== void 0 ? _a : defaults[key];
      }
    }
    const selCmpt = selCmpts[name5] = Object.assign(Object.assign({}, defaults), {
      name: name5,
      type,
      init: def.value,
      bind: def.bind,
      events: isString2(defaults.on) ? eventSelector(defaults.on, "scope") : array(duplicate(defaults.on))
    });
    for (const c of selectionCompilers) {
      if (c.defined(selCmpt) && c.parse) {
        c.parse(model, selCmpt, def);
      }
    }
  }
  return selCmpts;
}
function parseSelectionPredicate(model, pred, dfnode, datum = "datum") {
  const name5 = isString2(pred) ? pred : pred.param;
  const vname = varName(name5);
  const store = $(vname + STORE);
  let selCmpt;
  try {
    selCmpt = model.getSelectionComponent(vname, name5);
  } catch (e2) {
    return `!!${vname}`;
  }
  if (selCmpt.project.timeUnit) {
    const child = dfnode !== null && dfnode !== void 0 ? dfnode : model.component.data.raw;
    const tunode = selCmpt.project.timeUnit.clone();
    if (child.parent) {
      tunode.insertAsParentOf(child);
    } else {
      child.parent = tunode;
    }
  }
  const test = `vlSelectionTest(${store}, ${datum}${selCmpt.resolve === "global" ? ")" : `, ${$(selCmpt.resolve)})`}`;
  const length2 = `length(data(${store}))`;
  return pred.empty === false ? `${length2} && ${test}` : `!${length2} || ${test}`;
}
function parseSelectionExtent(model, name5, extent) {
  const vname = varName(name5);
  const encoding = extent["encoding"];
  let field = extent["field"];
  let selCmpt;
  try {
    selCmpt = model.getSelectionComponent(vname, name5);
  } catch (e2) {
    return vname;
  }
  if (!encoding && !field) {
    field = selCmpt.project.items[0].field;
    if (selCmpt.project.items.length > 1) {
      warn(`A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${$(field)}.`);
    }
  } else if (encoding && !field) {
    const encodings = selCmpt.project.items.filter((p) => p.channel === encoding);
    if (!encodings.length || encodings.length > 1) {
      field = selCmpt.project.items[0].field;
      warn((!encodings.length ? "No " : "Multiple ") + `matching ${$(encoding)} encoding found for selection ${$(extent.param)}. Using "field": ${$(field)}.`);
    } else {
      field = encodings[0].field;
    }
  }
  return `${selCmpt.name}[${$(replacePathInField(field))}]`;
}
function materializeSelections(model, main5) {
  var _a;
  for (const [selection, selCmpt] of entries((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {
    const lookupName = model.getName(`lookup_${selection}`);
    model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(new FilterNode(main5, model, { param: selection }), lookupName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);
  }
}

// node_modules/vega-lite/build/src/compile/predicate.js
function expression2(model, filterOp, node) {
  return logicalExpr(filterOp, (predicate) => {
    if (isString2(predicate)) {
      return predicate;
    } else if (isSelectionPredicate(predicate)) {
      return parseSelectionPredicate(model, predicate, node);
    } else {
      return fieldFilterExpression(predicate);
    }
  });
}

// node_modules/vega-lite/build/src/compile/axis/assemble.js
var __rest20 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function assembleTitle(title2, config) {
  if (!title2) {
    return void 0;
  }
  if (isArray2(title2) && !isText(title2)) {
    return title2.map((fieldDef) => defaultTitle(fieldDef, config)).join(", ");
  }
  return title2;
}
function setAxisEncode(axis, part, vgProp, vgRef) {
  var _a, _b, _c;
  var _d, _e;
  (_a = axis.encode) !== null && _a !== void 0 ? _a : axis.encode = {};
  (_b = (_d = axis.encode)[part]) !== null && _b !== void 0 ? _b : _d[part] = {};
  (_c = (_e = axis.encode[part]).update) !== null && _c !== void 0 ? _c : _e.update = {};
  axis.encode[part].update[vgProp] = vgRef;
}
function assembleAxis(axisCmpt, kind, config, opt = { header: false }) {
  var _a, _b;
  const _c = axisCmpt.combine(), { disable, orient: orient2, scale, labelExpr, title: title2, zindex: zindex2 } = _c, axis = __rest20(_c, ["disable", "orient", "scale", "labelExpr", "title", "zindex"]);
  if (disable) {
    return void 0;
  }
  for (const prop in axis) {
    const propType = AXIS_PROPERTY_TYPE[prop];
    const propValue = axis[prop];
    if (propType && propType !== kind && propType !== "both") {
      delete axis[prop];
    } else if (isConditionalAxisValue(propValue)) {
      const { condition } = propValue, valueOrSignalRef = __rest20(propValue, ["condition"]);
      const conditions = array(condition);
      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];
      if (propIndex) {
        const { vgProp, part } = propIndex;
        const vgRef = [
          ...conditions.map((c) => {
            const { test } = c, valueOrSignalCRef = __rest20(c, ["test"]);
            return Object.assign({ test: expression2(null, test) }, valueOrSignalCRef);
          }),
          valueOrSignalRef
        ];
        setAxisEncode(axis, part, vgProp, vgRef);
        delete axis[prop];
      } else if (propIndex === null) {
        const signalRef = {
          signal: conditions.map((c) => {
            const { test } = c, valueOrSignalCRef = __rest20(c, ["test"]);
            return `${expression2(null, test)} ? ${exprFromValueOrSignalRef(valueOrSignalCRef)} : `;
          }).join("") + exprFromValueOrSignalRef(valueOrSignalRef)
        };
        axis[prop] = signalRef;
      }
    } else if (isSignalRef(propValue)) {
      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];
      if (propIndex) {
        const { vgProp, part } = propIndex;
        setAxisEncode(axis, part, vgProp, propValue);
        delete axis[prop];
      }
    }
    if (contains(["labelAlign", "labelBaseline"], prop) && axis[prop] === null) {
      delete axis[prop];
    }
  }
  if (kind === "grid") {
    if (!axis.grid) {
      return void 0;
    }
    if (axis.encode) {
      const { grid } = axis.encode;
      axis.encode = Object.assign({}, grid ? { grid } : {});
      if (isEmpty(axis.encode)) {
        delete axis.encode;
      }
    }
    return Object.assign(Object.assign({
      scale,
      orient: orient2
    }, axis), {
      domain: false,
      labels: false,
      aria: false,
      maxExtent: 0,
      minExtent: 0,
      ticks: false,
      zindex: getFirstDefined(zindex2, 0)
    });
  } else {
    if (!opt.header && axisCmpt.mainExtracted) {
      return void 0;
    }
    if (labelExpr !== void 0) {
      let expr = labelExpr;
      if (((_b = (_a = axis.encode) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b.update) && isSignalRef(axis.encode.labels.update.text)) {
        expr = replaceAll(labelExpr, "datum.label", axis.encode.labels.update.text.signal);
      }
      setAxisEncode(axis, "labels", "text", { signal: expr });
    }
    if (axis.labelAlign === null) {
      delete axis.labelAlign;
    }
    if (axis.encode) {
      for (const part of AXIS_PARTS) {
        if (!axisCmpt.hasAxisPart(part)) {
          delete axis.encode[part];
        }
      }
      if (isEmpty(axis.encode)) {
        delete axis.encode;
      }
    }
    const titleString = assembleTitle(title2, config);
    return Object.assign(Object.assign(Object.assign(Object.assign({
      scale,
      orient: orient2,
      grid: false
    }, titleString ? { title: titleString } : {}), axis), config.aria === false ? { aria: false } : {}), {
      zindex: getFirstDefined(zindex2, 0)
    });
  }
}
function assembleAxisSignals(model) {
  const { axes } = model.component;
  const signals = [];
  for (const channel of POSITION_SCALE_CHANNELS) {
    if (axes[channel]) {
      for (const axis of axes[channel]) {
        if (!axis.get("disable") && !axis.get("gridScale")) {
          const sizeType = channel === "x" ? "height" : "width";
          const update = model.getSizeSignalRef(sizeType).signal;
          if (sizeType !== update) {
            signals.push({
              name: sizeType,
              update
            });
          }
        }
      }
    }
  }
  return signals;
}
function assembleAxes(axisComponents, config) {
  const { x = [], y = [] } = axisComponents;
  return [
    ...x.map((a) => assembleAxis(a, "grid", config)),
    ...y.map((a) => assembleAxis(a, "grid", config)),
    ...x.map((a) => assembleAxis(a, "main", config)),
    ...y.map((a) => assembleAxis(a, "main", config))
  ].filter((a) => a);
}

// node_modules/vega-lite/build/src/compile/axis/config.js
function getAxisConfigFromConfigTypes(configTypes, config, channel, orient2) {
  return Object.assign.apply(null, [
    {},
    ...configTypes.map((configType) => {
      if (configType === "axisOrient") {
        const orient1 = channel === "x" ? "bottom" : "left";
        const orientConfig1 = config[channel === "x" ? "axisBottom" : "axisLeft"] || {};
        const orientConfig2 = config[channel === "x" ? "axisTop" : "axisRight"] || {};
        const props = new Set([...keys(orientConfig1), ...keys(orientConfig2)]);
        const conditionalOrientAxisConfig = {};
        for (const prop of props.values()) {
          conditionalOrientAxisConfig[prop] = {
            signal: `${orient2["signal"]} === "${orient1}" ? ${signalOrStringValue(orientConfig1[prop])} : ${signalOrStringValue(orientConfig2[prop])}`
          };
        }
        return conditionalOrientAxisConfig;
      }
      return config[configType];
    })
  ]);
}
function getAxisConfigs(channel, scaleType2, orient2, config) {
  const typeBasedConfigTypes = scaleType2 === "band" ? ["axisDiscrete", "axisBand"] : scaleType2 === "point" ? ["axisDiscrete", "axisPoint"] : isQuantitative(scaleType2) ? ["axisQuantitative"] : scaleType2 === "time" || scaleType2 === "utc" ? ["axisTemporal"] : [];
  const axisChannel = channel === "x" ? "axisX" : "axisY";
  const axisOrient = isSignalRef(orient2) ? "axisOrient" : `axis${titleCase(orient2)}`;
  const vlOnlyConfigTypes = [
    ...typeBasedConfigTypes,
    ...typeBasedConfigTypes.map((c) => axisChannel + c.substr(4))
  ];
  const vgConfigTypes = ["axis", axisOrient, axisChannel];
  return {
    vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config, channel, orient2),
    vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config, channel, orient2),
    axisConfigStyle: getAxisConfigStyle([...vgConfigTypes, ...vlOnlyConfigTypes], config)
  };
}
function getAxisConfigStyle(axisConfigTypes, config) {
  var _a;
  const toMerge = [{}];
  for (const configType of axisConfigTypes) {
    let style = (_a = config[configType]) === null || _a === void 0 ? void 0 : _a.style;
    if (style) {
      style = array(style);
      for (const s of style) {
        toMerge.push(config.style[s]);
      }
    }
  }
  return Object.assign.apply(null, toMerge);
}
function getAxisConfig(property, styleConfigIndex, style, axisConfigs = {}) {
  var _a;
  const styleConfig = getStyleConfig(property, style, styleConfigIndex);
  if (styleConfig !== void 0) {
    return {
      configFrom: "style",
      configValue: styleConfig
    };
  }
  for (const configFrom of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"]) {
    if (((_a = axisConfigs[configFrom]) === null || _a === void 0 ? void 0 : _a[property]) !== void 0) {
      return { configFrom, configValue: axisConfigs[configFrom][property] };
    }
  }
  return {};
}

// node_modules/vega-lite/build/src/compile/axis/properties.js
var axisRules = {
  scale: ({ model, channel }) => model.scaleName(channel),
  format: ({ fieldOrDatumDef, config, axis }) => {
    const { format, formatType } = axis;
    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, true);
  },
  formatType: ({ axis, fieldOrDatumDef, scaleType: scaleType2 }) => {
    const { formatType } = axis;
    return guideFormatType(formatType, fieldOrDatumDef, scaleType2);
  },
  grid: ({ fieldOrDatumDef, axis, scaleType: scaleType2 }) => {
    var _a;
    return (_a = axis.grid) !== null && _a !== void 0 ? _a : defaultGrid(scaleType2, fieldOrDatumDef);
  },
  gridScale: ({ model, channel }) => gridScale(model, channel),
  labelAlign: ({ axis, labelAngle, orient: orient2, channel }) => axis.labelAlign || defaultLabelAlign(labelAngle, orient2, channel),
  labelAngle: ({ labelAngle }) => labelAngle,
  labelBaseline: ({ axis, labelAngle, orient: orient2, channel }) => axis.labelBaseline || defaultLabelBaseline(labelAngle, orient2, channel),
  labelFlush: ({ axis, fieldOrDatumDef, channel }) => {
    var _a;
    return (_a = axis.labelFlush) !== null && _a !== void 0 ? _a : defaultLabelFlush(fieldOrDatumDef.type, channel);
  },
  labelOverlap: ({ axis, fieldOrDatumDef, scaleType: scaleType2 }) => {
    var _a;
    return (_a = axis.labelOverlap) !== null && _a !== void 0 ? _a : defaultLabelOverlap(fieldOrDatumDef.type, scaleType2, isFieldDef(fieldOrDatumDef) && !!fieldOrDatumDef.timeUnit, isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : void 0);
  },
  orient: ({ orient: orient2 }) => orient2,
  tickCount: ({ channel, model, axis, fieldOrDatumDef, scaleType: scaleType2 }) => {
    var _a;
    const sizeType = channel === "x" ? "width" : channel === "y" ? "height" : void 0;
    const size = sizeType ? model.getSizeSignalRef(sizeType) : void 0;
    return (_a = axis.tickCount) !== null && _a !== void 0 ? _a : defaultTickCount({ fieldOrDatumDef, scaleType: scaleType2, size, values: axis.values });
  },
  title: ({ axis, model, channel }) => {
    if (axis.title !== void 0) {
      return axis.title;
    }
    const fieldDefTitle = getFieldDefTitle(model, channel);
    if (fieldDefTitle !== void 0) {
      return fieldDefTitle;
    }
    const fieldDef = model.typedFieldDef(channel);
    const channel2 = channel === "x" ? "x2" : "y2";
    const fieldDef2 = model.fieldDef(channel2);
    return mergeTitleFieldDefs(fieldDef ? [toFieldDefBase(fieldDef)] : [], isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []);
  },
  values: ({ axis, fieldOrDatumDef }) => values(axis, fieldOrDatumDef),
  zindex: ({ axis, fieldOrDatumDef, mark: mark3 }) => {
    var _a;
    return (_a = axis.zindex) !== null && _a !== void 0 ? _a : defaultZindex(mark3, fieldOrDatumDef);
  }
};
function defaultGrid(scaleType2, fieldDef) {
  return !hasDiscreteDomain(scaleType2) && isFieldDef(fieldDef) && !isBinning(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) && !isBinned(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin);
}
function gridScale(model, channel) {
  const gridChannel = channel === "x" ? "y" : "x";
  if (model.getScaleComponent(gridChannel)) {
    return model.scaleName(gridChannel);
  }
  return void 0;
}
function getLabelAngle(fieldOrDatumDef, axis, channel, styleConfig, axisConfigs) {
  const labelAngle = axis === null || axis === void 0 ? void 0 : axis.labelAngle;
  if (labelAngle !== void 0) {
    return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);
  } else {
    const { configValue: angle } = getAxisConfig("labelAngle", styleConfig, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs);
    if (angle !== void 0) {
      return normalizeAngle(angle);
    } else {
      if (channel === X && contains([NOMINAL, ORDINAL], fieldOrDatumDef.type) && !(isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit)) {
        return 270;
      }
      return void 0;
    }
  }
}
function normalizeAngleExpr(angle) {
  return `(((${angle.signal} % 360) + 360) % 360)`;
}
function defaultLabelBaseline(angle, orient2, channel, alwaysIncludeMiddle) {
  if (angle !== void 0) {
    if (channel === "x") {
      if (isSignalRef(angle)) {
        const a = normalizeAngleExpr(angle);
        const orientIsTop = isSignalRef(orient2) ? `(${orient2.signal} === "top")` : orient2 === "top";
        return {
          signal: `(45 < ${a} && ${a} < 135) || (225 < ${a} && ${a} < 315) ? "middle" :(${a} <= 45 || 315 <= ${a}) === ${orientIsTop} ? "bottom" : "top"`
        };
      }
      if (45 < angle && angle < 135 || 225 < angle && angle < 315) {
        return "middle";
      }
      if (isSignalRef(orient2)) {
        const op = angle <= 45 || 315 <= angle ? "===" : "!==";
        return { signal: `${orient2.signal} ${op} "top" ? "bottom" : "top"` };
      }
      return (angle <= 45 || 315 <= angle) === (orient2 === "top") ? "bottom" : "top";
    } else {
      if (isSignalRef(angle)) {
        const a = normalizeAngleExpr(angle);
        const orientIsLeft = isSignalRef(orient2) ? `(${orient2.signal} === "left")` : orient2 === "left";
        const middle = alwaysIncludeMiddle ? '"middle"' : "null";
        return {
          signal: `${a} <= 45 || 315 <= ${a} || (135 <= ${a} && ${a} <= 225) ? ${middle} : (45 <= ${a} && ${a} <= 135) === ${orientIsLeft} ? "top" : "bottom"`
        };
      }
      if (angle <= 45 || 315 <= angle || 135 <= angle && angle <= 225) {
        return alwaysIncludeMiddle ? "middle" : null;
      }
      if (isSignalRef(orient2)) {
        const op = 45 <= angle && angle <= 135 ? "===" : "!==";
        return { signal: `${orient2.signal} ${op} "left" ? "top" : "bottom"` };
      }
      return (45 <= angle && angle <= 135) === (orient2 === "left") ? "top" : "bottom";
    }
  }
  return void 0;
}
function defaultLabelAlign(angle, orient2, channel) {
  if (angle === void 0) {
    return void 0;
  }
  const isX2 = channel === "x";
  const startAngle = isX2 ? 0 : 90;
  const mainOrient = isX2 ? "bottom" : "left";
  if (isSignalRef(angle)) {
    const a = normalizeAngleExpr(angle);
    const orientIsMain = isSignalRef(orient2) ? `(${orient2.signal} === "${mainOrient}")` : orient2 === mainOrient;
    return {
      signal: `(${startAngle ? `(${a} + 90)` : a} % 180 === 0) ? ${isX2 ? null : '"center"'} :(${startAngle} < ${a} && ${a} < ${180 + startAngle}) === ${orientIsMain} ? "left" : "right"`
    };
  }
  if ((angle + startAngle) % 180 === 0) {
    return isX2 ? null : "center";
  }
  if (isSignalRef(orient2)) {
    const op = startAngle < angle && angle < 180 + startAngle ? "===" : "!==";
    const orientIsMain = `${orient2.signal} ${op} "${mainOrient}"`;
    return {
      signal: `${orientIsMain} ? "left" : "right"`
    };
  }
  if ((startAngle < angle && angle < 180 + startAngle) === (orient2 === mainOrient)) {
    return "left";
  }
  return "right";
}
function defaultLabelFlush(type, channel) {
  if (channel === "x" && contains(["quantitative", "temporal"], type)) {
    return true;
  }
  return void 0;
}
function defaultLabelOverlap(type, scaleType2, hasTimeUnit, sort) {
  if (hasTimeUnit && !isObject2(sort) || type !== "nominal" && type !== "ordinal") {
    if (scaleType2 === "log" || scaleType2 === "symlog") {
      return "greedy";
    }
    return true;
  }
  return void 0;
}
function defaultOrient(channel) {
  return channel === "x" ? "bottom" : "left";
}
function defaultTickCount({ fieldOrDatumDef, scaleType: scaleType2, size, values: vals2 }) {
  var _a;
  if (!vals2 && !hasDiscreteDomain(scaleType2) && scaleType2 !== "log") {
    if (isFieldDef(fieldOrDatumDef)) {
      if (isBinning(fieldOrDatumDef.bin)) {
        return { signal: `ceil(${size.signal}/10)` };
      }
      if (fieldOrDatumDef.timeUnit && contains(["month", "hours", "day", "quarter"], (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit)) {
        return void 0;
      }
    }
    return { signal: `ceil(${size.signal}/40)` };
  }
  return void 0;
}
function getFieldDefTitle(model, channel) {
  const channel2 = channel === "x" ? "x2" : "y2";
  const fieldDef = model.fieldDef(channel);
  const fieldDef2 = model.fieldDef(channel2);
  const title1 = fieldDef ? fieldDef.title : void 0;
  const title2 = fieldDef2 ? fieldDef2.title : void 0;
  if (title1 && title2) {
    return mergeTitle(title1, title2);
  } else if (title1) {
    return title1;
  } else if (title2) {
    return title2;
  } else if (title1 !== void 0) {
    return title1;
  } else if (title2 !== void 0) {
    return title2;
  }
  return void 0;
}
function values(axis, fieldOrDatumDef) {
  const vals2 = axis.values;
  if (isArray2(vals2)) {
    return valueArray(fieldOrDatumDef, vals2);
  } else if (isSignalRef(vals2)) {
    return vals2;
  }
  return void 0;
}
function defaultZindex(mark3, fieldDef) {
  if (mark3 === "rect" && isDiscrete(fieldDef)) {
    return 1;
  }
  return 0;
}

// node_modules/vega-lite/build/src/compile/data/calculate.js
var CalculateNode = class extends DataFlowNode {
  constructor(parent, transform) {
    super(parent);
    this.transform = transform;
    this._dependentFields = getDependentFields(this.transform.calculate);
  }
  clone() {
    return new CalculateNode(null, duplicate(this.transform));
  }
  static parseAllForSortIndex(parent, model) {
    model.forEachFieldDef((fieldDef, channel) => {
      if (!isScaleFieldDef(fieldDef)) {
        return;
      }
      if (isSortArray(fieldDef.sort)) {
        const { field, timeUnit } = fieldDef;
        const sort = fieldDef.sort;
        const calculate = sort.map((sortValue, i) => {
          return `${fieldFilterExpression({ field, timeUnit, equal: sortValue })} ? ${i} : `;
        }).join("") + sort.length;
        parent = new CalculateNode(parent, {
          calculate,
          as: sortArrayIndexField(fieldDef, channel, { forAs: true })
        });
      }
    });
    return parent;
  }
  producedFields() {
    return new Set([this.transform.as]);
  }
  dependentFields() {
    return this._dependentFields;
  }
  assemble() {
    return {
      type: "formula",
      expr: this.transform.calculate,
      as: this.transform.as
    };
  }
  hash() {
    return `Calculate ${hash(this.transform)}`;
  }
};
function sortArrayIndexField(fieldDef, channel, opt) {
  return vgField(fieldDef, Object.assign({ prefix: channel, suffix: "sort_index" }, opt !== null && opt !== void 0 ? opt : {}));
}

// node_modules/vega-lite/build/src/compile/header/common.js
function getHeaderChannel(channel, orient2) {
  if (contains(["top", "bottom"], orient2)) {
    return "column";
  } else if (contains(["left", "right"], orient2)) {
    return "row";
  }
  return channel === "row" ? "row" : "column";
}
function getHeaderProperty(prop, header, config, channel) {
  const headerSpecificConfig = channel === "row" ? config.headerRow : channel === "column" ? config.headerColumn : config.headerFacet;
  return getFirstDefined((header || {})[prop], headerSpecificConfig[prop], config.header[prop]);
}
function getHeaderProperties(properties, header, config, channel) {
  const props = {};
  for (const prop of properties) {
    const value = getHeaderProperty(prop, header || {}, config, channel);
    if (value !== void 0) {
      props[prop] = value;
    }
  }
  return props;
}

// node_modules/vega-lite/build/src/compile/header/component.js
var HEADER_CHANNELS = ["row", "column"];
var HEADER_TYPES = ["header", "footer"];

// node_modules/vega-lite/build/src/compile/header/assemble.js
function assembleTitleGroup(model, channel) {
  const title2 = model.component.layoutHeaders[channel].title;
  const config = model.config ? model.config : void 0;
  const facetFieldDef = model.component.layoutHeaders[channel].facetFieldDef ? model.component.layoutHeaders[channel].facetFieldDef : void 0;
  const { titleAnchor, titleAngle: ta, titleOrient } = getHeaderProperties(["titleAnchor", "titleAngle", "titleOrient"], facetFieldDef.header, config, channel);
  const headerChannel = getHeaderChannel(channel, titleOrient);
  const titleAngle = normalizeAngle(ta);
  return {
    name: `${channel}-title`,
    type: "group",
    role: `${headerChannel}-title`,
    title: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ text: title2 }, channel === "row" ? { orient: "left" } : {}), { style: "guide-title" }), defaultHeaderGuideBaseline(titleAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, titleAngle, titleAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP))
  };
}
function defaultHeaderGuideAlign(headerChannel, angle, anchor = "middle") {
  switch (anchor) {
    case "start":
      return { align: "left" };
    case "end":
      return { align: "right" };
  }
  const align2 = defaultLabelAlign(angle, headerChannel === "row" ? "left" : "top", headerChannel === "row" ? "y" : "x");
  return align2 ? { align: align2 } : {};
}
function defaultHeaderGuideBaseline(angle, channel) {
  const baseline2 = defaultLabelBaseline(angle, channel === "row" ? "left" : "top", channel === "row" ? "y" : "x", true);
  return baseline2 ? { baseline: baseline2 } : {};
}
function assembleHeaderGroups(model, channel) {
  const layoutHeader = model.component.layoutHeaders[channel];
  const groups = [];
  for (const headerType of HEADER_TYPES) {
    if (layoutHeader[headerType]) {
      for (const headerComponent of layoutHeader[headerType]) {
        const group = assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent);
        if (group != null) {
          groups.push(group);
        }
      }
    }
  }
  return groups;
}
function getSort(facetFieldDef, channel) {
  var _a;
  const { sort } = facetFieldDef;
  if (isSortField(sort)) {
    return {
      field: vgField(sort, { expr: "datum" }),
      order: (_a = sort.order) !== null && _a !== void 0 ? _a : "ascending"
    };
  } else if (isArray2(sort)) {
    return {
      field: sortArrayIndexField(facetFieldDef, channel, { expr: "datum" }),
      order: "ascending"
    };
  } else {
    return {
      field: vgField(facetFieldDef, { expr: "datum" }),
      order: sort !== null && sort !== void 0 ? sort : "ascending"
    };
  }
}
function assembleLabelTitle(facetFieldDef, channel, config) {
  const { format, formatType, labelAngle, labelAnchor, labelOrient, labelExpr } = getHeaderProperties(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], facetFieldDef.header, config, channel);
  const titleTextExpr = formatSignalRef({
    fieldOrDatumDef: facetFieldDef,
    format,
    formatType,
    expr: "parent",
    config
  }).signal;
  const headerChannel = getHeaderChannel(channel, labelOrient);
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ text: {
    signal: labelExpr ? replaceAll(replaceAll(labelExpr, "datum.label", titleTextExpr), "datum.value", vgField(facetFieldDef, { expr: "parent" })) : titleTextExpr
  } }, channel === "row" ? { orient: "left" } : {}), { style: "guide-label", frame: "group" }), defaultHeaderGuideBaseline(labelAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, labelAngle, labelAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP));
}
function assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent) {
  if (headerComponent) {
    let title2 = null;
    const { facetFieldDef } = layoutHeader;
    const config = model.config ? model.config : void 0;
    if (facetFieldDef && headerComponent.labels) {
      const { labelOrient } = getHeaderProperties(["labelOrient"], facetFieldDef.header, config, channel);
      if (channel === "row" && !contains(["top", "bottom"], labelOrient) || channel === "column" && !contains(["left", "right"], labelOrient)) {
        title2 = assembleLabelTitle(facetFieldDef, channel, config);
      }
    }
    const isFacetWithoutRowCol = isFacetModel(model) && !isFacetMapping(model.facet);
    const axes = headerComponent.axes;
    const hasAxes = (axes === null || axes === void 0 ? void 0 : axes.length) > 0;
    if (title2 || hasAxes) {
      const sizeChannel = channel === "row" ? "height" : "width";
      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: model.getName(`${channel}_${headerType}`), type: "group", role: `${channel}-${headerType}` }, layoutHeader.facetFieldDef ? {
        from: { data: model.getName(`${channel}_domain`) },
        sort: getSort(facetFieldDef, channel)
      } : {}), hasAxes && isFacetWithoutRowCol ? {
        from: { data: model.getName(`facet_domain_${channel}`) }
      } : {}), title2 ? { title: title2 } : {}), headerComponent.sizeSignal ? {
        encode: {
          update: {
            [sizeChannel]: headerComponent.sizeSignal
          }
        }
      } : {}), hasAxes ? { axes } : {});
    }
  }
  return null;
}
var LAYOUT_TITLE_BAND = {
  column: {
    start: 0,
    end: 1
  },
  row: {
    start: 1,
    end: 0
  }
};
function getLayoutTitleBand(titleAnchor, headerChannel) {
  return LAYOUT_TITLE_BAND[headerChannel][titleAnchor];
}
function assembleLayoutTitleBand(headerComponentIndex, config) {
  const titleBand = {};
  for (const channel of FACET_CHANNELS) {
    const headerComponent = headerComponentIndex[channel];
    if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent.facetFieldDef) {
      const { titleAnchor, titleOrient } = getHeaderProperties(["titleAnchor", "titleOrient"], headerComponent.facetFieldDef.header, config, channel);
      const headerChannel = getHeaderChannel(channel, titleOrient);
      const band = getLayoutTitleBand(titleAnchor, headerChannel);
      if (band !== void 0) {
        titleBand[headerChannel] = band;
      }
    }
  }
  return isEmpty(titleBand) ? void 0 : titleBand;
}
function assembleHeaderProperties(config, facetFieldDef, channel, properties, propertiesMap) {
  const props = {};
  for (const prop of properties) {
    if (!propertiesMap[prop]) {
      continue;
    }
    const value = getHeaderProperty(prop, facetFieldDef === null || facetFieldDef === void 0 ? void 0 : facetFieldDef.header, config, channel);
    if (value !== void 0) {
      props[propertiesMap[prop]] = value;
    }
  }
  return props;
}

// node_modules/vega-lite/build/src/compile/layoutsize/assemble.js
function assembleLayoutSignals(model) {
  return [
    ...sizeSignals(model, "width"),
    ...sizeSignals(model, "height"),
    ...sizeSignals(model, "childWidth"),
    ...sizeSignals(model, "childHeight")
  ];
}
function sizeSignals(model, sizeType) {
  const channel = sizeType === "width" ? "x" : "y";
  const size = model.component.layoutSize.get(sizeType);
  if (!size || size === "merged") {
    return [];
  }
  const name5 = model.getSizeSignalRef(sizeType).signal;
  if (size === "step") {
    const scaleComponent = model.getScaleComponent(channel);
    if (scaleComponent) {
      const type = scaleComponent.get("type");
      const range2 = scaleComponent.get("range");
      if (hasDiscreteDomain(type) && isVgRangeStep(range2)) {
        const scaleName = model.scaleName(channel);
        if (isFacetModel(model.parent)) {
          const parentResolve = model.parent.component.resolve;
          if (parentResolve.scale[channel] === "independent") {
            return [stepSignal(scaleName, range2)];
          }
        }
        return [
          stepSignal(scaleName, range2),
          {
            name: name5,
            update: sizeExpr(scaleName, scaleComponent, `domain('${scaleName}').length`)
          }
        ];
      }
    }
    throw new Error("layout size is step although width/height is not step.");
  } else if (size == "container") {
    const isWidth = name5.endsWith("width");
    const expr = isWidth ? "containerSize()[0]" : "containerSize()[1]";
    const defaultValue = getViewConfigContinuousSize(model.config.view, isWidth ? "width" : "height");
    const safeExpr = `isFinite(${expr}) ? ${expr} : ${defaultValue}`;
    return [{ name: name5, init: safeExpr, on: [{ update: safeExpr, events: "window:resize" }] }];
  } else {
    return [
      {
        name: name5,
        value: size
      }
    ];
  }
}
function stepSignal(scaleName, range2) {
  return {
    name: `${scaleName}_step`,
    value: range2.step
  };
}
function sizeExpr(scaleName, scaleComponent, cardinality) {
  const type = scaleComponent.get("type");
  const padding2 = scaleComponent.get("padding");
  const paddingOuter2 = getFirstDefined(scaleComponent.get("paddingOuter"), padding2);
  let paddingInner2 = scaleComponent.get("paddingInner");
  paddingInner2 = type === "band" ? paddingInner2 !== void 0 ? paddingInner2 : padding2 : 1;
  return `bandspace(${cardinality}, ${signalOrStringValue(paddingInner2)}, ${signalOrStringValue(paddingOuter2)}) * ${scaleName}_step`;
}

// node_modules/vega-lite/build/src/compile/layoutsize/component.js
function getSizeTypeFromLayoutSizeType(layoutSizeType) {
  return layoutSizeType === "childWidth" ? "width" : layoutSizeType === "childHeight" ? "height" : layoutSizeType;
}

// node_modules/vega-lite/build/src/compile/guide.js
function guideEncodeEntry(encoding, model) {
  return keys(encoding).reduce((encode13, channel) => {
    const valueDef = encoding[channel];
    return Object.assign(Object.assign({}, encode13), wrapCondition(model, valueDef, channel, (def) => signalOrValueRef(def.value)));
  }, {});
}

// node_modules/vega-lite/build/src/compile/resolve.js
function defaultScaleResolve(channel, model) {
  if (isFacetModel(model)) {
    return channel === "theta" ? "independent" : "shared";
  } else if (isLayerModel(model)) {
    return "shared";
  } else if (isConcatModel(model)) {
    return isXorY(channel) || channel === "theta" || channel === "radius" ? "independent" : "shared";
  }
  throw new Error("invalid model type for resolve");
}
function parseGuideResolve(resolve, channel) {
  const channelScaleResolve = resolve.scale[channel];
  const guide = isXorY(channel) ? "axis" : "legend";
  if (channelScaleResolve === "independent") {
    if (resolve[guide][channel] === "shared") {
      warn(message_exports.independentScaleMeansIndependentGuide(channel));
    }
    return "independent";
  }
  return resolve[guide][channel] || "shared";
}

// node_modules/vega-lite/build/src/compile/legend/component.js
var LEGEND_COMPONENT_PROPERTY_INDEX = Object.assign(Object.assign({}, COMMON_LEGEND_PROPERTY_INDEX), {
  disable: 1,
  labelExpr: 1,
  selections: 1,
  opacity: 1,
  shape: 1,
  stroke: 1,
  fill: 1,
  size: 1,
  strokeWidth: 1,
  strokeDash: 1,
  encode: 1
});
var LEGEND_COMPONENT_PROPERTIES = keys(LEGEND_COMPONENT_PROPERTY_INDEX);
var LegendComponent = class extends Split {
};

// node_modules/vega-lite/build/src/compile/legend/encode.js
var legendEncodeRules = {
  symbols,
  gradient,
  labels,
  entries: entries2
};
function symbols(symbolsSpec, { fieldOrDatumDef, model, channel, legendCmpt, legendType }) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  if (legendType !== "symbol") {
    return void 0;
  }
  const { markDef, encoding, config, mark: mark3 } = model;
  const filled = markDef.filled && mark3 !== "trail";
  let out = Object.assign(Object.assign({}, applyMarkConfig({}, model, FILL_STROKE_CONFIG)), color(model, { filled }));
  const symbolOpacity = (_a = legendCmpt.get("symbolOpacity")) !== null && _a !== void 0 ? _a : config.legend.symbolOpacity;
  const symbolFillColor = (_b = legendCmpt.get("symbolFillColor")) !== null && _b !== void 0 ? _b : config.legend.symbolFillColor;
  const symbolStrokeColor = (_c = legendCmpt.get("symbolStrokeColor")) !== null && _c !== void 0 ? _c : config.legend.symbolStrokeColor;
  const opacity2 = symbolOpacity === void 0 ? (_d = getMaxValue(encoding.opacity)) !== null && _d !== void 0 ? _d : markDef.opacity : void 0;
  if (out.fill) {
    if (channel === "fill" || filled && channel === COLOR) {
      delete out.fill;
    } else {
      if (out.fill["field"]) {
        if (symbolFillColor) {
          delete out.fill;
        } else {
          out.fill = signalOrValueRef((_e = config.legend.symbolBaseFillColor) !== null && _e !== void 0 ? _e : "black");
          out.fillOpacity = signalOrValueRef(opacity2 !== null && opacity2 !== void 0 ? opacity2 : 1);
        }
      } else if (isArray2(out.fill)) {
        const fill = (_h = (_g = getFirstConditionValue((_f = encoding.fill) !== null && _f !== void 0 ? _f : encoding.color)) !== null && _g !== void 0 ? _g : markDef.fill) !== null && _h !== void 0 ? _h : filled && markDef.color;
        if (fill) {
          out.fill = signalOrValueRef(fill);
        }
      }
    }
  }
  if (out.stroke) {
    if (channel === "stroke" || !filled && channel === COLOR) {
      delete out.stroke;
    } else {
      if (out.stroke["field"] || symbolStrokeColor) {
        delete out.stroke;
      } else if (isArray2(out.stroke)) {
        const stroke = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled ? markDef.color : void 0);
        if (stroke) {
          out.stroke = { value: stroke };
        }
      }
    }
  }
  if (channel !== OPACITY) {
    const condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);
    if (condition) {
      out.opacity = [
        Object.assign({ test: condition }, signalOrValueRef(opacity2 !== null && opacity2 !== void 0 ? opacity2 : 1)),
        signalOrValueRef(config.legend.unselectedOpacity)
      ];
    } else if (opacity2) {
      out.opacity = signalOrValueRef(opacity2);
    }
  }
  out = Object.assign(Object.assign({}, out), symbolsSpec);
  return isEmpty(out) ? void 0 : out;
}
function gradient(gradientSpec, { model, legendType, legendCmpt }) {
  var _a;
  if (legendType !== "gradient") {
    return void 0;
  }
  const { config, markDef, encoding } = model;
  let out = {};
  const gradientOpacity = (_a = legendCmpt.get("gradientOpacity")) !== null && _a !== void 0 ? _a : config.legend.gradientOpacity;
  const opacity2 = gradientOpacity === void 0 ? getMaxValue(encoding.opacity) || markDef.opacity : void 0;
  if (opacity2) {
    out.opacity = signalOrValueRef(opacity2);
  }
  out = Object.assign(Object.assign({}, out), gradientSpec);
  return isEmpty(out) ? void 0 : out;
}
function labels(specifiedlabelsSpec, { fieldOrDatumDef, model, channel, legendCmpt }) {
  const legend = model.legend(channel) || {};
  const config = model.config;
  const condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : void 0;
  const opacity2 = condition ? [{ test: condition, value: 1 }, { value: config.legend.unselectedOpacity }] : void 0;
  const { format, formatType } = legend;
  const text3 = isCustomFormatType(formatType) ? formatCustomType({
    fieldOrDatumDef,
    field: "datum.value",
    format,
    formatType,
    config
  }) : void 0;
  const labelsSpec = Object.assign(Object.assign(Object.assign({}, opacity2 ? { opacity: opacity2 } : {}), text3 ? { text: text3 } : {}), specifiedlabelsSpec);
  return isEmpty(labelsSpec) ? void 0 : labelsSpec;
}
function entries2(entriesSpec, { legendCmpt }) {
  const selections = legendCmpt.get("selections");
  return (selections === null || selections === void 0 ? void 0 : selections.length) ? Object.assign(Object.assign({}, entriesSpec), { fill: { value: "transparent" } }) : entriesSpec;
}
function getMaxValue(channelDef) {
  return getConditionValue(channelDef, (v, conditionalDef) => Math.max(v, conditionalDef.value));
}
function getFirstConditionValue(channelDef) {
  return getConditionValue(channelDef, (v, conditionalDef) => {
    return getFirstDefined(v, conditionalDef.value);
  });
}
function getConditionValue(channelDef, reducer) {
  if (hasConditionalValueDef(channelDef)) {
    return array(channelDef.condition).reduce(reducer, channelDef.value);
  } else if (isValueDef(channelDef)) {
    return channelDef.value;
  }
  return void 0;
}
function selectedCondition(model, legendCmpt, fieldDef) {
  const selections = legendCmpt.get("selections");
  if (!(selections === null || selections === void 0 ? void 0 : selections.length))
    return void 0;
  const field = $(fieldDef.field);
  return selections.map((name5) => {
    const store = $(varName(name5) + STORE);
    return `(!length(data(${store})) || (${name5}[${field}] && indexof(${name5}[${field}], datum.value) >= 0))`;
  }).join(" || ");
}

// node_modules/vega-lite/build/src/compile/legend/properties.js
var legendRules = {
  direction: ({ direction }) => direction,
  format: ({ fieldOrDatumDef, legend, config }) => {
    const { format, formatType } = legend;
    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, false);
  },
  formatType: ({ legend, fieldOrDatumDef, scaleType: scaleType2 }) => {
    const { formatType } = legend;
    return guideFormatType(formatType, fieldOrDatumDef, scaleType2);
  },
  gradientLength: (params) => {
    var _a, _b;
    const { legend, legendConfig } = params;
    return (_b = (_a = legend.gradientLength) !== null && _a !== void 0 ? _a : legendConfig.gradientLength) !== null && _b !== void 0 ? _b : defaultGradientLength(params);
  },
  labelOverlap: ({ legend, legendConfig, scaleType: scaleType2 }) => {
    var _a, _b;
    return (_b = (_a = legend.labelOverlap) !== null && _a !== void 0 ? _a : legendConfig.labelOverlap) !== null && _b !== void 0 ? _b : defaultLabelOverlap2(scaleType2);
  },
  symbolType: ({ legend, markDef, channel, encoding }) => {
    var _a;
    return (_a = legend.symbolType) !== null && _a !== void 0 ? _a : defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape);
  },
  title: ({ fieldOrDatumDef, config }) => title(fieldOrDatumDef, config, { allowDisabling: true }),
  type: ({ legendType, scaleType: scaleType2, channel }) => {
    if (isColorChannel(channel) && isContinuousToContinuous(scaleType2)) {
      if (legendType === "gradient") {
        return void 0;
      }
    } else if (legendType === "symbol") {
      return void 0;
    }
    return legendType;
  },
  values: ({ fieldOrDatumDef, legend }) => values2(legend, fieldOrDatumDef)
};
function values2(legend, fieldOrDatumDef) {
  const vals2 = legend.values;
  if (isArray2(vals2)) {
    return valueArray(fieldOrDatumDef, vals2);
  } else if (isSignalRef(vals2)) {
    return vals2;
  }
  return void 0;
}
function defaultSymbolType(mark3, channel, shapeChannelDef, markShape) {
  var _a;
  if (channel !== "shape") {
    const shape = (_a = getFirstConditionValue(shapeChannelDef)) !== null && _a !== void 0 ? _a : markShape;
    if (shape) {
      return shape;
    }
  }
  switch (mark3) {
    case "bar":
    case "rect":
    case "image":
    case "square":
      return "square";
    case "line":
    case "trail":
    case "rule":
      return "stroke";
    case "arc":
    case "point":
    case "circle":
    case "tick":
    case "geoshape":
    case "area":
    case "text":
      return "circle";
  }
}
function getLegendType(params) {
  const { legend } = params;
  return getFirstDefined(legend.type, defaultType2(params));
}
function defaultType2({ channel, timeUnit, scaleType: scaleType2 }) {
  if (isColorChannel(channel)) {
    if (contains(["quarter", "month", "day"], timeUnit)) {
      return "symbol";
    }
    if (isContinuousToContinuous(scaleType2)) {
      return "gradient";
    }
  }
  return "symbol";
}
function getDirection({ legendConfig, legendType, orient: orient2, legend }) {
  var _a, _b;
  return (_b = (_a = legend.direction) !== null && _a !== void 0 ? _a : legendConfig[legendType ? "gradientDirection" : "symbolDirection"]) !== null && _b !== void 0 ? _b : defaultDirection(orient2, legendType);
}
function defaultDirection(orient2, legendType) {
  switch (orient2) {
    case "top":
    case "bottom":
      return "horizontal";
    case "left":
    case "right":
    case "none":
    case void 0:
      return void 0;
    default:
      return legendType === "gradient" ? "horizontal" : void 0;
  }
}
function defaultGradientLength({ legendConfig, model, direction, orient: orient2, scaleType: scaleType2 }) {
  const { gradientHorizontalMaxLength, gradientHorizontalMinLength, gradientVerticalMaxLength, gradientVerticalMinLength } = legendConfig;
  if (isContinuousToContinuous(scaleType2)) {
    if (direction === "horizontal") {
      if (orient2 === "top" || orient2 === "bottom") {
        return gradientLengthSignal(model, "width", gradientHorizontalMinLength, gradientHorizontalMaxLength);
      } else {
        return gradientHorizontalMinLength;
      }
    } else {
      return gradientLengthSignal(model, "height", gradientVerticalMinLength, gradientVerticalMaxLength);
    }
  }
  return void 0;
}
function gradientLengthSignal(model, sizeType, min, max) {
  const sizeSignal = model.getSizeSignalRef(sizeType).signal;
  return { signal: `clamp(${sizeSignal}, ${min}, ${max})` };
}
function defaultLabelOverlap2(scaleType2) {
  if (contains(["quantile", "threshold", "log", "symlog"], scaleType2)) {
    return "greedy";
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/legend/parse.js
function parseLegend(model) {
  const legendComponent = isUnitModel(model) ? parseUnitLegend(model) : parseNonUnitLegend(model);
  model.component.legends = legendComponent;
  return legendComponent;
}
function parseUnitLegend(model) {
  const { encoding } = model;
  const legendComponent = {};
  for (const channel of [COLOR, ...LEGEND_SCALE_CHANNELS]) {
    const def = getFieldOrDatumDef(encoding[channel]);
    if (!def || !model.getScaleComponent(channel)) {
      continue;
    }
    if (channel === SHAPE && isFieldDef(def) && def.type === GEOJSON) {
      continue;
    }
    legendComponent[channel] = parseLegendForChannel(model, channel);
  }
  return legendComponent;
}
function getLegendDefWithScale(model, channel) {
  const scale = model.scaleName(channel);
  if (model.mark === "trail") {
    if (channel === "color") {
      return { stroke: scale };
    } else if (channel === "size") {
      return { strokeWidth: scale };
    }
  }
  if (channel === "color") {
    return model.markDef.filled ? { fill: scale } : { stroke: scale };
  }
  return { [channel]: scale };
}
function isExplicit(value, property, legend, fieldDef) {
  switch (property) {
    case "disable":
      return legend !== void 0;
    case "values":
      return !!(legend === null || legend === void 0 ? void 0 : legend.values);
    case "title":
      if (property === "title" && value === (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.title)) {
        return true;
      }
  }
  return value === (legend || {})[property];
}
function parseLegendForChannel(model, channel) {
  var _a, _b, _c;
  let legend = model.legend(channel);
  const { markDef, encoding, config } = model;
  const legendConfig = config.legend;
  const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));
  parseInteractiveLegend(model, channel, legendCmpt);
  const disable = legend !== void 0 ? !legend : legendConfig.disable;
  legendCmpt.set("disable", disable, legend !== void 0);
  if (disable) {
    return legendCmpt;
  }
  legend = legend || {};
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
  const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : void 0;
  const orient2 = legend.orient || config.legend.orient || "right";
  const legendType = getLegendType({ legend, channel, timeUnit, scaleType: scaleType2 });
  const direction = getDirection({ legend, legendType, orient: orient2, legendConfig });
  const ruleParams = {
    legend,
    channel,
    model,
    markDef,
    encoding,
    fieldOrDatumDef,
    legendConfig,
    config,
    scaleType: scaleType2,
    orient: orient2,
    legendType,
    direction
  };
  for (const property of LEGEND_COMPONENT_PROPERTIES) {
    if (legendType === "gradient" && property.startsWith("symbol") || legendType === "symbol" && property.startsWith("gradient")) {
      continue;
    }
    const value = property in legendRules ? legendRules[property](ruleParams) : legend[property];
    if (value !== void 0) {
      const explicit = isExplicit(value, property, legend, model.fieldDef(channel));
      if (explicit || config.legend[property] === void 0) {
        legendCmpt.set(property, value, explicit);
      }
    }
  }
  const legendEncoding = (_b = legend === null || legend === void 0 ? void 0 : legend.encoding) !== null && _b !== void 0 ? _b : {};
  const selections = legendCmpt.get("selections");
  const legendEncode = {};
  const legendEncodeParams = { fieldOrDatumDef, model, channel, legendCmpt, legendType };
  for (const part of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {
    const legendEncodingPart = guideEncodeEntry((_c = legendEncoding[part]) !== null && _c !== void 0 ? _c : {}, model);
    const value = part in legendEncodeRules ? legendEncodeRules[part](legendEncodingPart, legendEncodeParams) : legendEncodingPart;
    if (value !== void 0 && !isEmpty(value)) {
      legendEncode[part] = Object.assign(Object.assign(Object.assign({}, (selections === null || selections === void 0 ? void 0 : selections.length) && isFieldDef(fieldOrDatumDef) ? { name: `${varName(fieldOrDatumDef.field)}_legend_${part}` } : {}), (selections === null || selections === void 0 ? void 0 : selections.length) ? { interactive: !!selections } : {}), { update: value });
    }
  }
  if (!isEmpty(legendEncode)) {
    legendCmpt.set("encode", legendEncode, !!(legend === null || legend === void 0 ? void 0 : legend.encoding));
  }
  return legendCmpt;
}
function parseNonUnitLegend(model) {
  const { legends, resolve } = model.component;
  for (const child of model.children) {
    parseLegend(child);
    for (const channel of keys(child.component.legends)) {
      resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);
      if (resolve.legend[channel] === "shared") {
        legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);
        if (!legends[channel]) {
          resolve.legend[channel] = "independent";
          delete legends[channel];
        }
      }
    }
  }
  for (const channel of keys(legends)) {
    for (const child of model.children) {
      if (!child.component.legends[channel]) {
        continue;
      }
      if (resolve.legend[channel] === "shared") {
        delete child.component.legends[channel];
      }
    }
  }
  return legends;
}
function mergeLegendComponent(mergedLegend, childLegend) {
  var _a, _b, _c, _d;
  if (!mergedLegend) {
    return childLegend.clone();
  }
  const mergedOrient = mergedLegend.getWithExplicit("orient");
  const childOrient = childLegend.getWithExplicit("orient");
  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {
    return void 0;
  }
  let typeMerged = false;
  for (const prop of LEGEND_COMPONENT_PROPERTIES) {
    const mergedValueWithExplicit = mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop), childLegend.getWithExplicit(prop), prop, "legend", (v1, v2) => {
      switch (prop) {
        case "symbolType":
          return mergeSymbolType(v1, v2);
        case "title":
          return mergeTitleComponent(v1, v2);
        case "type":
          typeMerged = true;
          return makeImplicit("symbol");
      }
      return defaultTieBreaker(v1, v2, prop, "legend");
    });
    mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);
  }
  if (typeMerged) {
    if ((_b = (_a = mergedLegend.implicit) === null || _a === void 0 ? void 0 : _a.encode) === null || _b === void 0 ? void 0 : _b.gradient) {
      deleteNestedProperty(mergedLegend.implicit, ["encode", "gradient"]);
    }
    if ((_d = (_c = mergedLegend.explicit) === null || _c === void 0 ? void 0 : _c.encode) === null || _d === void 0 ? void 0 : _d.gradient) {
      deleteNestedProperty(mergedLegend.explicit, ["encode", "gradient"]);
    }
  }
  return mergedLegend;
}
function mergeSymbolType(st1, st2) {
  if (st2.value === "circle") {
    return st2;
  }
  return st1;
}

// node_modules/vega-lite/build/src/compile/legend/assemble.js
var __rest21 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function setLegendEncode(legend, part, vgProp, vgRef) {
  var _a, _b, _c;
  var _d, _e;
  (_a = legend.encode) !== null && _a !== void 0 ? _a : legend.encode = {};
  (_b = (_d = legend.encode)[part]) !== null && _b !== void 0 ? _b : _d[part] = {};
  (_c = (_e = legend.encode[part]).update) !== null && _c !== void 0 ? _c : _e.update = {};
  legend.encode[part].update[vgProp] = vgRef;
}
function assembleLegends(model) {
  const legendComponentIndex = model.component.legends;
  const legendByDomain = {};
  for (const channel of keys(legendComponentIndex)) {
    const scaleComponent = model.getScaleComponent(channel);
    const domainHash = stringify(scaleComponent.get("domains"));
    if (legendByDomain[domainHash]) {
      for (const mergedLegendComponent of legendByDomain[domainHash]) {
        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);
        if (!merged) {
          legendByDomain[domainHash].push(legendComponentIndex[channel]);
        }
      }
    } else {
      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];
    }
  }
  const legends = vals(legendByDomain).flat().map((l) => assembleLegend(l, model.config)).filter((l) => l !== void 0);
  return legends;
}
function assembleLegend(legendCmpt, config) {
  var _a, _b, _c;
  const _d = legendCmpt.combine(), { disable, labelExpr, selections } = _d, legend = __rest21(_d, ["disable", "labelExpr", "selections"]);
  if (disable) {
    return void 0;
  }
  if (config.aria === false && legend.aria == void 0) {
    legend.aria = false;
  }
  if ((_a = legend.encode) === null || _a === void 0 ? void 0 : _a.symbols) {
    const out = legend.encode.symbols.update;
    if (out.fill && out.fill["value"] !== "transparent" && !out.stroke && !legend.stroke) {
      out.stroke = { value: "transparent" };
    }
    for (const property of LEGEND_SCALE_CHANNELS) {
      if (legend[property]) {
        delete out[property];
      }
    }
  }
  if (!legend.title) {
    delete legend.title;
  }
  if (labelExpr !== void 0) {
    let expr = labelExpr;
    if (((_c = (_b = legend.encode) === null || _b === void 0 ? void 0 : _b.labels) === null || _c === void 0 ? void 0 : _c.update) && isSignalRef(legend.encode.labels.update.text)) {
      expr = replaceAll(labelExpr, "datum.label", legend.encode.labels.update.text.signal);
    }
    setLegendEncode(legend, "labels", "text", { signal: expr });
  }
  return legend;
}

// node_modules/vega-lite/build/src/compile/projection/assemble.js
function assembleProjections(model) {
  if (isLayerModel(model) || isConcatModel(model)) {
    return assembleProjectionsForModelAndChildren(model);
  } else {
    return assembleProjectionForModel(model);
  }
}
function assembleProjectionsForModelAndChildren(model) {
  return model.children.reduce((projections, child) => {
    return projections.concat(child.assembleProjections());
  }, assembleProjectionForModel(model));
}
function assembleProjectionForModel(model) {
  const component = model.component.projection;
  if (!component || component.merged) {
    return [];
  }
  const projection = component.combine();
  const { name: name5 } = projection;
  if (!component.data) {
    return [
      Object.assign(Object.assign({ name: name5 }, { translate: { signal: "[width / 2, height / 2]" } }), projection)
    ];
  } else {
    const size = {
      signal: `[${component.size.map((ref5) => ref5.signal).join(", ")}]`
    };
    const fits = component.data.reduce((sources, data) => {
      const source2 = isSignalRef(data) ? data.signal : `data('${model.lookupDataSource(data)}')`;
      if (!contains(sources, source2)) {
        sources.push(source2);
      }
      return sources;
    }, []);
    if (fits.length <= 0) {
      throw new Error("Projection's fit didn't find any data sources");
    }
    return [
      Object.assign({
        name: name5,
        size,
        fit: {
          signal: fits.length > 1 ? `[${fits.join(", ")}]` : fits[0]
        }
      }, projection)
    ];
  }
}

// node_modules/vega-lite/build/src/projection.js
var PROJECTION_PROPERTIES = [
  "type",
  "clipAngle",
  "clipExtent",
  "center",
  "rotate",
  "precision",
  "reflectX",
  "reflectY",
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];

// node_modules/vega-lite/build/src/compile/projection/component.js
var ProjectionComponent = class extends Split {
  constructor(name5, specifiedProjection, size, data) {
    super(Object.assign({}, specifiedProjection), { name: name5 });
    this.specifiedProjection = specifiedProjection;
    this.size = size;
    this.data = data;
    this.merged = false;
  }
  get isFit() {
    return !!this.data;
  }
};

// node_modules/vega-lite/build/src/compile/projection/parse.js
function parseProjection(model) {
  model.component.projection = isUnitModel(model) ? parseUnitProjection(model) : parseNonUnitProjections(model);
}
function parseUnitProjection(model) {
  var _a;
  if (model.hasProjection) {
    const proj = replaceExprRef(model.specifiedProjection);
    const fit = !(proj && (proj.scale != null || proj.translate != null));
    const size = fit ? [model.getSizeSignalRef("width"), model.getSizeSignalRef("height")] : void 0;
    const data = fit ? gatherFitData(model) : void 0;
    const projComp = new ProjectionComponent(model.projectionName(true), Object.assign(Object.assign({}, (_a = replaceExprRef(model.config.projection)) !== null && _a !== void 0 ? _a : {}), proj !== null && proj !== void 0 ? proj : {}), size, data);
    if (!projComp.get("type")) {
      projComp.set("type", "equalEarth", false);
    }
    return projComp;
  }
  return void 0;
}
function gatherFitData(model) {
  const data = [];
  const { encoding } = model;
  for (const posssiblePair of [
    [LONGITUDE, LATITUDE],
    [LONGITUDE2, LATITUDE2]
  ]) {
    if (getFieldOrDatumDef(encoding[posssiblePair[0]]) || getFieldOrDatumDef(encoding[posssiblePair[1]])) {
      data.push({
        signal: model.getName(`geojson_${data.length}`)
      });
    }
  }
  if (model.channelHasField(SHAPE) && model.typedFieldDef(SHAPE).type === GEOJSON) {
    data.push({
      signal: model.getName(`geojson_${data.length}`)
    });
  }
  if (data.length === 0) {
    data.push(model.requestDataName(DataSourceType.Main));
  }
  return data;
}
function mergeIfNoConflict(first, second) {
  const allPropertiesShared = every(PROJECTION_PROPERTIES, (prop) => {
    if (!has(first.explicit, prop) && !has(second.explicit, prop)) {
      return true;
    }
    if (has(first.explicit, prop) && has(second.explicit, prop) && deepEqual(first.get(prop), second.get(prop))) {
      return true;
    }
    return false;
  });
  const size = deepEqual(first.size, second.size);
  if (size) {
    if (allPropertiesShared) {
      return first;
    } else if (deepEqual(first.explicit, {})) {
      return second;
    } else if (deepEqual(second.explicit, {})) {
      return first;
    }
  }
  return null;
}
function parseNonUnitProjections(model) {
  if (model.children.length === 0) {
    return void 0;
  }
  let nonUnitProjection;
  for (const child of model.children) {
    parseProjection(child);
  }
  const mergable = every(model.children, (child) => {
    const projection = child.component.projection;
    if (!projection) {
      return true;
    } else if (!nonUnitProjection) {
      nonUnitProjection = projection;
      return true;
    } else {
      const merge = mergeIfNoConflict(nonUnitProjection, projection);
      if (merge) {
        nonUnitProjection = merge;
      }
      return !!merge;
    }
  });
  if (nonUnitProjection && mergable) {
    const name5 = model.projectionName(true);
    const modelProjection = new ProjectionComponent(name5, nonUnitProjection.specifiedProjection, nonUnitProjection.size, duplicate(nonUnitProjection.data));
    for (const child of model.children) {
      const projection = child.component.projection;
      if (projection) {
        if (projection.isFit) {
          modelProjection.data.push(...child.component.projection.data);
        }
        child.renameProjection(projection.get("name"), name5);
        projection.merged = true;
      }
    }
    return modelProjection;
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/data/bin.js
var __rest22 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function rangeFormula(model, fieldDef, channel, config) {
  var _a, _b;
  if (binRequiresRange(fieldDef, channel)) {
    const guide = isUnitModel(model) ? (_b = (_a = model.axis(channel)) !== null && _a !== void 0 ? _a : model.legend(channel)) !== null && _b !== void 0 ? _b : {} : {};
    const startField = vgField(fieldDef, { expr: "datum" });
    const endField = vgField(fieldDef, { expr: "datum", binSuffix: "end" });
    return {
      formulaAs: vgField(fieldDef, { binSuffix: "range", forAs: true }),
      formula: binFormatExpression(startField, endField, guide.format, guide.formatType, config)
    };
  }
  return {};
}
function binKey(bin2, field) {
  return `${binToString(bin2)}_${field}`;
}
function getSignalsFromModel(model, key) {
  return {
    signal: model.getName(`${key}_bins`),
    extentSignal: model.getName(`${key}_extent`)
  };
}
function getBinSignalName(model, field, bin2) {
  var _a;
  const normalizedBin = (_a = normalizeBin(bin2, void 0)) !== null && _a !== void 0 ? _a : {};
  const key = binKey(normalizedBin, field);
  return model.getName(`${key}_bins`);
}
function isBinTransform(t2) {
  return "as" in t2;
}
function createBinComponent(t2, bin2, model) {
  let as;
  let span;
  if (isBinTransform(t2)) {
    as = isString2(t2.as) ? [t2.as, `${t2.as}_end`] : [t2.as[0], t2.as[1]];
  } else {
    as = [vgField(t2, { forAs: true }), vgField(t2, { binSuffix: "end", forAs: true })];
  }
  const normalizedBin = Object.assign({}, normalizeBin(bin2, void 0));
  const key = binKey(normalizedBin, t2.field);
  const { signal, extentSignal } = getSignalsFromModel(model, key);
  if (isParameterExtent(normalizedBin.extent)) {
    const ext = normalizedBin.extent;
    span = parseSelectionExtent(model, ext.param, ext);
    delete normalizedBin.extent;
  }
  const binComponent = Object.assign(Object.assign(Object.assign({ bin: normalizedBin, field: t2.field, as: [as] }, signal ? { signal } : {}), extentSignal ? { extentSignal } : {}), span ? { span } : {});
  return { key, binComponent };
}
var BinNode = class extends DataFlowNode {
  constructor(parent, bins2) {
    super(parent);
    this.bins = bins2;
  }
  clone() {
    return new BinNode(null, duplicate(this.bins));
  }
  static makeFromEncoding(parent, model) {
    const bins2 = model.reduceFieldDef((binComponentIndex, fieldDef, channel) => {
      if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {
        const { key, binComponent } = createBinComponent(fieldDef, fieldDef.bin, model);
        binComponentIndex[key] = Object.assign(Object.assign(Object.assign({}, binComponent), binComponentIndex[key]), rangeFormula(model, fieldDef, channel, model.config));
      }
      return binComponentIndex;
    }, {});
    if (isEmpty(bins2)) {
      return null;
    }
    return new BinNode(parent, bins2);
  }
  static makeFromTransform(parent, t2, model) {
    const { key, binComponent } = createBinComponent(t2, t2.bin, model);
    return new BinNode(parent, {
      [key]: binComponent
    });
  }
  merge(other, renameSignal) {
    for (const key of keys(other.bins)) {
      if (key in this.bins) {
        renameSignal(other.bins[key].signal, this.bins[key].signal);
        this.bins[key].as = unique([...this.bins[key].as, ...other.bins[key].as], hash);
      } else {
        this.bins[key] = other.bins[key];
      }
    }
    for (const child of other.children) {
      other.removeChild(child);
      child.parent = this;
    }
    other.remove();
  }
  producedFields() {
    return new Set(vals(this.bins).map((c) => c.as).flat(2));
  }
  dependentFields() {
    return new Set(vals(this.bins).map((c) => c.field));
  }
  hash() {
    return `Bin ${hash(this.bins)}`;
  }
  assemble() {
    return vals(this.bins).flatMap((bin2) => {
      const transform = [];
      const [binAs, ...remainingAs] = bin2.as;
      const _a = bin2.bin, { extent } = _a, params = __rest22(_a, ["extent"]);
      const binTrans = Object.assign(Object.assign(Object.assign({ type: "bin", field: replacePathInField(bin2.field), as: binAs, signal: bin2.signal }, !isParameterExtent(extent) ? { extent } : { extent: null }), bin2.span ? { span: { signal: `span(${bin2.span})` } } : {}), params);
      if (!extent && bin2.extentSignal) {
        transform.push({
          type: "extent",
          field: replacePathInField(bin2.field),
          signal: bin2.extentSignal
        });
        binTrans.extent = { signal: bin2.extentSignal };
      }
      transform.push(binTrans);
      for (const as of remainingAs) {
        for (let i = 0; i < 2; i++) {
          transform.push({
            type: "formula",
            expr: vgField({ field: binAs[i] }, { expr: "datum" }),
            as: as[i]
          });
        }
      }
      if (bin2.formula) {
        transform.push({
          type: "formula",
          expr: bin2.formula,
          as: bin2.formulaAs
        });
      }
      return transform;
    });
  }
};

// node_modules/vega-lite/build/src/compile/data/aggregate.js
function addDimension(dims, channel, fieldDef, model) {
  var _a;
  const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : void 0;
  if (isTypedFieldDef(fieldDef) && isUnitModel(model) && hasBandEnd(fieldDef, channelDef2, model.markDef, model.config)) {
    dims.add(vgField(fieldDef, {}));
    dims.add(vgField(fieldDef, { suffix: "end" }));
    if (fieldDef.bin && binRequiresRange(fieldDef, channel)) {
      dims.add(vgField(fieldDef, { binSuffix: "range" }));
    }
  } else if (isGeoPositionChannel(channel)) {
    const posChannel = getPositionChannelFromLatLong(channel);
    dims.add(model.getName(posChannel));
  } else {
    dims.add(vgField(fieldDef));
  }
  if (isScaleFieldDef(fieldDef) && isFieldRange((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.range)) {
    dims.add(fieldDef.scale.range.field);
  }
  return dims;
}
function mergeMeasures(parentMeasures, childMeasures) {
  var _a;
  for (const field of keys(childMeasures)) {
    const ops = childMeasures[field];
    for (const op of keys(ops)) {
      if (field in parentMeasures) {
        parentMeasures[field][op] = new Set([...(_a = parentMeasures[field][op]) !== null && _a !== void 0 ? _a : [], ...ops[op]]);
      } else {
        parentMeasures[field] = { [op]: ops[op] };
      }
    }
  }
}
var AggregateNode = class extends DataFlowNode {
  constructor(parent, dimensions, measures) {
    super(parent);
    this.dimensions = dimensions;
    this.measures = measures;
  }
  clone() {
    return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));
  }
  get groupBy() {
    return this.dimensions;
  }
  static makeFromEncoding(parent, model) {
    let isAggregate3 = false;
    model.forEachFieldDef((fd) => {
      if (fd.aggregate) {
        isAggregate3 = true;
      }
    });
    const meas = {};
    const dims = new Set();
    if (!isAggregate3) {
      return null;
    }
    model.forEachFieldDef((fieldDef, channel) => {
      var _a, _b, _c, _d;
      const { aggregate, field } = fieldDef;
      if (aggregate) {
        if (aggregate === "count") {
          (_a = meas["*"]) !== null && _a !== void 0 ? _a : meas["*"] = {};
          meas["*"]["count"] = new Set([vgField(fieldDef, { forAs: true })]);
        } else {
          if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {
            const op = isArgminDef(aggregate) ? "argmin" : "argmax";
            const argField = aggregate[op];
            (_b = meas[argField]) !== null && _b !== void 0 ? _b : meas[argField] = {};
            meas[argField][op] = new Set([vgField({ op, field: argField }, { forAs: true })]);
          } else {
            (_c = meas[field]) !== null && _c !== void 0 ? _c : meas[field] = {};
            meas[field][aggregate] = new Set([vgField(fieldDef, { forAs: true })]);
          }
          if (isScaleChannel(channel) && model.scaleDomain(channel) === "unaggregated") {
            (_d = meas[field]) !== null && _d !== void 0 ? _d : meas[field] = {};
            meas[field]["min"] = new Set([vgField({ field, aggregate: "min" }, { forAs: true })]);
            meas[field]["max"] = new Set([vgField({ field, aggregate: "max" }, { forAs: true })]);
          }
        }
      } else {
        addDimension(dims, channel, fieldDef, model);
      }
    });
    if (dims.size + keys(meas).length === 0) {
      return null;
    }
    return new AggregateNode(parent, dims, meas);
  }
  static makeFromTransform(parent, t2) {
    var _a, _b, _c;
    const dims = new Set();
    const meas = {};
    for (const s of t2.aggregate) {
      const { op, field, as } = s;
      if (op) {
        if (op === "count") {
          (_a = meas["*"]) !== null && _a !== void 0 ? _a : meas["*"] = {};
          meas["*"]["count"] = new Set([as ? as : vgField(s, { forAs: true })]);
        } else {
          (_b = meas[field]) !== null && _b !== void 0 ? _b : meas[field] = {};
          meas[field][op] = new Set([as ? as : vgField(s, { forAs: true })]);
        }
      }
    }
    for (const s of (_c = t2.groupby) !== null && _c !== void 0 ? _c : []) {
      dims.add(s);
    }
    if (dims.size + keys(meas).length === 0) {
      return null;
    }
    return new AggregateNode(parent, dims, meas);
  }
  merge(other) {
    if (setEqual(this.dimensions, other.dimensions)) {
      mergeMeasures(this.measures, other.measures);
      return true;
    } else {
      debug("different dimensions, cannot merge");
      return false;
    }
  }
  addDimensions(fields) {
    fields.forEach(this.dimensions.add, this.dimensions);
  }
  dependentFields() {
    return new Set([...this.dimensions, ...keys(this.measures)]);
  }
  producedFields() {
    const out = new Set();
    for (const field of keys(this.measures)) {
      for (const op of keys(this.measures[field])) {
        const m = this.measures[field][op];
        if (m.size === 0) {
          out.add(`${op}_${field}`);
        } else {
          m.forEach(out.add, out);
        }
      }
    }
    return out;
  }
  hash() {
    return `Aggregate ${hash({ dimensions: this.dimensions, measures: this.measures })}`;
  }
  assemble() {
    const ops = [];
    const fields = [];
    const as = [];
    for (const field of keys(this.measures)) {
      for (const op of keys(this.measures[field])) {
        for (const alias of this.measures[field][op]) {
          as.push(alias);
          ops.push(op);
          fields.push(field === "*" ? null : replacePathInField(field));
        }
      }
    }
    const result = {
      type: "aggregate",
      groupby: [...this.dimensions].map(replacePathInField),
      ops,
      fields,
      as
    };
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/facet.js
var FacetNode = class extends DataFlowNode {
  constructor(parent, model, name5, data) {
    super(parent);
    this.model = model;
    this.name = name5;
    this.data = data;
    for (const channel of FACET_CHANNELS) {
      const fieldDef = model.facet[channel];
      if (fieldDef) {
        const { bin: bin2, sort } = fieldDef;
        this[channel] = Object.assign({ name: model.getName(`${channel}_domain`), fields: [vgField(fieldDef), ...isBinning(bin2) ? [vgField(fieldDef, { binSuffix: "end" })] : []] }, isSortField(sort) ? { sortField: sort } : isArray2(sort) ? { sortIndexField: sortArrayIndexField(fieldDef, channel) } : {});
      }
    }
    this.childModel = model.child;
  }
  hash() {
    let out = `Facet`;
    for (const channel of FACET_CHANNELS) {
      if (this[channel]) {
        out += ` ${channel.charAt(0)}:${hash(this[channel])}`;
      }
    }
    return out;
  }
  get fields() {
    var _a;
    const f = [];
    for (const channel of FACET_CHANNELS) {
      if ((_a = this[channel]) === null || _a === void 0 ? void 0 : _a.fields) {
        f.push(...this[channel].fields);
      }
    }
    return f;
  }
  dependentFields() {
    const depFields = new Set(this.fields);
    for (const channel of FACET_CHANNELS) {
      if (this[channel]) {
        if (this[channel].sortField) {
          depFields.add(this[channel].sortField.field);
        }
        if (this[channel].sortIndexField) {
          depFields.add(this[channel].sortIndexField);
        }
      }
    }
    return depFields;
  }
  producedFields() {
    return new Set();
  }
  getSource() {
    return this.name;
  }
  getChildIndependentFieldsWithStep() {
    const childIndependentFieldsWithStep = {};
    for (const channel of POSITION_SCALE_CHANNELS) {
      const childScaleComponent = this.childModel.component.scales[channel];
      if (childScaleComponent && !childScaleComponent.merged) {
        const type = childScaleComponent.get("type");
        const range2 = childScaleComponent.get("range");
        if (hasDiscreteDomain(type) && isVgRangeStep(range2)) {
          const domain2 = assembleDomain(this.childModel, channel);
          const field = getFieldFromDomain(domain2);
          if (field) {
            childIndependentFieldsWithStep[channel] = field;
          } else {
            warn(message_exports.unknownField(channel));
          }
        }
      }
    }
    return childIndependentFieldsWithStep;
  }
  assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {
    const childChannel = { row: "y", column: "x", facet: void 0 }[channel];
    const fields = [];
    const ops = [];
    const as = [];
    if (childChannel && childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {
      if (crossedDataName) {
        fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);
        ops.push("max");
      } else {
        fields.push(childIndependentFieldsWithStep[childChannel]);
        ops.push("distinct");
      }
      as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);
    }
    const { sortField, sortIndexField } = this[channel];
    if (sortField) {
      const { op = DEFAULT_SORT_OP, field } = sortField;
      fields.push(field);
      ops.push(op);
      as.push(vgField(sortField, { forAs: true }));
    } else if (sortIndexField) {
      fields.push(sortIndexField);
      ops.push("max");
      as.push(sortIndexField);
    }
    return {
      name: this[channel].name,
      source: crossedDataName !== null && crossedDataName !== void 0 ? crossedDataName : this.data,
      transform: [
        Object.assign({ type: "aggregate", groupby: this[channel].fields }, fields.length ? {
          fields,
          ops,
          as
        } : {})
      ]
    };
  }
  assembleFacetHeaderData(childIndependentFieldsWithStep) {
    var _a, _b;
    const { columns } = this.model.layout;
    const { layoutHeaders } = this.model.component;
    const data = [];
    const hasSharedAxis = {};
    for (const headerChannel of HEADER_CHANNELS) {
      for (const headerType of HEADER_TYPES) {
        const headers = (_a = layoutHeaders[headerChannel] && layoutHeaders[headerChannel][headerType]) !== null && _a !== void 0 ? _a : [];
        for (const header of headers) {
          if (((_b = header.axes) === null || _b === void 0 ? void 0 : _b.length) > 0) {
            hasSharedAxis[headerChannel] = true;
            break;
          }
        }
      }
      if (hasSharedAxis[headerChannel]) {
        const cardinality = `length(data("${this.facet.name}"))`;
        const stop2 = headerChannel === "row" ? columns ? { signal: `ceil(${cardinality} / ${columns})` } : 1 : columns ? { signal: `min(${cardinality}, ${columns})` } : { signal: cardinality };
        data.push({
          name: `${this.facet.name}_${headerChannel}`,
          transform: [
            {
              type: "sequence",
              start: 0,
              stop: stop2
            }
          ]
        });
      }
    }
    const { row, column } = hasSharedAxis;
    if (row || column) {
      data.unshift(this.assembleRowColumnHeaderData("facet", null, childIndependentFieldsWithStep));
    }
    return data;
  }
  assemble() {
    var _a, _b;
    const data = [];
    let crossedDataName = null;
    const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();
    const { column, row, facet } = this;
    if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {
      crossedDataName = `cross_${this.column.name}_${this.row.name}`;
      const fields = [].concat((_a = childIndependentFieldsWithStep.x) !== null && _a !== void 0 ? _a : [], (_b = childIndependentFieldsWithStep.y) !== null && _b !== void 0 ? _b : []);
      const ops = fields.map(() => "distinct");
      data.push({
        name: crossedDataName,
        source: this.data,
        transform: [
          {
            type: "aggregate",
            groupby: this.fields,
            fields,
            ops
          }
        ]
      });
    }
    for (const channel of [COLUMN, ROW]) {
      if (this[channel]) {
        data.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));
      }
    }
    if (facet) {
      const facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);
      if (facetData) {
        data.push(...facetData);
      }
    }
    return data;
  }
};

// node_modules/vega-lite/build/src/compile/data/formatparse.js
function unquote(pattern) {
  if (pattern[0] === "'" && pattern[pattern.length - 1] === "'" || pattern[0] === '"' && pattern[pattern.length - 1] === '"') {
    return pattern.slice(1, -1);
  }
  return pattern;
}
function parseExpression2(field, parse) {
  const f = accessPathWithDatum(field);
  if (parse === "number") {
    return `toNumber(${f})`;
  } else if (parse === "boolean") {
    return `toBoolean(${f})`;
  } else if (parse === "string") {
    return `toString(${f})`;
  } else if (parse === "date") {
    return `toDate(${f})`;
  } else if (parse === "flatten") {
    return f;
  } else if (parse.startsWith("date:")) {
    const specifier = unquote(parse.slice(5, parse.length));
    return `timeParse(${f},'${specifier}')`;
  } else if (parse.startsWith("utc:")) {
    const specifier = unquote(parse.slice(4, parse.length));
    return `utcParse(${f},'${specifier}')`;
  } else {
    warn(message_exports.unrecognizedParse(parse));
    return null;
  }
}
function getImplicitFromFilterTransform(transform) {
  const implicit = {};
  forEachLeaf(transform.filter, (filter) => {
    var _a;
    if (isFieldPredicate(filter)) {
      let val = null;
      if (isFieldEqualPredicate(filter)) {
        val = signalRefOrValue(filter.equal);
      } else if (isFieldLTEPredicate(filter)) {
        val = signalRefOrValue(filter.lte);
      } else if (isFieldLTPredicate(filter)) {
        val = signalRefOrValue(filter.lt);
      } else if (isFieldGTPredicate(filter)) {
        val = signalRefOrValue(filter.gt);
      } else if (isFieldGTEPredicate(filter)) {
        val = signalRefOrValue(filter.gte);
      } else if (isFieldRangePredicate(filter)) {
        val = filter.range[0];
      } else if (isFieldOneOfPredicate(filter)) {
        val = ((_a = filter.oneOf) !== null && _a !== void 0 ? _a : filter["in"])[0];
      }
      if (val) {
        if (isDateTime(val)) {
          implicit[filter.field] = "date";
        } else if (isNumber(val)) {
          implicit[filter.field] = "number";
        } else if (isString2(val)) {
          implicit[filter.field] = "string";
        }
      }
      if (filter.timeUnit) {
        implicit[filter.field] = "date";
      }
    }
  });
  return implicit;
}
function getImplicitFromEncoding(model) {
  const implicit = {};
  function add2(fieldDef) {
    if (isFieldOrDatumDefForTimeFormat(fieldDef)) {
      implicit[fieldDef.field] = "date";
    } else if (fieldDef.type === "quantitative" && isMinMaxOp(fieldDef.aggregate)) {
      implicit[fieldDef.field] = "number";
    } else if (accessPathDepth(fieldDef.field) > 1) {
      if (!(fieldDef.field in implicit)) {
        implicit[fieldDef.field] = "flatten";
      }
    } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {
      if (!(fieldDef.sort.field in implicit)) {
        implicit[fieldDef.sort.field] = "flatten";
      }
    }
  }
  if (isUnitModel(model) || isFacetModel(model)) {
    model.forEachFieldDef((fieldDef, channel) => {
      if (isTypedFieldDef(fieldDef)) {
        add2(fieldDef);
      } else {
        const mainChannel = getMainRangeChannel(channel);
        const mainFieldDef = model.fieldDef(mainChannel);
        add2(Object.assign(Object.assign({}, fieldDef), { type: mainFieldDef.type }));
      }
    });
  }
  if (isUnitModel(model)) {
    const { mark: mark3, markDef, encoding } = model;
    if (isPathMark(mark3) && !model.encoding.order) {
      const dimensionChannel = markDef.orient === "horizontal" ? "y" : "x";
      const dimensionChannelDef = encoding[dimensionChannel];
      if (isFieldDef(dimensionChannelDef) && dimensionChannelDef.type === "quantitative" && !(dimensionChannelDef.field in implicit)) {
        implicit[dimensionChannelDef.field] = "number";
      }
    }
  }
  return implicit;
}
function getImplicitFromSelection(model) {
  const implicit = {};
  if (isUnitModel(model) && model.component.selection) {
    for (const name5 of keys(model.component.selection)) {
      const selCmpt = model.component.selection[name5];
      for (const proj of selCmpt.project.items) {
        if (!proj.channel && accessPathDepth(proj.field) > 1) {
          implicit[proj.field] = "flatten";
        }
      }
    }
  }
  return implicit;
}
var ParseNode = class extends DataFlowNode {
  constructor(parent, parse) {
    super(parent);
    this._parse = parse;
  }
  clone() {
    return new ParseNode(null, duplicate(this._parse));
  }
  hash() {
    return `Parse ${hash(this._parse)}`;
  }
  static makeExplicit(parent, model, ancestorParse) {
    var _a;
    let explicit = {};
    const data = model.data;
    if (!isGenerator(data) && ((_a = data === null || data === void 0 ? void 0 : data.format) === null || _a === void 0 ? void 0 : _a.parse)) {
      explicit = data.format.parse;
    }
    return this.makeWithAncestors(parent, explicit, {}, ancestorParse);
  }
  static makeWithAncestors(parent, explicit, implicit, ancestorParse) {
    for (const field of keys(implicit)) {
      const parsedAs = ancestorParse.getWithExplicit(field);
      if (parsedAs.value !== void 0) {
        if (parsedAs.explicit || parsedAs.value === implicit[field] || parsedAs.value === "derived" || implicit[field] === "flatten") {
          delete implicit[field];
        } else {
          warn(message_exports.differentParse(field, implicit[field], parsedAs.value));
        }
      }
    }
    for (const field of keys(explicit)) {
      const parsedAs = ancestorParse.get(field);
      if (parsedAs !== void 0) {
        if (parsedAs === explicit[field]) {
          delete explicit[field];
        } else {
          warn(message_exports.differentParse(field, explicit[field], parsedAs));
        }
      }
    }
    const parse = new Split(explicit, implicit);
    ancestorParse.copyAll(parse);
    const p = {};
    for (const key of keys(parse.combine())) {
      const val = parse.get(key);
      if (val !== null) {
        p[key] = val;
      }
    }
    if (keys(p).length === 0 || ancestorParse.parseNothing) {
      return null;
    }
    return new ParseNode(parent, p);
  }
  get parse() {
    return this._parse;
  }
  merge(other) {
    this._parse = Object.assign(Object.assign({}, this._parse), other.parse);
    other.remove();
  }
  assembleFormatParse() {
    const formatParse = {};
    for (const field of keys(this._parse)) {
      const p = this._parse[field];
      if (accessPathDepth(field) === 1) {
        formatParse[field] = p;
      }
    }
    return formatParse;
  }
  producedFields() {
    return new Set(keys(this._parse));
  }
  dependentFields() {
    return new Set(keys(this._parse));
  }
  assembleTransforms(onlyNested = false) {
    return keys(this._parse).filter((field) => onlyNested ? accessPathDepth(field) > 1 : true).map((field) => {
      const expr = parseExpression2(field, this._parse[field]);
      if (!expr) {
        return null;
      }
      const formula = {
        type: "formula",
        expr,
        as: removePathFromField(field)
      };
      return formula;
    }).filter((t2) => t2 !== null);
  }
};

// node_modules/vega-lite/build/src/compile/data/identifier.js
var IdentifierNode = class extends DataFlowNode {
  clone() {
    return new IdentifierNode(null);
  }
  constructor(parent) {
    super(parent);
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {
    return new Set([SELECTION_ID]);
  }
  hash() {
    return "Identifier";
  }
  assemble() {
    return { type: "identifier", as: SELECTION_ID };
  }
};

// node_modules/vega-lite/build/src/compile/data/graticule.js
var GraticuleNode = class extends DataFlowNode {
  constructor(parent, params) {
    super(parent);
    this.params = params;
  }
  clone() {
    return new GraticuleNode(null, this.params);
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {
    return void 0;
  }
  hash() {
    return `Graticule ${hash(this.params)}`;
  }
  assemble() {
    return Object.assign({ type: "graticule" }, this.params === true ? {} : this.params);
  }
};

// node_modules/vega-lite/build/src/compile/data/sequence.js
var SequenceNode = class extends DataFlowNode {
  constructor(parent, params) {
    super(parent);
    this.params = params;
  }
  clone() {
    return new SequenceNode(null, this.params);
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {
    var _a;
    return new Set([(_a = this.params.as) !== null && _a !== void 0 ? _a : "data"]);
  }
  hash() {
    return `Hash ${hash(this.params)}`;
  }
  assemble() {
    return Object.assign({ type: "sequence" }, this.params);
  }
};

// node_modules/vega-lite/build/src/compile/data/source.js
var SourceNode = class extends DataFlowNode {
  constructor(data) {
    super(null);
    data !== null && data !== void 0 ? data : data = { name: "source" };
    let format;
    if (!isGenerator(data)) {
      format = data.format ? Object.assign({}, omit(data.format, ["parse"])) : {};
    }
    if (isInlineData(data)) {
      this._data = { values: data.values };
    } else if (isUrlData(data)) {
      this._data = { url: data.url };
      if (!format.type) {
        let defaultExtension = /(?:\.([^.]+))?$/.exec(data.url)[1];
        if (!contains(["json", "csv", "tsv", "dsv", "topojson"], defaultExtension)) {
          defaultExtension = "json";
        }
        format.type = defaultExtension;
      }
    } else if (isSphereGenerator(data)) {
      this._data = { values: [{ type: "Sphere" }] };
    } else if (isNamedData(data) || isGenerator(data)) {
      this._data = {};
    }
    this._generator = isGenerator(data);
    if (data.name) {
      this._name = data.name;
    }
    if (format && !isEmpty(format)) {
      this._data.format = format;
    }
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {
    return void 0;
  }
  get data() {
    return this._data;
  }
  hasName() {
    return !!this._name;
  }
  get isGenerator() {
    return this._generator;
  }
  get dataName() {
    return this._name;
  }
  set dataName(name5) {
    this._name = name5;
  }
  set parent(parent) {
    throw new Error("Source nodes have to be roots.");
  }
  remove() {
    throw new Error("Source nodes are roots and cannot be removed.");
  }
  hash() {
    throw new Error("Cannot hash sources");
  }
  assemble() {
    return Object.assign(Object.assign({ name: this._name }, this._data), { transform: [] });
  }
};

// node_modules/vega-lite/build/src/compile/data/optimizer.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Optimizer_modified;
function isDataSourceNode(node) {
  return node instanceof SourceNode || node instanceof GraticuleNode || node instanceof SequenceNode;
}
var Optimizer = class {
  constructor() {
    _Optimizer_modified.set(this, void 0);
    __classPrivateFieldSet(this, _Optimizer_modified, false, "f");
  }
  setModified() {
    __classPrivateFieldSet(this, _Optimizer_modified, true, "f");
  }
  get modifiedFlag() {
    return __classPrivateFieldGet(this, _Optimizer_modified, "f");
  }
};
_Optimizer_modified = new WeakMap();
var BottomUpOptimizer = class extends Optimizer {
  getNodeDepths(node, depth, depths) {
    depths.set(node, depth);
    for (const child of node.children) {
      this.getNodeDepths(child, depth + 1, depths);
    }
    return depths;
  }
  optimize(node) {
    const depths = this.getNodeDepths(node, 0, new Map());
    const topologicalSort = [...depths.entries()].sort((a, b) => b[1] - a[1]);
    for (const tuple of topologicalSort) {
      this.run(tuple[0]);
    }
    return this.modifiedFlag;
  }
};
var TopDownOptimizer = class extends Optimizer {
  optimize(node) {
    this.run(node);
    for (const child of node.children) {
      this.optimize(child);
    }
    return this.modifiedFlag;
  }
};

// node_modules/vega-lite/build/src/compile/data/optimizers.js
var MergeIdenticalNodes = class extends TopDownOptimizer {
  mergeNodes(parent, nodes) {
    const mergedNode = nodes.shift();
    for (const node of nodes) {
      parent.removeChild(node);
      node.parent = mergedNode;
      node.remove();
    }
  }
  run(node) {
    const hashes = node.children.map((x) => x.hash());
    const buckets = {};
    for (let i = 0; i < hashes.length; i++) {
      if (buckets[hashes[i]] === void 0) {
        buckets[hashes[i]] = [node.children[i]];
      } else {
        buckets[hashes[i]].push(node.children[i]);
      }
    }
    for (const k of keys(buckets)) {
      if (buckets[k].length > 1) {
        this.setModified();
        this.mergeNodes(node, buckets[k]);
      }
    }
  }
};
var RemoveUnnecessaryIdentifierNodes = class extends TopDownOptimizer {
  constructor(model) {
    super();
    this.requiresSelectionId = model && requiresSelectionId(model);
  }
  run(node) {
    if (node instanceof IdentifierNode) {
      if (!(this.requiresSelectionId && (isDataSourceNode(node.parent) || node.parent instanceof AggregateNode || node.parent instanceof ParseNode))) {
        this.setModified();
        node.remove();
      }
    }
  }
};
var RemoveDuplicateTimeUnits = class extends Optimizer {
  optimize(node) {
    this.run(node, new Set());
    return this.modifiedFlag;
  }
  run(node, timeUnitFields) {
    let producedFields = new Set();
    if (node instanceof TimeUnitNode) {
      producedFields = node.producedFields();
      if (hasIntersection(producedFields, timeUnitFields)) {
        this.setModified();
        node.removeFormulas(timeUnitFields);
        if (node.producedFields.length === 0) {
          node.remove();
        }
      }
    }
    for (const child of node.children) {
      this.run(child, new Set([...timeUnitFields, ...producedFields]));
    }
  }
};
var RemoveUnnecessaryOutputNodes = class extends TopDownOptimizer {
  constructor() {
    super();
  }
  run(node) {
    if (node instanceof OutputNode && !node.isRequired()) {
      this.setModified();
      node.remove();
    }
  }
};
var MoveParseUp = class extends BottomUpOptimizer {
  run(node) {
    if (isDataSourceNode(node)) {
      return;
    }
    if (node.numChildren() > 1) {
      return;
    }
    for (const child of node.children) {
      if (child instanceof ParseNode) {
        if (node instanceof ParseNode) {
          this.setModified();
          node.merge(child);
        } else {
          if (fieldIntersection(node.producedFields(), child.dependentFields())) {
            continue;
          }
          this.setModified();
          child.swapWithParent();
        }
      }
    }
    return;
  }
};
var MergeParse = class extends BottomUpOptimizer {
  run(node) {
    const originalChildren = [...node.children];
    const parseChildren = node.children.filter((child) => child instanceof ParseNode);
    if (node.numChildren() > 1 && parseChildren.length >= 1) {
      const commonParse = {};
      const conflictingParse = new Set();
      for (const parseNode of parseChildren) {
        const parse = parseNode.parse;
        for (const k of keys(parse)) {
          if (!(k in commonParse)) {
            commonParse[k] = parse[k];
          } else if (commonParse[k] !== parse[k]) {
            conflictingParse.add(k);
          }
        }
      }
      for (const field of conflictingParse) {
        delete commonParse[field];
      }
      if (!isEmpty(commonParse)) {
        this.setModified();
        const mergedParseNode = new ParseNode(node, commonParse);
        for (const childNode of originalChildren) {
          if (childNode instanceof ParseNode) {
            for (const key of keys(commonParse)) {
              delete childNode.parse[key];
            }
          }
          node.removeChild(childNode);
          childNode.parent = mergedParseNode;
          if (childNode instanceof ParseNode && keys(childNode.parse).length === 0) {
            childNode.remove();
          }
        }
      }
    }
  }
};
var RemoveUnusedSubtrees = class extends BottomUpOptimizer {
  run(node) {
    if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode) {
    } else if (node instanceof SourceNode) {
    } else {
      this.setModified();
      node.remove();
    }
  }
};
var MergeTimeUnits = class extends BottomUpOptimizer {
  run(node) {
    const timeUnitChildren = node.children.filter((x) => x instanceof TimeUnitNode);
    const combination = timeUnitChildren.pop();
    for (const timeUnit of timeUnitChildren) {
      this.setModified();
      combination.merge(timeUnit);
    }
  }
};
var MergeAggregates = class extends BottomUpOptimizer {
  run(node) {
    const aggChildren = node.children.filter((child) => child instanceof AggregateNode);
    const groupedAggregates = {};
    for (const agg of aggChildren) {
      const groupBys = hash(agg.groupBy);
      if (!(groupBys in groupedAggregates)) {
        groupedAggregates[groupBys] = [];
      }
      groupedAggregates[groupBys].push(agg);
    }
    for (const group of keys(groupedAggregates)) {
      const mergeableAggs = groupedAggregates[group];
      if (mergeableAggs.length > 1) {
        const mergedAggs = mergeableAggs.pop();
        for (const agg of mergeableAggs) {
          if (mergedAggs.merge(agg)) {
            node.removeChild(agg);
            agg.parent = mergedAggs;
            agg.remove();
            this.setModified();
          }
        }
      }
    }
  }
};
var MergeBins = class extends BottomUpOptimizer {
  constructor(model) {
    super();
    this.model = model;
  }
  run(node) {
    const moveBinsUp = !(isDataSourceNode(node) || node instanceof FilterNode || node instanceof ParseNode || node instanceof IdentifierNode);
    const promotableBins = [];
    const remainingBins = [];
    for (const child of node.children) {
      if (child instanceof BinNode) {
        if (moveBinsUp && !fieldIntersection(node.producedFields(), child.dependentFields())) {
          promotableBins.push(child);
        } else {
          remainingBins.push(child);
        }
      }
    }
    if (promotableBins.length > 0) {
      const promotedBin = promotableBins.pop();
      for (const bin2 of promotableBins) {
        promotedBin.merge(bin2, this.model.renameSignal.bind(this.model));
      }
      this.setModified();
      if (node instanceof BinNode) {
        node.merge(promotedBin, this.model.renameSignal.bind(this.model));
      } else {
        promotedBin.swapWithParent();
      }
    }
    if (remainingBins.length > 1) {
      const remainingBin = remainingBins.pop();
      for (const bin2 of remainingBins) {
        remainingBin.merge(bin2, this.model.renameSignal.bind(this.model));
      }
      this.setModified();
    }
  }
};
var MergeOutputs = class extends BottomUpOptimizer {
  run(node) {
    const children2 = [...node.children];
    const hasOutputChild = some(children2, (child) => child instanceof OutputNode);
    if (!hasOutputChild || node.numChildren() <= 1) {
      return;
    }
    const otherChildren = [];
    let mainOutput;
    for (const child of children2) {
      if (child instanceof OutputNode) {
        let lastOutput = child;
        while (lastOutput.numChildren() === 1) {
          const [theChild] = lastOutput.children;
          if (theChild instanceof OutputNode) {
            lastOutput = theChild;
          } else {
            break;
          }
        }
        otherChildren.push(...lastOutput.children);
        if (mainOutput) {
          node.removeChild(child);
          child.parent = mainOutput.parent;
          mainOutput.parent.removeChild(mainOutput);
          mainOutput.parent = lastOutput;
          this.setModified();
        } else {
          mainOutput = lastOutput;
        }
      } else {
        otherChildren.push(child);
      }
    }
    if (otherChildren.length) {
      this.setModified();
      for (const child of otherChildren) {
        child.parent.removeChild(child);
        child.parent = mainOutput;
      }
    }
  }
};

// node_modules/vega-lite/build/src/compile/data/joinaggregate.js
var JoinAggregateTransformNode = class extends DataFlowNode {
  constructor(parent, transform) {
    super(parent);
    this.transform = transform;
  }
  clone() {
    return new JoinAggregateTransformNode(null, duplicate(this.transform));
  }
  addDimensions(fields) {
    this.transform.groupby = unique(this.transform.groupby.concat(fields), (d) => d);
  }
  dependentFields() {
    const out = new Set();
    if (this.transform.groupby) {
      this.transform.groupby.forEach(out.add, out);
    }
    this.transform.joinaggregate.map((w2) => w2.field).filter((f) => f !== void 0).forEach(out.add, out);
    return out;
  }
  producedFields() {
    return new Set(this.transform.joinaggregate.map(this.getDefaultName));
  }
  getDefaultName(joinAggregateFieldDef) {
    var _a;
    return (_a = joinAggregateFieldDef.as) !== null && _a !== void 0 ? _a : vgField(joinAggregateFieldDef);
  }
  hash() {
    return `JoinAggregateTransform ${hash(this.transform)}`;
  }
  assemble() {
    const fields = [];
    const ops = [];
    const as = [];
    for (const joinaggregate of this.transform.joinaggregate) {
      ops.push(joinaggregate.op);
      as.push(this.getDefaultName(joinaggregate));
      fields.push(joinaggregate.field === void 0 ? null : joinaggregate.field);
    }
    const groupby = this.transform.groupby;
    return Object.assign({
      type: "joinaggregate",
      as,
      ops,
      fields
    }, groupby !== void 0 ? { groupby } : {});
  }
};

// node_modules/vega-lite/build/src/compile/data/stack.js
function getStackByFields(model) {
  return model.stack.stackBy.reduce((fields, by) => {
    const fieldDef = by.fieldDef;
    const _field = vgField(fieldDef);
    if (_field) {
      fields.push(_field);
    }
    return fields;
  }, []);
}
function isValidAsArray(as) {
  return isArray2(as) && as.every((s) => isString2(s)) && as.length > 1;
}
var StackNode = class extends DataFlowNode {
  constructor(parent, stack2) {
    super(parent);
    this._stack = stack2;
  }
  clone() {
    return new StackNode(null, duplicate(this._stack));
  }
  static makeFromTransform(parent, stackTransform) {
    const { stack: stack2, groupby, as, offset = "zero" } = stackTransform;
    const sortFields = [];
    const sortOrder = [];
    if (stackTransform.sort !== void 0) {
      for (const sortField of stackTransform.sort) {
        sortFields.push(sortField.field);
        sortOrder.push(getFirstDefined(sortField.order, "ascending"));
      }
    }
    const sort = {
      field: sortFields,
      order: sortOrder
    };
    let normalizedAs;
    if (isValidAsArray(as)) {
      normalizedAs = as;
    } else if (isString2(as)) {
      normalizedAs = [as, `${as}_end`];
    } else {
      normalizedAs = [`${stackTransform.stack}_start`, `${stackTransform.stack}_end`];
    }
    return new StackNode(parent, {
      stackField: stack2,
      groupby,
      offset,
      sort,
      facetby: [],
      as: normalizedAs
    });
  }
  static makeFromEncoding(parent, model) {
    const stackProperties = model.stack;
    const { encoding } = model;
    if (!stackProperties) {
      return null;
    }
    const { groupbyChannel, fieldChannel, offset, impute } = stackProperties;
    let dimensionFieldDef;
    if (groupbyChannel) {
      const cDef = encoding[groupbyChannel];
      dimensionFieldDef = getFieldDef(cDef);
    }
    const stackby = getStackByFields(model);
    const orderDef = model.encoding.order;
    let sort;
    if (isArray2(orderDef) || isFieldDef(orderDef)) {
      sort = sortParams(orderDef);
    } else {
      sort = stackby.reduce((s, field) => {
        s.field.push(field);
        s.order.push(fieldChannel === "y" ? "descending" : "ascending");
        return s;
      }, { field: [], order: [] });
    }
    return new StackNode(parent, {
      dimensionFieldDef,
      stackField: model.vgField(fieldChannel),
      facetby: [],
      stackby,
      sort,
      offset,
      impute,
      as: [
        model.vgField(fieldChannel, { suffix: "start", forAs: true }),
        model.vgField(fieldChannel, { suffix: "end", forAs: true })
      ]
    });
  }
  get stack() {
    return this._stack;
  }
  addDimensions(fields) {
    this._stack.facetby.push(...fields);
  }
  dependentFields() {
    const out = new Set();
    out.add(this._stack.stackField);
    this.getGroupbyFields().forEach(out.add, out);
    this._stack.facetby.forEach(out.add, out);
    this._stack.sort.field.forEach(out.add, out);
    return out;
  }
  producedFields() {
    return new Set(this._stack.as);
  }
  hash() {
    return `Stack ${hash(this._stack)}`;
  }
  getGroupbyFields() {
    const { dimensionFieldDef, impute, groupby } = this._stack;
    if (dimensionFieldDef) {
      if (dimensionFieldDef.bin) {
        if (impute) {
          return [vgField(dimensionFieldDef, { binSuffix: "mid" })];
        }
        return [
          vgField(dimensionFieldDef, {}),
          vgField(dimensionFieldDef, { binSuffix: "end" })
        ];
      }
      return [vgField(dimensionFieldDef)];
    }
    return groupby !== null && groupby !== void 0 ? groupby : [];
  }
  assemble() {
    const transform = [];
    const { facetby, dimensionFieldDef, stackField: field, stackby, sort, offset, impute, as } = this._stack;
    if (impute && dimensionFieldDef) {
      const { bandPosition = 0.5, bin: bin2 } = dimensionFieldDef;
      if (bin2) {
        transform.push({
          type: "formula",
          expr: `${bandPosition}*` + vgField(dimensionFieldDef, { expr: "datum" }) + `+${1 - bandPosition}*` + vgField(dimensionFieldDef, { expr: "datum", binSuffix: "end" }),
          as: vgField(dimensionFieldDef, { binSuffix: "mid", forAs: true })
        });
      }
      transform.push({
        type: "impute",
        field,
        groupby: [...stackby, ...facetby],
        key: vgField(dimensionFieldDef, { binSuffix: "mid" }),
        method: "value",
        value: 0
      });
    }
    transform.push({
      type: "stack",
      groupby: [...this.getGroupbyFields(), ...facetby],
      field,
      sort,
      as,
      offset
    });
    return transform;
  }
};

// node_modules/vega-lite/build/src/compile/data/window.js
var WindowTransformNode = class extends DataFlowNode {
  constructor(parent, transform) {
    super(parent);
    this.transform = transform;
  }
  clone() {
    return new WindowTransformNode(null, duplicate(this.transform));
  }
  addDimensions(fields) {
    this.transform.groupby = unique(this.transform.groupby.concat(fields), (d) => d);
  }
  dependentFields() {
    var _a, _b;
    const out = new Set();
    ((_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []).forEach(out.add, out);
    ((_b = this.transform.sort) !== null && _b !== void 0 ? _b : []).forEach((m) => out.add(m.field));
    this.transform.window.map((w2) => w2.field).filter((f) => f !== void 0).forEach(out.add, out);
    return out;
  }
  producedFields() {
    return new Set(this.transform.window.map(this.getDefaultName));
  }
  getDefaultName(windowFieldDef) {
    var _a;
    return (_a = windowFieldDef.as) !== null && _a !== void 0 ? _a : vgField(windowFieldDef);
  }
  hash() {
    return `WindowTransform ${hash(this.transform)}`;
  }
  assemble() {
    var _a;
    const fields = [];
    const ops = [];
    const as = [];
    const params = [];
    for (const window2 of this.transform.window) {
      ops.push(window2.op);
      as.push(this.getDefaultName(window2));
      params.push(window2.param === void 0 ? null : window2.param);
      fields.push(window2.field === void 0 ? null : window2.field);
    }
    const frame = this.transform.frame;
    const groupby = this.transform.groupby;
    if (frame && frame[0] === null && frame[1] === null && ops.every((o) => isAggregateOp(o))) {
      return Object.assign({ type: "joinaggregate", as, ops, fields }, groupby !== void 0 ? { groupby } : {});
    }
    const sortFields = [];
    const sortOrder = [];
    if (this.transform.sort !== void 0) {
      for (const sortField of this.transform.sort) {
        sortFields.push(sortField.field);
        sortOrder.push((_a = sortField.order) !== null && _a !== void 0 ? _a : "ascending");
      }
    }
    const sort = {
      field: sortFields,
      order: sortOrder
    };
    const ignorePeers = this.transform.ignorePeers;
    return Object.assign(Object.assign(Object.assign({
      type: "window",
      params,
      as,
      ops,
      fields,
      sort
    }, ignorePeers !== void 0 ? { ignorePeers } : {}), groupby !== void 0 ? { groupby } : {}), frame !== void 0 ? { frame } : {});
  }
};

// node_modules/vega-lite/build/src/compile/data/subtree.js
function cloneSubtree(facet) {
  function clone(node) {
    if (!(node instanceof FacetNode)) {
      const copy = node.clone();
      if (copy instanceof OutputNode) {
        const newName = FACET_SCALE_PREFIX + copy.getSource();
        copy.setSource(newName);
        facet.model.component.data.outputNodes[newName] = copy;
      } else if (copy instanceof AggregateNode || copy instanceof StackNode || copy instanceof WindowTransformNode || copy instanceof JoinAggregateTransformNode) {
        copy.addDimensions(facet.fields);
      }
      for (const n of node.children.flatMap(clone)) {
        n.parent = copy;
      }
      return [copy];
    }
    return node.children.flatMap(clone);
  }
  return clone;
}
function moveFacetDown(node) {
  if (node instanceof FacetNode) {
    if (node.numChildren() === 1 && !(node.children[0] instanceof OutputNode)) {
      const child = node.children[0];
      if (child instanceof AggregateNode || child instanceof StackNode || child instanceof WindowTransformNode || child instanceof JoinAggregateTransformNode) {
        child.addDimensions(node.fields);
      }
      child.swapWithParent();
      moveFacetDown(node);
    } else {
      const facetMain = node.model.component.data.main;
      moveMainDownToFacet(facetMain);
      const cloner = cloneSubtree(node);
      const copy = node.children.map(cloner).flat();
      for (const c of copy) {
        c.parent = facetMain;
      }
    }
  } else {
    node.children.map(moveFacetDown);
  }
}
function moveMainDownToFacet(node) {
  if (node instanceof OutputNode && node.type === DataSourceType.Main) {
    if (node.numChildren() === 1) {
      const child = node.children[0];
      if (!(child instanceof FacetNode)) {
        child.swapWithParent();
        moveMainDownToFacet(node);
      }
    }
  }
}

// node_modules/vega-lite/build/src/compile/data/optimize.js
var FACET_SCALE_PREFIX = "scale_";
var MAX_OPTIMIZATION_RUNS = 5;
function checkLinks(nodes) {
  for (const node of nodes) {
    for (const child of node.children) {
      if (child.parent !== node) {
        return false;
      }
    }
    if (!checkLinks(node.children)) {
      return false;
    }
  }
  return true;
}
function runOptimizer(optimizer, nodes) {
  let modified = false;
  for (const node of nodes) {
    modified = optimizer.optimize(node) || modified;
  }
  return modified;
}
function optimizationDataflowHelper(dataComponent, model, firstPass) {
  let roots = dataComponent.sources;
  let modified = false;
  modified = runOptimizer(new RemoveUnnecessaryOutputNodes(), roots) || modified;
  modified = runOptimizer(new RemoveUnnecessaryIdentifierNodes(model), roots) || modified;
  roots = roots.filter((r) => r.numChildren() > 0);
  modified = runOptimizer(new RemoveUnusedSubtrees(), roots) || modified;
  roots = roots.filter((r) => r.numChildren() > 0);
  if (!firstPass) {
    modified = runOptimizer(new MoveParseUp(), roots) || modified;
    modified = runOptimizer(new MergeBins(model), roots) || modified;
    modified = runOptimizer(new RemoveDuplicateTimeUnits(), roots) || modified;
    modified = runOptimizer(new MergeParse(), roots) || modified;
    modified = runOptimizer(new MergeAggregates(), roots) || modified;
    modified = runOptimizer(new MergeTimeUnits(), roots) || modified;
    modified = runOptimizer(new MergeIdenticalNodes(), roots) || modified;
    modified = runOptimizer(new MergeOutputs(), roots) || modified;
  }
  dataComponent.sources = roots;
  return modified;
}
function optimizeDataflow(data, model) {
  checkLinks(data.sources);
  let firstPassCounter = 0;
  let secondPassCounter = 0;
  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {
    if (!optimizationDataflowHelper(data, model, true)) {
      break;
    }
    firstPassCounter++;
  }
  data.sources.map(moveFacetDown);
  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {
    if (!optimizationDataflowHelper(data, model, false)) {
      break;
    }
    secondPassCounter++;
  }
  checkLinks(data.sources);
  if (Math.max(firstPassCounter, secondPassCounter) === MAX_OPTIMIZATION_RUNS) {
    warn(`Maximum optimization runs(${MAX_OPTIMIZATION_RUNS}) reached.`);
  }
}

// node_modules/vega-lite/build/src/compile/signal.js
var SignalRefWrapper = class {
  constructor(exprGenerator) {
    Object.defineProperty(this, "signal", {
      enumerable: true,
      get: exprGenerator
    });
  }
  static fromName(rename, signalName) {
    return new SignalRefWrapper(() => rename(signalName));
  }
};

// node_modules/vega-lite/build/src/compile/scale/domain.js
var __rest23 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function parseScaleDomain(model) {
  if (isUnitModel(model)) {
    parseUnitScaleDomain(model);
  } else {
    parseNonUnitScaleDomain(model);
  }
}
function parseUnitScaleDomain(model) {
  const localScaleComponents = model.component.scales;
  for (const channel of keys(localScaleComponents)) {
    const domains = parseDomainForChannel(model, channel);
    const localScaleCmpt = localScaleComponents[channel];
    localScaleCmpt.setWithExplicit("domains", domains);
    parseSelectionDomain(model, channel);
    if (model.component.data.isFaceted) {
      let facetParent = model;
      while (!isFacetModel(facetParent) && facetParent.parent) {
        facetParent = facetParent.parent;
      }
      const resolve = facetParent.component.resolve.scale[channel];
      if (resolve === "shared") {
        for (const domain2 of domains.value) {
          if (isDataRefDomain(domain2)) {
            domain2.data = FACET_SCALE_PREFIX + domain2.data.replace(FACET_SCALE_PREFIX, "");
          }
        }
      }
    }
  }
}
function parseNonUnitScaleDomain(model) {
  for (const child of model.children) {
    parseScaleDomain(child);
  }
  const localScaleComponents = model.component.scales;
  for (const channel of keys(localScaleComponents)) {
    let domains;
    let selectionExtent = null;
    for (const child of model.children) {
      const childComponent = child.component.scales[channel];
      if (childComponent) {
        if (domains === void 0) {
          domains = childComponent.getWithExplicit("domains");
        } else {
          domains = mergeValuesWithExplicit(domains, childComponent.getWithExplicit("domains"), "domains", "scale", domainsTieBreaker);
        }
        const se = childComponent.get("selectionExtent");
        if (selectionExtent && se && selectionExtent.param !== se.param) {
          warn(message_exports.NEEDS_SAME_SELECTION);
        }
        selectionExtent = se;
      }
    }
    localScaleComponents[channel].setWithExplicit("domains", domains);
    if (selectionExtent) {
      localScaleComponents[channel].set("selectionExtent", selectionExtent, true);
    }
  }
}
function normalizeUnaggregatedDomain(domain2, fieldDef, scaleType2, scaleConfig) {
  if (domain2 === "unaggregated") {
    const { valid, reason } = canUseUnaggregatedDomain(fieldDef, scaleType2);
    if (!valid) {
      warn(reason);
      return void 0;
    }
  } else if (domain2 === void 0 && scaleConfig.useUnaggregatedDomain) {
    const { valid } = canUseUnaggregatedDomain(fieldDef, scaleType2);
    if (valid) {
      return "unaggregated";
    }
  }
  return domain2;
}
function parseDomainForChannel(model, channel) {
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const { encoding } = model;
  const domain2 = normalizeUnaggregatedDomain(model.scaleDomain(channel), model.typedFieldDef(channel), scaleType2, model.config.scale);
  if (domain2 !== model.scaleDomain(channel)) {
    model.specifiedScales[channel] = Object.assign(Object.assign({}, model.specifiedScales[channel]), { domain: domain2 });
  }
  if (channel === "x" && getFieldOrDatumDef(encoding.x2)) {
    if (getFieldOrDatumDef(encoding.x)) {
      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType2, domain2, model, "x"), parseSingleChannelDomain(scaleType2, domain2, model, "x2"), "domain", "scale", domainsTieBreaker);
    } else {
      return parseSingleChannelDomain(scaleType2, domain2, model, "x2");
    }
  } else if (channel === "y" && getFieldOrDatumDef(encoding.y2)) {
    if (getFieldOrDatumDef(encoding.y)) {
      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType2, domain2, model, "y"), parseSingleChannelDomain(scaleType2, domain2, model, "y2"), "domain", "scale", domainsTieBreaker);
    } else {
      return parseSingleChannelDomain(scaleType2, domain2, model, "y2");
    }
  }
  return parseSingleChannelDomain(scaleType2, domain2, model, channel);
}
function mapDomainToDataSignal(domain2, type, timeUnit) {
  return domain2.map((v) => {
    const data = valueExpr(v, { timeUnit, type });
    return { signal: `{data: ${data}}` };
  });
}
function convertDomainIfItIsDateTime(domain2, type, timeUnit) {
  var _a;
  const normalizedTimeUnit = (_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;
  if (type === "temporal" || normalizedTimeUnit) {
    return mapDomainToDataSignal(domain2, type, normalizedTimeUnit);
  }
  return [domain2];
}
function parseSingleChannelDomain(scaleType2, domain2, model, channel) {
  const { encoding } = model;
  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
  const { type } = fieldOrDatumDef;
  const timeUnit = fieldOrDatumDef["timeUnit"];
  if (isDomainUnionWith(domain2)) {
    const defaultDomain = parseSingleChannelDomain(scaleType2, void 0, model, channel);
    const unionWith = convertDomainIfItIsDateTime(domain2.unionWith, type, timeUnit);
    return makeExplicit([...defaultDomain.value, ...unionWith]);
  } else if (isSignalRef(domain2)) {
    return makeExplicit([domain2]);
  } else if (domain2 && domain2 !== "unaggregated" && !isParameterDomain(domain2)) {
    return makeExplicit(convertDomainIfItIsDateTime(domain2, type, timeUnit));
  }
  const stack2 = model.stack;
  if (stack2 && channel === stack2.fieldChannel) {
    if (stack2.offset === "normalize") {
      return makeImplicit([[0, 1]]);
    }
    const data = model.requestDataName(DataSourceType.Main);
    return makeImplicit([
      {
        data,
        field: model.vgField(channel, { suffix: "start" })
      },
      {
        data,
        field: model.vgField(channel, { suffix: "end" })
      }
    ]);
  }
  const sort = isScaleChannel(channel) && isFieldDef(fieldOrDatumDef) ? domainSort(model, channel, scaleType2) : void 0;
  if (isDatumDef(fieldOrDatumDef)) {
    const d = convertDomainIfItIsDateTime([fieldOrDatumDef.datum], type, timeUnit);
    return makeImplicit(d);
  }
  const fieldDef = fieldOrDatumDef;
  if (domain2 === "unaggregated") {
    const data = model.requestDataName(DataSourceType.Main);
    const { field } = fieldOrDatumDef;
    return makeImplicit([
      {
        data,
        field: vgField({ field, aggregate: "min" })
      },
      {
        data,
        field: vgField({ field, aggregate: "max" })
      }
    ]);
  } else if (isBinning(fieldDef.bin)) {
    if (hasDiscreteDomain(scaleType2)) {
      if (scaleType2 === "bin-ordinal") {
        return makeImplicit([]);
      }
      return makeImplicit([
        {
          data: isBoolean3(sort) ? model.requestDataName(DataSourceType.Main) : model.requestDataName(DataSourceType.Raw),
          field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? { binSuffix: "range" } : {}),
          sort: sort === true || !isObject2(sort) ? {
            field: model.vgField(channel, {}),
            op: "min"
          } : sort
        }
      ]);
    } else {
      const { bin: bin2 } = fieldDef;
      if (isBinning(bin2)) {
        const binSignal = getBinSignalName(model, fieldDef.field, bin2);
        return makeImplicit([
          new SignalRefWrapper(() => {
            const signal = model.getSignalName(binSignal);
            return `[${signal}.start, ${signal}.stop]`;
          })
        ]);
      } else {
        return makeImplicit([
          {
            data: model.requestDataName(DataSourceType.Main),
            field: model.vgField(channel, {})
          }
        ]);
      }
    }
  } else if (fieldDef.timeUnit && contains(["time", "utc"], scaleType2) && hasBandEnd(fieldDef, isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : void 0, model.markDef, model.config)) {
    const data = model.requestDataName(DataSourceType.Main);
    return makeImplicit([
      {
        data,
        field: model.vgField(channel)
      },
      {
        data,
        field: model.vgField(channel, { suffix: "end" })
      }
    ]);
  } else if (sort) {
    return makeImplicit([
      {
        data: isBoolean3(sort) ? model.requestDataName(DataSourceType.Main) : model.requestDataName(DataSourceType.Raw),
        field: model.vgField(channel),
        sort
      }
    ]);
  } else {
    return makeImplicit([
      {
        data: model.requestDataName(DataSourceType.Main),
        field: model.vgField(channel)
      }
    ]);
  }
}
function normalizeSortField(sort, isStackedMeasure) {
  const { op, field, order } = sort;
  return Object.assign(Object.assign({
    op: op !== null && op !== void 0 ? op : isStackedMeasure ? "sum" : DEFAULT_SORT_OP
  }, field ? { field: replacePathInField(field) } : {}), order ? { order } : {});
}
function parseSelectionDomain(model, channel) {
  var _a;
  const scale = model.component.scales[channel];
  const spec = model.specifiedScales[channel].domain;
  const bin2 = (_a = model.fieldDef(channel)) === null || _a === void 0 ? void 0 : _a.bin;
  const domain2 = isParameterDomain(spec) && spec;
  const extent = isBinParams(bin2) && isParameterExtent(bin2.extent) && bin2.extent;
  if (domain2 || extent) {
    scale.set("selectionExtent", domain2 !== null && domain2 !== void 0 ? domain2 : extent, true);
  }
}
function domainSort(model, channel, scaleType2) {
  if (!hasDiscreteDomain(scaleType2)) {
    return void 0;
  }
  const fieldDef = model.fieldDef(channel);
  const sort = fieldDef.sort;
  if (isSortArray(sort)) {
    return {
      op: "min",
      field: sortArrayIndexField(fieldDef, channel),
      order: "ascending"
    };
  }
  const { stack: stack2 } = model;
  const stackDimensions = stack2 ? [...stack2.groupbyField ? [stack2.groupbyField] : [], ...stack2.stackBy.map((s) => s.fieldDef.field)] : void 0;
  if (isSortField(sort)) {
    const isStackedMeasure = stack2 && !contains(stackDimensions, sort.field);
    return normalizeSortField(sort, isStackedMeasure);
  } else if (isSortByEncoding(sort)) {
    const { encoding, order } = sort;
    const fieldDefToSortBy = model.fieldDef(encoding);
    const { aggregate, field } = fieldDefToSortBy;
    const isStackedMeasure = stack2 && !contains(stackDimensions, field);
    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {
      return normalizeSortField({
        field: vgField(fieldDefToSortBy),
        order
      }, isStackedMeasure);
    } else if (isAggregateOp(aggregate) || !aggregate) {
      return normalizeSortField({
        op: aggregate,
        field,
        order
      }, isStackedMeasure);
    }
  } else if (sort === "descending") {
    return {
      op: "min",
      field: model.vgField(channel),
      order: "descending"
    };
  } else if (contains(["ascending", void 0], sort)) {
    return true;
  }
  return void 0;
}
function canUseUnaggregatedDomain(fieldDef, scaleType2) {
  const { aggregate, type } = fieldDef;
  if (!aggregate) {
    return {
      valid: false,
      reason: message_exports.unaggregateDomainHasNoEffectForRawField(fieldDef)
    };
  }
  if (isString2(aggregate) && !SHARED_DOMAIN_OP_INDEX[aggregate]) {
    return {
      valid: false,
      reason: message_exports.unaggregateDomainWithNonSharedDomainOp(aggregate)
    };
  }
  if (type === "quantitative") {
    if (scaleType2 === "log") {
      return {
        valid: false,
        reason: message_exports.unaggregatedDomainWithLogScale(fieldDef)
      };
    }
  }
  return { valid: true };
}
function domainsTieBreaker(v1, v2, property, propertyOf) {
  if (v1.explicit && v2.explicit) {
    warn(message_exports.mergeConflictingDomainProperty(property, propertyOf, v1.value, v2.value));
  }
  return { explicit: v1.explicit, value: [...v1.value, ...v2.value] };
}
function mergeDomains(domains) {
  const uniqueDomains = unique(domains.map((domain2) => {
    if (isDataRefDomain(domain2)) {
      const { sort: _s } = domain2, domainWithoutSort = __rest23(domain2, ["sort"]);
      return domainWithoutSort;
    }
    return domain2;
  }), hash);
  const sorts = unique(domains.map((d) => {
    if (isDataRefDomain(d)) {
      const s = d.sort;
      if (s !== void 0 && !isBoolean3(s)) {
        if ("op" in s && s.op === "count") {
          delete s.field;
        }
        if (s.order === "ascending") {
          delete s.order;
        }
      }
      return s;
    }
    return void 0;
  }).filter((s) => s !== void 0), hash);
  if (uniqueDomains.length === 0) {
    return void 0;
  } else if (uniqueDomains.length === 1) {
    const domain2 = domains[0];
    if (isDataRefDomain(domain2) && sorts.length > 0) {
      let sort2 = sorts[0];
      if (sorts.length > 1) {
        warn(message_exports.MORE_THAN_ONE_SORT);
        sort2 = true;
      } else {
        if (isObject2(sort2) && "field" in sort2) {
          const sortField = sort2.field;
          if (domain2.field === sortField) {
            sort2 = sort2.order ? { order: sort2.order } : true;
          }
        }
      }
      return Object.assign(Object.assign({}, domain2), { sort: sort2 });
    }
    return domain2;
  }
  const unionDomainSorts = unique(sorts.map((s) => {
    if (isBoolean3(s) || !("op" in s) || isString2(s.op) && s.op in MULTIDOMAIN_SORT_OP_INDEX) {
      return s;
    }
    warn(message_exports.domainSortDropped(s));
    return true;
  }), hash);
  let sort;
  if (unionDomainSorts.length === 1) {
    sort = unionDomainSorts[0];
  } else if (unionDomainSorts.length > 1) {
    warn(message_exports.MORE_THAN_ONE_SORT);
    sort = true;
  }
  const allData = unique(domains.map((d) => {
    if (isDataRefDomain(d)) {
      return d.data;
    }
    return null;
  }), (x) => x);
  if (allData.length === 1 && allData[0] !== null) {
    const domain2 = Object.assign({ data: allData[0], fields: uniqueDomains.map((d) => d.field) }, sort ? { sort } : {});
    return domain2;
  }
  return Object.assign({ fields: uniqueDomains }, sort ? { sort } : {});
}
function getFieldFromDomain(domain2) {
  if (isDataRefDomain(domain2) && isString2(domain2.field)) {
    return domain2.field;
  } else if (isDataRefUnionedDomain(domain2)) {
    let field;
    for (const nonUnionDomain of domain2.fields) {
      if (isDataRefDomain(nonUnionDomain) && isString2(nonUnionDomain.field)) {
        if (!field) {
          field = nonUnionDomain.field;
        } else if (field !== nonUnionDomain.field) {
          warn(message_exports.FACETED_INDEPENDENT_DIFFERENT_SOURCES);
          return field;
        }
      }
    }
    warn(message_exports.FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES);
    return field;
  } else if (isFieldRefUnionDomain(domain2)) {
    warn(message_exports.FACETED_INDEPENDENT_SAME_SOURCE);
    const field = domain2.fields[0];
    return isString2(field) ? field : void 0;
  }
  return void 0;
}
function assembleDomain(model, channel) {
  const scaleComponent = model.component.scales[channel];
  const domains = scaleComponent.get("domains").map((domain2) => {
    if (isDataRefDomain(domain2)) {
      domain2.data = model.lookupDataSource(domain2.data);
    }
    return domain2;
  });
  return mergeDomains(domains);
}

// node_modules/vega-lite/build/src/compile/scale/assemble.js
var __rest24 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function assembleScales(model) {
  if (isLayerModel(model) || isConcatModel(model)) {
    return model.children.reduce((scales, child) => {
      return scales.concat(assembleScales(child));
    }, assembleScalesForModel(model));
  } else {
    return assembleScalesForModel(model);
  }
}
function assembleScalesForModel(model) {
  return keys(model.component.scales).reduce((scales, channel) => {
    const scaleComponent = model.component.scales[channel];
    if (scaleComponent.merged) {
      return scales;
    }
    const scale = scaleComponent.combine();
    const { name: name5, type, selectionExtent, domains: _d, range: _r, reverse: reverse2 } = scale, otherScaleProps = __rest24(scale, ["name", "type", "selectionExtent", "domains", "range", "reverse"]);
    const range2 = assembleScaleRange(scale.range, name5, channel, model);
    const domain2 = assembleDomain(model, channel);
    const domainRaw = selectionExtent ? assembleSelectionScaleDomain(model, selectionExtent, scaleComponent, domain2) : null;
    scales.push(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      name: name5,
      type
    }, domain2 ? { domain: domain2 } : {}), domainRaw ? { domainRaw } : {}), { range: range2 }), reverse2 !== void 0 ? { reverse: reverse2 } : {}), otherScaleProps));
    return scales;
  }, []);
}
function assembleScaleRange(scaleRange, scaleName, channel, model) {
  if (isXorY(channel)) {
    if (isVgRangeStep(scaleRange)) {
      return {
        step: { signal: `${scaleName}_step` }
      };
    }
  } else if (isObject2(scaleRange) && isDataRefDomain(scaleRange)) {
    return Object.assign(Object.assign({}, scaleRange), { data: model.lookupDataSource(scaleRange.data) });
  }
  return scaleRange;
}

// node_modules/vega-lite/build/src/compile/scale/component.js
var ScaleComponent = class extends Split {
  constructor(name5, typeWithExplicit) {
    super({}, { name: name5 });
    this.merged = false;
    this.setWithExplicit("type", typeWithExplicit);
  }
  domainDefinitelyIncludesZero() {
    if (this.get("zero") !== false) {
      return true;
    }
    return some(this.get("domains"), (d) => isArray2(d) && d.length === 2 && d[0] <= 0 && d[1] >= 0);
  }
};

// node_modules/vega-lite/build/src/compile/scale/range.js
var RANGE_PROPERTIES = ["range", "scheme"];
function getSizeChannel2(channel) {
  return channel === "x" ? "width" : channel === "y" ? "height" : void 0;
}
function parseUnitScaleRange(model) {
  const localScaleComponents = model.component.scales;
  for (const channel of SCALE_CHANNELS) {
    const localScaleCmpt = localScaleComponents[channel];
    if (!localScaleCmpt) {
      continue;
    }
    const rangeWithExplicit = parseRangeForChannel(channel, model);
    localScaleCmpt.setWithExplicit("range", rangeWithExplicit);
  }
}
function getBinStepSignal(model, channel) {
  const fieldDef = model.fieldDef(channel);
  if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) {
    const { bin: bin2, field } = fieldDef;
    const sizeType = getSizeChannel2(channel);
    const sizeSignal = model.getName(sizeType);
    if (isObject2(bin2) && bin2.binned && bin2.step !== void 0) {
      return new SignalRefWrapper(() => {
        const scaleName = model.scaleName(channel);
        const binCount = `(domain("${scaleName}")[1] - domain("${scaleName}")[0]) / ${bin2.step}`;
        return `${model.getSignalName(sizeSignal)} / (${binCount})`;
      });
    } else if (isBinning(bin2)) {
      const binSignal = getBinSignalName(model, field, bin2);
      return new SignalRefWrapper(() => {
        const updatedName = model.getSignalName(binSignal);
        const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;
        return `${model.getSignalName(sizeSignal)} / (${binCount})`;
      });
    }
  }
  return void 0;
}
function parseRangeForChannel(channel, model) {
  const specifiedScale = model.specifiedScales[channel];
  const { size } = model;
  const mergedScaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = mergedScaleCmpt.get("type");
  for (const property of RANGE_PROPERTIES) {
    if (specifiedScale[property] !== void 0) {
      const supportedByScaleType = scaleTypeSupportProperty(scaleType2, property);
      const channelIncompatability = channelScalePropertyIncompatability(channel, property);
      if (!supportedByScaleType) {
        warn(message_exports.scalePropertyNotWorkWithScaleType(scaleType2, property, channel));
      } else if (channelIncompatability) {
        warn(channelIncompatability);
      } else {
        switch (property) {
          case "range": {
            const range2 = specifiedScale.range;
            if (isArray2(range2)) {
              if (isXorY(channel)) {
                return makeExplicit(range2.map((v) => {
                  if (v === "width" || v === "height") {
                    const sizeSignal = model.getName(v);
                    const getSignalName = model.getSignalName.bind(model);
                    return SignalRefWrapper.fromName(getSignalName, sizeSignal);
                  }
                  return v;
                }));
              }
            } else if (isObject2(range2)) {
              return makeExplicit({
                data: model.requestDataName(DataSourceType.Main),
                field: range2.field,
                sort: { op: "min", field: model.vgField(channel) }
              });
            }
            return makeExplicit(range2);
          }
          case "scheme":
            return makeExplicit(parseScheme(specifiedScale[property]));
        }
      }
    }
  }
  if (channel === X || channel === Y) {
    const sizeChannel = channel === X ? "width" : "height";
    const sizeValue = size[sizeChannel];
    if (isStep(sizeValue)) {
      if (hasDiscreteDomain(scaleType2)) {
        return makeExplicit({ step: sizeValue.step });
      } else {
        warn(message_exports.stepDropped(sizeChannel));
      }
    }
  }
  const { rangeMin, rangeMax } = specifiedScale;
  const d = defaultRange(channel, model);
  if ((rangeMin !== void 0 || rangeMax !== void 0) && scaleTypeSupportProperty(scaleType2, "rangeMin") && isArray2(d) && d.length === 2) {
    return makeExplicit([rangeMin !== null && rangeMin !== void 0 ? rangeMin : d[0], rangeMax !== null && rangeMax !== void 0 ? rangeMax : d[1]]);
  }
  return makeImplicit(d);
}
function parseScheme(scheme) {
  if (isExtendedScheme(scheme)) {
    return Object.assign({ scheme: scheme.name }, omit(scheme, ["name"]));
  }
  return { scheme };
}
function defaultRange(channel, model) {
  const { size, config, mark: mark3, encoding } = model;
  const getSignalName = model.getSignalName.bind(model);
  const { type } = getFieldOrDatumDef(encoding[channel]);
  const mergedScaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = mergedScaleCmpt.get("type");
  const { domain: domain2, domainMid } = model.specifiedScales[channel];
  switch (channel) {
    case X:
    case Y: {
      if (contains(["point", "band"], scaleType2)) {
        if (channel === X && !size.width) {
          const w2 = getViewConfigDiscreteSize(config.view, "width");
          if (isStep(w2)) {
            return w2;
          }
        } else if (channel === Y && !size.height) {
          const h = getViewConfigDiscreteSize(config.view, "height");
          if (isStep(h)) {
            return h;
          }
        }
      }
      const sizeType = getSizeChannel2(channel);
      const sizeSignal = model.getName(sizeType);
      if (channel === Y && hasContinuousDomain(scaleType2)) {
        return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];
      } else {
        return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];
      }
    }
    case SIZE: {
      const zero2 = model.component.scales[channel].get("zero");
      const rangeMin = sizeRangeMin(mark3, zero2, config);
      const rangeMax = sizeRangeMax(mark3, size, model, config);
      if (isContinuousToDiscrete(scaleType2)) {
        return interpolateRange(rangeMin, rangeMax, defaultContinuousToDiscreteCount(scaleType2, config, domain2, channel));
      } else {
        return [rangeMin, rangeMax];
      }
    }
    case THETA:
      return [0, Math.PI * 2];
    case ANGLE:
      return [0, 360];
    case RADIUS: {
      return [
        0,
        new SignalRefWrapper(() => {
          const w2 = model.getSignalName("width");
          const h = model.getSignalName("height");
          return `min(${w2},${h})/2`;
        })
      ];
    }
    case STROKEWIDTH:
      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];
    case STROKEDASH:
      return [
        [1, 0],
        [4, 2],
        [2, 1],
        [1, 1],
        [1, 2, 4, 2]
      ];
    case SHAPE:
      return "symbol";
    case COLOR:
    case FILL:
    case STROKE:
      if (scaleType2 === "ordinal") {
        return type === "nominal" ? "category" : "ordinal";
      } else {
        if (domainMid !== void 0) {
          return "diverging";
        } else {
          return mark3 === "rect" || mark3 === "geoshape" ? "heatmap" : "ramp";
        }
      }
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
      return [config.scale.minOpacity, config.scale.maxOpacity];
  }
  throw new Error(`Scale range undefined for channel ${channel}`);
}
function defaultContinuousToDiscreteCount(scaleType2, config, domain2, channel) {
  switch (scaleType2) {
    case "quantile":
      return config.scale.quantileCount;
    case "quantize":
      return config.scale.quantizeCount;
    case "threshold":
      if (domain2 !== void 0 && isArray2(domain2)) {
        return domain2.length + 1;
      } else {
        warn(message_exports.domainRequiredForThresholdScale(channel));
        return 3;
      }
  }
}
function interpolateRange(rangeMin, rangeMax, cardinality) {
  const f = () => {
    const rMax = signalOrStringValue(rangeMax);
    const rMin = signalOrStringValue(rangeMin);
    const step = `(${rMax} - ${rMin}) / (${cardinality} - 1)`;
    return `sequence(${rMin}, ${rMax} + ${step}, ${step})`;
  };
  if (isSignalRef(rangeMax)) {
    return new SignalRefWrapper(f);
  } else {
    return { signal: f() };
  }
}
function sizeRangeMin(mark3, zero2, config) {
  if (zero2) {
    if (isSignalRef(zero2)) {
      return { signal: `${zero2.signal} ? 0 : ${sizeRangeMin(mark3, false, config)}` };
    } else {
      return 0;
    }
  }
  switch (mark3) {
    case "bar":
    case "tick":
      return config.scale.minBandSize;
    case "line":
    case "trail":
    case "rule":
      return config.scale.minStrokeWidth;
    case "text":
      return config.scale.minFontSize;
    case "point":
    case "square":
    case "circle":
      return config.scale.minSize;
  }
  throw new Error(message_exports.incompatibleChannel("size", mark3));
}
var MAX_SIZE_RANGE_STEP_RATIO = 0.95;
function sizeRangeMax(mark3, size, model, config) {
  const xyStepSignals = {
    x: getBinStepSignal(model, "x"),
    y: getBinStepSignal(model, "y")
  };
  switch (mark3) {
    case "bar":
    case "tick": {
      if (config.scale.maxBandSize !== void 0) {
        return config.scale.maxBandSize;
      }
      const min = minXYStep(size, xyStepSignals, config.view);
      if (isNumber(min)) {
        return min - 1;
      } else {
        return new SignalRefWrapper(() => `${min.signal} - 1`);
      }
    }
    case "line":
    case "trail":
    case "rule":
      return config.scale.maxStrokeWidth;
    case "text":
      return config.scale.maxFontSize;
    case "point":
    case "square":
    case "circle": {
      if (config.scale.maxSize) {
        return config.scale.maxSize;
      }
      const pointStep = minXYStep(size, xyStepSignals, config.view);
      if (isNumber(pointStep)) {
        return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);
      } else {
        return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);
      }
    }
  }
  throw new Error(message_exports.incompatibleChannel("size", mark3));
}
function minXYStep(size, xyStepSignals, viewConfig) {
  const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, "width");
  const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, "height");
  if (xyStepSignals.x || xyStepSignals.y) {
    return new SignalRefWrapper(() => {
      const exprs = [
        xyStepSignals.x ? xyStepSignals.x.signal : widthStep,
        xyStepSignals.y ? xyStepSignals.y.signal : heightStep
      ];
      return `min(${exprs.join(", ")})`;
    });
  }
  return Math.min(widthStep, heightStep);
}

// node_modules/vega-lite/build/src/compile/scale/properties.js
function parseScaleProperty(model, property) {
  if (isUnitModel(model)) {
    parseUnitScaleProperty(model, property);
  } else {
    parseNonUnitScaleProperty(model, property);
  }
}
function parseUnitScaleProperty(model, property) {
  const localScaleComponents = model.component.scales;
  const { config, encoding, markDef, specifiedScales } = model;
  for (const channel of keys(localScaleComponents)) {
    const specifiedScale = specifiedScales[channel];
    const localScaleCmpt = localScaleComponents[channel];
    const mergedScaleCmpt = model.getScaleComponent(channel);
    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
    const specifiedValue = specifiedScale[property];
    const scaleType2 = mergedScaleCmpt.get("type");
    const scalePadding = mergedScaleCmpt.get("padding");
    const scalePaddingInner = mergedScaleCmpt.get("paddingInner");
    const supportedByScaleType = scaleTypeSupportProperty(scaleType2, property);
    const channelIncompatability = channelScalePropertyIncompatability(channel, property);
    if (specifiedValue !== void 0) {
      if (!supportedByScaleType) {
        warn(message_exports.scalePropertyNotWorkWithScaleType(scaleType2, property, channel));
      } else if (channelIncompatability) {
        warn(channelIncompatability);
      }
    }
    if (supportedByScaleType && channelIncompatability === void 0) {
      if (specifiedValue !== void 0) {
        const timeUnit = fieldOrDatumDef["timeUnit"];
        const type = fieldOrDatumDef.type;
        switch (property) {
          case "domainMax":
          case "domainMin":
            if (isDateTime(specifiedScale[property]) || type === "temporal" || timeUnit) {
              localScaleCmpt.set(property, { signal: valueExpr(specifiedScale[property], { type, timeUnit }) }, true);
            } else {
              localScaleCmpt.set(property, specifiedScale[property], true);
            }
            break;
          default:
            localScaleCmpt.copyKeyFromObject(property, specifiedScale);
        }
      } else {
        const value = property in scaleRules ? scaleRules[property]({
          model,
          channel,
          fieldOrDatumDef,
          scaleType: scaleType2,
          scalePadding,
          scalePaddingInner,
          domain: specifiedScale.domain,
          markDef,
          config
        }) : config.scale[property];
        if (value !== void 0) {
          localScaleCmpt.set(property, value, false);
        }
      }
    }
  }
}
var scaleRules = {
  bins: ({ model, fieldOrDatumDef }) => isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : void 0,
  interpolate: ({ channel, fieldOrDatumDef }) => interpolate(channel, fieldOrDatumDef.type),
  nice: ({ scaleType: scaleType2, channel, domain: domain2, fieldOrDatumDef }) => nice(scaleType2, channel, domain2, fieldOrDatumDef),
  padding: ({ channel, scaleType: scaleType2, fieldOrDatumDef, markDef, config }) => padding(channel, scaleType2, config.scale, fieldOrDatumDef, markDef, config.bar),
  paddingInner: ({ scalePadding, channel, markDef, config }) => paddingInner(scalePadding, channel, markDef.type, config.scale),
  paddingOuter: ({ scalePadding, channel, scaleType: scaleType2, markDef, scalePaddingInner, config }) => paddingOuter(scalePadding, channel, scaleType2, markDef.type, scalePaddingInner, config.scale),
  reverse: ({ fieldOrDatumDef, scaleType: scaleType2, channel, config }) => {
    const sort = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : void 0;
    return reverse(scaleType2, sort, channel, config.scale);
  },
  zero: ({ channel, fieldOrDatumDef, domain: domain2, markDef, scaleType: scaleType2 }) => zero(channel, fieldOrDatumDef, domain2, markDef, scaleType2)
};
function parseScaleRange(model) {
  if (isUnitModel(model)) {
    parseUnitScaleRange(model);
  } else {
    parseNonUnitScaleProperty(model, "range");
  }
}
function parseNonUnitScaleProperty(model, property) {
  const localScaleComponents = model.component.scales;
  for (const child of model.children) {
    if (property === "range") {
      parseScaleRange(child);
    } else {
      parseScaleProperty(child, property);
    }
  }
  for (const channel of keys(localScaleComponents)) {
    let valueWithExplicit;
    for (const child of model.children) {
      const childComponent = child.component.scales[channel];
      if (childComponent) {
        const childValueWithExplicit = childComponent.getWithExplicit(property);
        valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property, "scale", tieBreakByComparing((v1, v2) => {
          switch (property) {
            case "range":
              if (v1.step && v2.step) {
                return v1.step - v2.step;
              }
              return 0;
          }
          return 0;
        }));
      }
    }
    localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);
  }
}
function bins(model, fieldDef) {
  const bin2 = fieldDef.bin;
  if (isBinning(bin2)) {
    const binSignal = getBinSignalName(model, fieldDef.field, bin2);
    return new SignalRefWrapper(() => {
      return model.getSignalName(binSignal);
    });
  } else if (isBinned(bin2) && isBinParams(bin2) && bin2.step !== void 0) {
    return {
      step: bin2.step
    };
  }
  return void 0;
}
function interpolate(channel, type) {
  if (contains([COLOR, FILL, STROKE], channel) && type !== "nominal") {
    return "hcl";
  }
  return void 0;
}
function nice(scaleType2, channel, specifiedDomain, fieldOrDatumDef) {
  var _a;
  if (((_a = getFieldDef(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.bin) || isArray2(specifiedDomain) || contains([ScaleType.TIME, ScaleType.UTC], scaleType2)) {
    return void 0;
  }
  return channel in POSITION_SCALE_CHANNEL_INDEX ? true : void 0;
}
function padding(channel, scaleType2, scaleConfig, fieldOrDatumDef, markDef, barConfig) {
  if (channel in POSITION_SCALE_CHANNEL_INDEX) {
    if (isContinuousToContinuous(scaleType2)) {
      if (scaleConfig.continuousPadding !== void 0) {
        return scaleConfig.continuousPadding;
      }
      const { type, orient: orient2 } = markDef;
      if (type === "bar" && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {
        if (orient2 === "vertical" && channel === "x" || orient2 === "horizontal" && channel === "y") {
          return barConfig.continuousBandSize;
        }
      }
    }
    if (scaleType2 === ScaleType.POINT) {
      return scaleConfig.pointPadding;
    }
  }
  return void 0;
}
function paddingInner(paddingValue, channel, mark3, scaleConfig) {
  if (paddingValue !== void 0) {
    return void 0;
  }
  if (channel in POSITION_SCALE_CHANNEL_INDEX) {
    const { bandPaddingInner, barBandPaddingInner, rectBandPaddingInner } = scaleConfig;
    return getFirstDefined(bandPaddingInner, mark3 === "bar" ? barBandPaddingInner : rectBandPaddingInner);
  }
  return void 0;
}
function paddingOuter(paddingValue, channel, scaleType2, mark3, paddingInnerValue, scaleConfig) {
  if (paddingValue !== void 0) {
    return void 0;
  }
  if (channel in POSITION_SCALE_CHANNEL_INDEX) {
    if (scaleType2 === ScaleType.BAND) {
      const { bandPaddingOuter } = scaleConfig;
      return getFirstDefined(bandPaddingOuter, isSignalRef(paddingInnerValue) ? { signal: `${paddingInnerValue.signal}/2` } : paddingInnerValue / 2);
    }
  }
  return void 0;
}
function reverse(scaleType2, sort, channel, scaleConfig) {
  if (channel === "x" && scaleConfig.xReverse !== void 0) {
    if (hasContinuousDomain(scaleType2) && sort === "descending") {
      if (isSignalRef(scaleConfig.xReverse)) {
        return { signal: `!${scaleConfig.xReverse.signal}` };
      } else {
        return !scaleConfig.xReverse;
      }
    }
    return scaleConfig.xReverse;
  }
  if (hasContinuousDomain(scaleType2) && sort === "descending") {
    return true;
  }
  return void 0;
}
function zero(channel, fieldDef, specifiedDomain, markDef, scaleType2) {
  const hasCustomDomain = !!specifiedDomain && specifiedDomain !== "unaggregated";
  if (hasCustomDomain) {
    if (hasContinuousDomain(scaleType2)) {
      if (isArray2(specifiedDomain)) {
        const first = specifiedDomain[0];
        const last = specifiedDomain[specifiedDomain.length - 1];
        if (first <= 0 && last >= 0) {
          return true;
        }
      }
      return false;
    }
  }
  if (channel === "size" && fieldDef.type === "quantitative" && !isContinuousToDiscrete(scaleType2)) {
    return true;
  }
  if (!(isFieldDef(fieldDef) && fieldDef.bin) && contains([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)) {
    const { orient: orient2, type } = markDef;
    if (contains(["bar", "area", "line", "trail"], type)) {
      if (orient2 === "horizontal" && channel === "y" || orient2 === "vertical" && channel === "x") {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/vega-lite/build/src/compile/scale/type.js
function scaleType(specifiedScale, channel, fieldDef, mark3) {
  const defaultScaleType = defaultType3(channel, fieldDef, mark3);
  const { type } = specifiedScale;
  if (!isScaleChannel(channel)) {
    return null;
  }
  if (type !== void 0) {
    if (!channelSupportScaleType(channel, type)) {
      warn(message_exports.scaleTypeNotWorkWithChannel(channel, type, defaultScaleType));
      return defaultScaleType;
    }
    if (isFieldDef(fieldDef) && !scaleTypeSupportDataType(type, fieldDef.type)) {
      warn(message_exports.scaleTypeNotWorkWithFieldDef(type, defaultScaleType));
      return defaultScaleType;
    }
    return type;
  }
  return defaultScaleType;
}
function defaultType3(channel, fieldDef, mark3) {
  var _a;
  switch (fieldDef.type) {
    case "nominal":
    case "ordinal": {
      if (isColorChannel(channel) || rangeType(channel) === "discrete") {
        if (channel === "shape" && fieldDef.type === "ordinal") {
          warn(message_exports.discreteChannelCannotEncode(channel, "ordinal"));
        }
        return "ordinal";
      }
      if (channel in POSITION_SCALE_CHANNEL_INDEX) {
        if (contains(["rect", "bar", "image", "rule"], mark3.type)) {
          return "band";
        }
      } else if (mark3.type === "arc" && channel in POLAR_POSITION_SCALE_CHANNEL_INDEX) {
        return "band";
      }
      const dimensionSize = mark3[getSizeChannel(channel)];
      if (isRelativeBandSize(dimensionSize)) {
        return "band";
      }
      if (isPositionFieldOrDatumDef(fieldDef) && ((_a = fieldDef.axis) === null || _a === void 0 ? void 0 : _a.tickBand)) {
        return "band";
      }
      return "point";
    }
    case "temporal":
      if (isColorChannel(channel)) {
        return "time";
      } else if (rangeType(channel) === "discrete") {
        warn(message_exports.discreteChannelCannotEncode(channel, "temporal"));
        return "ordinal";
      } else if (isFieldDef(fieldDef) && fieldDef.timeUnit && normalizeTimeUnit(fieldDef.timeUnit).utc) {
        return "utc";
      }
      return "time";
    case "quantitative":
      if (isColorChannel(channel)) {
        if (isFieldDef(fieldDef) && isBinning(fieldDef.bin)) {
          return "bin-ordinal";
        }
        return "linear";
      } else if (rangeType(channel) === "discrete") {
        warn(message_exports.discreteChannelCannotEncode(channel, "quantitative"));
        return "ordinal";
      }
      return "linear";
    case "geojson":
      return void 0;
  }
  throw new Error(message_exports.invalidFieldType(fieldDef.type));
}

// node_modules/vega-lite/build/src/compile/scale/parse.js
function parseScales(model, { ignoreRange } = {}) {
  parseScaleCore(model);
  parseScaleDomain(model);
  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {
    parseScaleProperty(model, prop);
  }
  if (!ignoreRange) {
    parseScaleRange(model);
  }
}
function parseScaleCore(model) {
  if (isUnitModel(model)) {
    model.component.scales = parseUnitScaleCore(model);
  } else {
    model.component.scales = parseNonUnitScaleCore(model);
  }
}
function parseUnitScaleCore(model) {
  const { encoding, mark: mark3, markDef } = model;
  return SCALE_CHANNELS.reduce((scaleComponents, channel) => {
    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
    if (fieldOrDatumDef && mark3 === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {
      return scaleComponents;
    }
    let specifiedScale = fieldOrDatumDef && fieldOrDatumDef["scale"];
    if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {
      specifiedScale !== null && specifiedScale !== void 0 ? specifiedScale : specifiedScale = {};
      const sType = scaleType(specifiedScale, channel, fieldOrDatumDef, markDef);
      scaleComponents[channel] = new ScaleComponent(model.scaleName(`${channel}`, true), {
        value: sType,
        explicit: specifiedScale.type === sType
      });
    }
    return scaleComponents;
  }, {});
}
var scaleTypeTieBreaker = tieBreakByComparing((st1, st2) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2));
function parseNonUnitScaleCore(model) {
  var _a;
  var _b;
  const scaleComponents = model.component.scales = {};
  const scaleTypeWithExplicitIndex = {};
  const resolve = model.component.resolve;
  for (const child of model.children) {
    parseScaleCore(child);
    for (const channel of keys(child.component.scales)) {
      (_a = (_b = resolve.scale)[channel]) !== null && _a !== void 0 ? _a : _b[channel] = defaultScaleResolve(channel, model);
      if (resolve.scale[channel] === "shared") {
        const explicitScaleType = scaleTypeWithExplicitIndex[channel];
        const childScaleType = child.component.scales[channel].getWithExplicit("type");
        if (explicitScaleType) {
          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {
            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, "type", "scale", scaleTypeTieBreaker);
          } else {
            resolve.scale[channel] = "independent";
            delete scaleTypeWithExplicitIndex[channel];
          }
        } else {
          scaleTypeWithExplicitIndex[channel] = childScaleType;
        }
      }
    }
  }
  for (const channel of keys(scaleTypeWithExplicitIndex)) {
    const name5 = model.scaleName(channel, true);
    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];
    scaleComponents[channel] = new ScaleComponent(name5, typeWithExplicit);
    for (const child of model.children) {
      const childScale = child.component.scales[channel];
      if (childScale) {
        child.renameScale(childScale.get("name"), name5);
        childScale.merged = true;
      }
    }
  }
  return scaleComponents;
}

// node_modules/vega-lite/build/src/compile/model.js
var __rest25 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var NameMap = class {
  constructor() {
    this.nameMap = {};
  }
  rename(oldName, newName) {
    this.nameMap[oldName] = newName;
  }
  has(name5) {
    return this.nameMap[name5] !== void 0;
  }
  get(name5) {
    while (this.nameMap[name5] && name5 !== this.nameMap[name5]) {
      name5 = this.nameMap[name5];
    }
    return name5;
  }
};
function isUnitModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "unit";
}
function isFacetModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "facet";
}
function isConcatModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "concat";
}
function isLayerModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "layer";
}
var Model = class {
  constructor(spec, type, parent, parentGivenName, config, resolve, view) {
    var _a, _b;
    this.type = type;
    this.parent = parent;
    this.config = config;
    this.correctDataNames = (mark3) => {
      var _a2, _b2, _c;
      if ((_a2 = mark3.from) === null || _a2 === void 0 ? void 0 : _a2.data) {
        mark3.from.data = this.lookupDataSource(mark3.from.data);
      }
      if ((_c = (_b2 = mark3.from) === null || _b2 === void 0 ? void 0 : _b2.facet) === null || _c === void 0 ? void 0 : _c.data) {
        mark3.from.facet.data = this.lookupDataSource(mark3.from.facet.data);
      }
      return mark3;
    };
    this.parent = parent;
    this.config = config;
    this.view = replaceExprRef(view);
    this.name = (_a = spec.name) !== null && _a !== void 0 ? _a : parentGivenName;
    this.title = isText(spec.title) ? { text: spec.title } : spec.title ? replaceExprRef(spec.title) : void 0;
    this.scaleNameMap = parent ? parent.scaleNameMap : new NameMap();
    this.projectionNameMap = parent ? parent.projectionNameMap : new NameMap();
    this.signalNameMap = parent ? parent.signalNameMap : new NameMap();
    this.data = spec.data;
    this.description = spec.description;
    this.transforms = normalizeTransform((_b = spec.transform) !== null && _b !== void 0 ? _b : []);
    this.layout = type === "layer" || type === "unit" ? {} : extractCompositionLayout(spec, type, config);
    this.component = {
      data: {
        sources: parent ? parent.component.data.sources : [],
        outputNodes: parent ? parent.component.data.outputNodes : {},
        outputNodeRefCounts: parent ? parent.component.data.outputNodeRefCounts : {},
        isFaceted: isFacetSpec(spec) || parent && parent.component.data.isFaceted && spec.data === void 0
      },
      layoutSize: new Split(),
      layoutHeaders: { row: {}, column: {}, facet: {} },
      mark: null,
      resolve: Object.assign({ scale: {}, axis: {}, legend: {} }, resolve ? duplicate(resolve) : {}),
      selection: null,
      scales: null,
      projection: null,
      axes: {},
      legends: {}
    };
  }
  get width() {
    return this.getSizeSignalRef("width");
  }
  get height() {
    return this.getSizeSignalRef("height");
  }
  parse() {
    this.parseScale();
    this.parseLayoutSize();
    this.renameTopLevelLayoutSizeSignal();
    this.parseSelections();
    this.parseProjection();
    this.parseData();
    this.parseAxesAndHeaders();
    this.parseLegends();
    this.parseMarkGroup();
  }
  parseScale() {
    parseScales(this);
  }
  parseProjection() {
    parseProjection(this);
  }
  renameTopLevelLayoutSizeSignal() {
    if (this.getName("width") !== "width") {
      this.renameSignal(this.getName("width"), "width");
    }
    if (this.getName("height") !== "height") {
      this.renameSignal(this.getName("height"), "height");
    }
  }
  parseLegends() {
    parseLegend(this);
  }
  assembleEncodeFromView(view) {
    const { style: _ } = view, baseView = __rest25(view, ["style"]);
    const e2 = {};
    for (const property of keys(baseView)) {
      const value = baseView[property];
      if (value !== void 0) {
        e2[property] = signalOrValueRef(value);
      }
    }
    return e2;
  }
  assembleGroupEncodeEntry(isTopLevel) {
    let encodeEntry2 = {};
    if (this.view) {
      encodeEntry2 = this.assembleEncodeFromView(this.view);
    }
    if (!isTopLevel) {
      if (this.description) {
        encodeEntry2["description"] = signalOrValueRef(this.description);
      }
      if (this.type === "unit" || this.type === "layer") {
        return Object.assign({ width: this.getSizeSignalRef("width"), height: this.getSizeSignalRef("height") }, encodeEntry2 !== null && encodeEntry2 !== void 0 ? encodeEntry2 : {});
      }
    }
    return isEmpty(encodeEntry2) ? void 0 : encodeEntry2;
  }
  assembleLayout() {
    if (!this.layout) {
      return void 0;
    }
    const _a = this.layout, { spacing } = _a, layout = __rest25(_a, ["spacing"]);
    const { component, config } = this;
    const titleBand = assembleLayoutTitleBand(component.layoutHeaders, config);
    return Object.assign(Object.assign(Object.assign({ padding: spacing }, this.assembleDefaultLayout()), layout), titleBand ? { titleBand } : {});
  }
  assembleDefaultLayout() {
    return {};
  }
  assembleHeaderMarks() {
    const { layoutHeaders } = this.component;
    let headerMarks = [];
    for (const channel of FACET_CHANNELS) {
      if (layoutHeaders[channel].title) {
        headerMarks.push(assembleTitleGroup(this, channel));
      }
    }
    for (const channel of HEADER_CHANNELS) {
      headerMarks = headerMarks.concat(assembleHeaderGroups(this, channel));
    }
    return headerMarks;
  }
  assembleAxes() {
    return assembleAxes(this.component.axes, this.config);
  }
  assembleLegends() {
    return assembleLegends(this);
  }
  assembleProjections() {
    return assembleProjections(this);
  }
  assembleTitle() {
    var _a, _b, _c;
    const _d = (_a = this.title) !== null && _a !== void 0 ? _a : {}, { encoding } = _d, titleNoEncoding = __rest25(_d, ["encoding"]);
    const title2 = Object.assign(Object.assign(Object.assign({}, extractTitleConfig(this.config.title).nonMarkTitleProperties), titleNoEncoding), encoding ? { encode: { update: encoding } } : {});
    if (title2.text) {
      if (contains(["unit", "layer"], this.type)) {
        if (contains(["middle", void 0], title2.anchor)) {
          (_b = title2.frame) !== null && _b !== void 0 ? _b : title2.frame = "group";
        }
      } else {
        (_c = title2.anchor) !== null && _c !== void 0 ? _c : title2.anchor = "start";
      }
      return isEmpty(title2) ? void 0 : title2;
    }
    return void 0;
  }
  assembleGroup(signals = []) {
    const group = {};
    signals = signals.concat(this.assembleSignals());
    if (signals.length > 0) {
      group.signals = signals;
    }
    const layout = this.assembleLayout();
    if (layout) {
      group.layout = layout;
    }
    group.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
    const scales = !this.parent || isFacetModel(this.parent) ? assembleScales(this) : [];
    if (scales.length > 0) {
      group.scales = scales;
    }
    const axes = this.assembleAxes();
    if (axes.length > 0) {
      group.axes = axes;
    }
    const legends = this.assembleLegends();
    if (legends.length > 0) {
      group.legends = legends;
    }
    return group;
  }
  getName(text3) {
    return varName((this.name ? `${this.name}_` : "") + text3);
  }
  getDataName(type) {
    return this.getName(DataSourceType[type].toLowerCase());
  }
  requestDataName(name5) {
    const fullName = this.getDataName(name5);
    const refCounts = this.component.data.outputNodeRefCounts;
    refCounts[fullName] = (refCounts[fullName] || 0) + 1;
    return fullName;
  }
  getSizeSignalRef(layoutSizeType) {
    if (isFacetModel(this.parent)) {
      const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);
      const channel = getPositionScaleChannel(sizeType);
      const scaleComponent = this.component.scales[channel];
      if (scaleComponent && !scaleComponent.merged) {
        const type = scaleComponent.get("type");
        const range2 = scaleComponent.get("range");
        if (hasDiscreteDomain(type) && isVgRangeStep(range2)) {
          const scaleName = scaleComponent.get("name");
          const domain2 = assembleDomain(this, channel);
          const field = getFieldFromDomain(domain2);
          if (field) {
            const fieldRef = vgField({ aggregate: "distinct", field }, { expr: "datum" });
            return {
              signal: sizeExpr(scaleName, scaleComponent, fieldRef)
            };
          } else {
            warn(message_exports.unknownField(channel));
            return null;
          }
        }
      }
    }
    return {
      signal: this.signalNameMap.get(this.getName(layoutSizeType))
    };
  }
  lookupDataSource(name5) {
    const node = this.component.data.outputNodes[name5];
    if (!node) {
      return name5;
    }
    return node.getSource();
  }
  getSignalName(oldSignalName) {
    return this.signalNameMap.get(oldSignalName);
  }
  renameSignal(oldName, newName) {
    this.signalNameMap.rename(oldName, newName);
  }
  renameScale(oldName, newName) {
    this.scaleNameMap.rename(oldName, newName);
  }
  renameProjection(oldName, newName) {
    this.projectionNameMap.rename(oldName, newName);
  }
  scaleName(originalScaleName, parse) {
    if (parse) {
      return this.getName(originalScaleName);
    }
    if (isChannel(originalScaleName) && isScaleChannel(originalScaleName) && this.component.scales[originalScaleName] || this.scaleNameMap.has(this.getName(originalScaleName))) {
      return this.scaleNameMap.get(this.getName(originalScaleName));
    }
    return void 0;
  }
  projectionName(parse) {
    if (parse) {
      return this.getName("projection");
    }
    if (this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection"))) {
      return this.projectionNameMap.get(this.getName("projection"));
    }
    return void 0;
  }
  getScaleComponent(channel) {
    if (!this.component.scales) {
      throw new Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
    }
    const localScaleComponent = this.component.scales[channel];
    if (localScaleComponent && !localScaleComponent.merged) {
      return localScaleComponent;
    }
    return this.parent ? this.parent.getScaleComponent(channel) : void 0;
  }
  getSelectionComponent(variableName, origName) {
    let sel = this.component.selection[variableName];
    if (!sel && this.parent) {
      sel = this.parent.getSelectionComponent(variableName, origName);
    }
    if (!sel) {
      throw new Error(message_exports.selectionNotFound(origName));
    }
    return sel;
  }
  hasAxisOrientSignalRef() {
    var _a, _b;
    return ((_a = this.component.axes.x) === null || _a === void 0 ? void 0 : _a.some((a) => a.hasOrientSignalRef())) || ((_b = this.component.axes.y) === null || _b === void 0 ? void 0 : _b.some((a) => a.hasOrientSignalRef()));
  }
};
var ModelWithField = class extends Model {
  vgField(channel, opt = {}) {
    const fieldDef = this.fieldDef(channel);
    if (!fieldDef) {
      return void 0;
    }
    return vgField(fieldDef, opt);
  }
  reduceFieldDef(f, init) {
    return reduce(this.getMapping(), (acc, cd, c) => {
      const fieldDef = getFieldDef(cd);
      if (fieldDef) {
        return f(acc, fieldDef, c);
      }
      return acc;
    }, init);
  }
  forEachFieldDef(f, t2) {
    forEach(this.getMapping(), (cd, c) => {
      const fieldDef = getFieldDef(cd);
      if (fieldDef) {
        f(fieldDef, c);
      }
    }, t2);
  }
};

// node_modules/vega-lite/build/src/compile/data/density.js
var __rest26 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var DensityTransformNode = class extends DataFlowNode {
  constructor(parent, transform) {
    var _a, _b, _c;
    super(parent);
    this.transform = transform;
    this.transform = duplicate(transform);
    const specifiedAs = (_a = this.transform.as) !== null && _a !== void 0 ? _a : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : "value", (_c = specifiedAs[1]) !== null && _c !== void 0 ? _c : "density"];
  }
  clone() {
    return new DensityTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a;
    return new Set([this.transform.density, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `DensityTransform ${hash(this.transform)}`;
  }
  assemble() {
    const _a = this.transform, { density } = _a, rest = __rest26(_a, ["density"]);
    const result = Object.assign({ type: "kde", field: density }, rest);
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/filterinvalid.js
var FilterInvalidNode = class extends DataFlowNode {
  constructor(parent, filter) {
    super(parent);
    this.filter = filter;
  }
  clone() {
    return new FilterInvalidNode(null, Object.assign({}, this.filter));
  }
  static make(parent, model) {
    const { config, mark: mark3, markDef } = model;
    const invalid = getMarkPropOrConfig("invalid", markDef, config);
    if (invalid !== "filter") {
      return null;
    }
    const filter = model.reduceFieldDef((aggregator, fieldDef, channel) => {
      const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);
      if (scaleComponent) {
        const scaleType2 = scaleComponent.get("type");
        if (hasContinuousDomain(scaleType2) && fieldDef.aggregate !== "count" && !isPathMark(mark3)) {
          aggregator[fieldDef.field] = fieldDef;
        }
      }
      return aggregator;
    }, {});
    if (!keys(filter).length) {
      return null;
    }
    return new FilterInvalidNode(parent, filter);
  }
  dependentFields() {
    return new Set(keys(this.filter));
  }
  producedFields() {
    return new Set();
  }
  hash() {
    return `FilterInvalid ${hash(this.filter)}`;
  }
  assemble() {
    const filters = keys(this.filter).reduce((vegaFilters, field) => {
      const fieldDef = this.filter[field];
      const ref5 = vgField(fieldDef, { expr: "datum" });
      if (fieldDef !== null) {
        if (fieldDef.type === "temporal") {
          vegaFilters.push(`(isDate(${ref5}) || (isValid(${ref5}) && isFinite(+${ref5})))`);
        } else if (fieldDef.type === "quantitative") {
          vegaFilters.push(`isValid(${ref5})`);
          vegaFilters.push(`isFinite(+${ref5})`);
        } else {
        }
      }
      return vegaFilters;
    }, []);
    return filters.length > 0 ? {
      type: "filter",
      expr: filters.join(" && ")
    } : null;
  }
};

// node_modules/vega-lite/build/src/compile/data/flatten.js
var FlattenTransformNode = class extends DataFlowNode {
  constructor(parent, transform) {
    super(parent);
    this.transform = transform;
    this.transform = duplicate(transform);
    const { flatten, as = [] } = this.transform;
    this.transform.as = flatten.map((f, i) => {
      var _a;
      return (_a = as[i]) !== null && _a !== void 0 ? _a : f;
    });
  }
  clone() {
    return new FlattenTransformNode(this.parent, duplicate(this.transform));
  }
  dependentFields() {
    return new Set(this.transform.flatten);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FlattenTransform ${hash(this.transform)}`;
  }
  assemble() {
    const { flatten: fields, as } = this.transform;
    const result = {
      type: "flatten",
      fields,
      as
    };
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/fold.js
var FoldTransformNode = class extends DataFlowNode {
  constructor(parent, transform) {
    var _a, _b, _c;
    super(parent);
    this.transform = transform;
    this.transform = duplicate(transform);
    const specifiedAs = (_a = this.transform.as) !== null && _a !== void 0 ? _a : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : "key", (_c = specifiedAs[1]) !== null && _c !== void 0 ? _c : "value"];
  }
  clone() {
    return new FoldTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    return new Set(this.transform.fold);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FoldTransform ${hash(this.transform)}`;
  }
  assemble() {
    const { fold, as } = this.transform;
    const result = {
      type: "fold",
      fields: fold,
      as
    };
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/geojson.js
var GeoJSONNode = class extends DataFlowNode {
  constructor(parent, fields, geojson, signal) {
    super(parent);
    this.fields = fields;
    this.geojson = geojson;
    this.signal = signal;
  }
  clone() {
    return new GeoJSONNode(null, duplicate(this.fields), this.geojson, this.signal);
  }
  static parseAll(parent, model) {
    if (model.component.projection && !model.component.projection.isFit) {
      return parent;
    }
    let geoJsonCounter = 0;
    for (const coordinates of [
      [LONGITUDE, LATITUDE],
      [LONGITUDE2, LATITUDE2]
    ]) {
      const pair = coordinates.map((channel) => {
        const def = getFieldOrDatumDef(model.encoding[channel]);
        return isFieldDef(def) ? def.field : isDatumDef(def) ? { expr: `${def.datum}` } : isValueDef(def) ? { expr: `${def["value"]}` } : void 0;
      });
      if (pair[0] || pair[1]) {
        parent = new GeoJSONNode(parent, pair, null, model.getName(`geojson_${geoJsonCounter++}`));
      }
    }
    if (model.channelHasField(SHAPE)) {
      const fieldDef = model.typedFieldDef(SHAPE);
      if (fieldDef.type === GEOJSON) {
        parent = new GeoJSONNode(parent, null, fieldDef.field, model.getName(`geojson_${geoJsonCounter++}`));
      }
    }
    return parent;
  }
  dependentFields() {
    var _a;
    const fields = ((_a = this.fields) !== null && _a !== void 0 ? _a : []).filter(isString2);
    return new Set([...this.geojson ? [this.geojson] : [], ...fields]);
  }
  producedFields() {
    return new Set();
  }
  hash() {
    return `GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`;
  }
  assemble() {
    return [
      ...this.geojson ? [
        {
          type: "filter",
          expr: `isValid(datum["${this.geojson}"])`
        }
      ] : [],
      Object.assign(Object.assign(Object.assign({ type: "geojson" }, this.fields ? { fields: this.fields } : {}), this.geojson ? { geojson: this.geojson } : {}), { signal: this.signal })
    ];
  }
};

// node_modules/vega-lite/build/src/compile/data/geopoint.js
var GeoPointNode = class extends DataFlowNode {
  constructor(parent, projection, fields, as) {
    super(parent);
    this.projection = projection;
    this.fields = fields;
    this.as = as;
  }
  clone() {
    return new GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));
  }
  static parseAll(parent, model) {
    if (!model.projectionName()) {
      return parent;
    }
    for (const coordinates of [
      [LONGITUDE, LATITUDE],
      [LONGITUDE2, LATITUDE2]
    ]) {
      const pair = coordinates.map((channel) => {
        const def = getFieldOrDatumDef(model.encoding[channel]);
        return isFieldDef(def) ? def.field : isDatumDef(def) ? { expr: `${def.datum}` } : isValueDef(def) ? { expr: `${def["value"]}` } : void 0;
      });
      const suffix = coordinates[0] === LONGITUDE2 ? "2" : "";
      if (pair[0] || pair[1]) {
        parent = new GeoPointNode(parent, model.projectionName(), pair, [
          model.getName(`x${suffix}`),
          model.getName(`y${suffix}`)
        ]);
      }
    }
    return parent;
  }
  dependentFields() {
    return new Set(this.fields.filter(isString2));
  }
  producedFields() {
    return new Set(this.as);
  }
  hash() {
    return `Geopoint ${this.projection} ${hash(this.fields)} ${hash(this.as)}`;
  }
  assemble() {
    return {
      type: "geopoint",
      projection: this.projection,
      fields: this.fields,
      as: this.as
    };
  }
};

// node_modules/vega-lite/build/src/compile/data/impute.js
var ImputeNode = class extends DataFlowNode {
  constructor(parent, transform) {
    super(parent);
    this.transform = transform;
  }
  clone() {
    return new ImputeNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a;
    return new Set([this.transform.impute, this.transform.key, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  producedFields() {
    return new Set([this.transform.impute]);
  }
  processSequence(keyvals) {
    const { start = 0, stop: stop2, step } = keyvals;
    const result = [start, stop2, ...step ? [step] : []].join(",");
    return { signal: `sequence(${result})` };
  }
  static makeFromTransform(parent, imputeTransform) {
    return new ImputeNode(parent, imputeTransform);
  }
  static makeFromEncoding(parent, model) {
    const encoding = model.encoding;
    const xDef = encoding.x;
    const yDef = encoding.y;
    if (isFieldDef(xDef) && isFieldDef(yDef)) {
      const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : void 0;
      if (imputedChannel === void 0) {
        return void 0;
      }
      const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : void 0;
      const { method, value, frame, keyvals } = imputedChannel.impute;
      const groupbyFields = pathGroupingFields(model.mark, encoding);
      return new ImputeNode(parent, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ impute: imputedChannel.field, key: keyChannel.field }, method ? { method } : {}), value !== void 0 ? { value } : {}), frame ? { frame } : {}), keyvals !== void 0 ? { keyvals } : {}), groupbyFields.length ? { groupby: groupbyFields } : {}));
    }
    return null;
  }
  hash() {
    return `Impute ${hash(this.transform)}`;
  }
  assemble() {
    const { impute, key, keyvals, method, groupby, value, frame = [null, null] } = this.transform;
    const imputeTransform = Object.assign(Object.assign(Object.assign(Object.assign({ type: "impute", field: impute, key }, keyvals ? { keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals } : {}), { method: "value" }), groupby ? { groupby } : {}), { value: !method || method === "value" ? value : null });
    if (method && method !== "value") {
      const deriveNewField = Object.assign({ type: "window", as: [`imputed_${impute}_value`], ops: [method], fields: [impute], frame, ignorePeers: false }, groupby ? { groupby } : {});
      const replaceOriginal = {
        type: "formula",
        expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,
        as: impute
      };
      return [imputeTransform, deriveNewField, replaceOriginal];
    } else {
      return [imputeTransform];
    }
  }
};

// node_modules/vega-lite/build/src/compile/data/loess.js
var __rest27 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var LoessTransformNode = class extends DataFlowNode {
  constructor(parent, transform) {
    var _a, _b, _c;
    super(parent);
    this.transform = transform;
    this.transform = duplicate(transform);
    const specifiedAs = (_a = this.transform.as) !== null && _a !== void 0 ? _a : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : transform.on, (_c = specifiedAs[1]) !== null && _c !== void 0 ? _c : transform.loess];
  }
  clone() {
    return new LoessTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a;
    return new Set([this.transform.loess, this.transform.on, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `LoessTransform ${hash(this.transform)}`;
  }
  assemble() {
    const _a = this.transform, { loess, on } = _a, rest = __rest27(_a, ["loess", "on"]);
    const result = Object.assign({ type: "loess", x: on, y: loess }, rest);
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/lookup.js
var LookupNode = class extends DataFlowNode {
  constructor(parent, transform, secondary) {
    super(parent);
    this.transform = transform;
    this.secondary = secondary;
  }
  clone() {
    return new LookupNode(null, duplicate(this.transform), this.secondary);
  }
  static make(parent, model, transform, counter) {
    const sources = model.component.data.sources;
    const { from } = transform;
    let fromOutputNode = null;
    if (isLookupData(from)) {
      let fromSource = findSource(from.data, sources);
      if (!fromSource) {
        fromSource = new SourceNode(from.data);
        sources.push(fromSource);
      }
      const fromOutputName = model.getName(`lookup_${counter}`);
      fromOutputNode = new OutputNode(fromSource, fromOutputName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);
      model.component.data.outputNodes[fromOutputName] = fromOutputNode;
    } else if (isLookupSelection(from)) {
      const selName = from.param;
      transform = Object.assign({ as: selName }, transform);
      let selCmpt;
      try {
        selCmpt = model.getSelectionComponent(varName(selName), selName);
      } catch (e2) {
        throw new Error(message_exports.cannotLookupVariableParameter(selName));
      }
      fromOutputNode = selCmpt.materialized;
      if (!fromOutputNode) {
        throw new Error(message_exports.noSameUnitLookup(selName));
      }
    }
    return new LookupNode(parent, transform, fromOutputNode.getSource());
  }
  dependentFields() {
    return new Set([this.transform.lookup]);
  }
  producedFields() {
    return new Set(this.transform.as ? array(this.transform.as) : this.transform.from.fields);
  }
  hash() {
    return `Lookup ${hash({ transform: this.transform, secondary: this.secondary })}`;
  }
  assemble() {
    let foreign;
    if (this.transform.from.fields) {
      foreign = Object.assign({ values: this.transform.from.fields }, this.transform.as ? { as: array(this.transform.as) } : {});
    } else {
      let asName = this.transform.as;
      if (!isString2(asName)) {
        warn(message_exports.NO_FIELDS_NEEDS_AS);
        asName = "_lookup";
      }
      foreign = {
        as: [asName]
      };
    }
    return Object.assign(Object.assign({ type: "lookup", from: this.secondary, key: this.transform.from.key, fields: [this.transform.lookup] }, foreign), this.transform.default ? { default: this.transform.default } : {});
  }
};

// node_modules/vega-lite/build/src/compile/data/quantile.js
var __rest28 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var QuantileTransformNode = class extends DataFlowNode {
  constructor(parent, transform) {
    var _a, _b, _c;
    super(parent);
    this.transform = transform;
    this.transform = duplicate(transform);
    const specifiedAs = (_a = this.transform.as) !== null && _a !== void 0 ? _a : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : "prob", (_c = specifiedAs[1]) !== null && _c !== void 0 ? _c : "value"];
  }
  clone() {
    return new QuantileTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a;
    return new Set([this.transform.quantile, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `QuantileTransform ${hash(this.transform)}`;
  }
  assemble() {
    const _a = this.transform, { quantile } = _a, rest = __rest28(_a, ["quantile"]);
    const result = Object.assign({ type: "quantile", field: quantile }, rest);
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/regression.js
var __rest29 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
var RegressionTransformNode = class extends DataFlowNode {
  constructor(parent, transform) {
    var _a, _b, _c;
    super(parent);
    this.transform = transform;
    this.transform = duplicate(transform);
    const specifiedAs = (_a = this.transform.as) !== null && _a !== void 0 ? _a : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : transform.on, (_c = specifiedAs[1]) !== null && _c !== void 0 ? _c : transform.regression];
  }
  clone() {
    return new RegressionTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a;
    return new Set([this.transform.regression, this.transform.on, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `RegressionTransform ${hash(this.transform)}`;
  }
  assemble() {
    const _a = this.transform, { regression, on } = _a, rest = __rest29(_a, ["regression", "on"]);
    const result = Object.assign({ type: "regression", x: on, y: regression }, rest);
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/pivot.js
var PivotTransformNode = class extends DataFlowNode {
  constructor(parent, transform) {
    super(parent);
    this.transform = transform;
  }
  clone() {
    return new PivotTransformNode(null, duplicate(this.transform));
  }
  addDimensions(fields) {
    var _a;
    this.transform.groupby = unique(((_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []).concat(fields), (d) => d);
  }
  producedFields() {
    return void 0;
  }
  dependentFields() {
    var _a;
    return new Set([this.transform.pivot, this.transform.value, ...(_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []]);
  }
  hash() {
    return `PivotTransform ${hash(this.transform)}`;
  }
  assemble() {
    const { pivot, value, groupby, limit, op } = this.transform;
    return Object.assign(Object.assign(Object.assign({ type: "pivot", field: pivot, value }, limit !== void 0 ? { limit } : {}), op !== void 0 ? { op } : {}), groupby !== void 0 ? { groupby } : {});
  }
};

// node_modules/vega-lite/build/src/compile/data/sample.js
var SampleTransformNode = class extends DataFlowNode {
  constructor(parent, transform) {
    super(parent);
    this.transform = transform;
  }
  clone() {
    return new SampleTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {
    return new Set();
  }
  hash() {
    return `SampleTransform ${hash(this.transform)}`;
  }
  assemble() {
    return {
      type: "sample",
      size: this.transform.sample
    };
  }
};

// node_modules/vega-lite/build/src/compile/data/assemble.js
function makeWalkTree(data) {
  let datasetIndex = 0;
  function walkTree(node, dataSource) {
    var _a;
    if (node instanceof SourceNode) {
      if (!node.isGenerator && !isUrlData(node.data)) {
        data.push(dataSource);
        const newData = {
          name: null,
          source: dataSource.name,
          transform: []
        };
        dataSource = newData;
      }
    }
    if (node instanceof ParseNode) {
      if (node.parent instanceof SourceNode && !dataSource.source) {
        dataSource.format = Object.assign(Object.assign({}, (_a = dataSource.format) !== null && _a !== void 0 ? _a : {}), { parse: node.assembleFormatParse() });
        dataSource.transform.push(...node.assembleTransforms(true));
      } else {
        dataSource.transform.push(...node.assembleTransforms());
      }
    }
    if (node instanceof FacetNode) {
      if (!dataSource.name) {
        dataSource.name = `data_${datasetIndex++}`;
      }
      if (!dataSource.source || dataSource.transform.length > 0) {
        data.push(dataSource);
        node.data = dataSource.name;
      } else {
        node.data = dataSource.source;
      }
      data.push(...node.assemble());
      return;
    }
    if (node instanceof GraticuleNode || node instanceof SequenceNode || node instanceof FilterInvalidNode || node instanceof FilterNode || node instanceof CalculateNode || node instanceof GeoPointNode || node instanceof AggregateNode || node instanceof LookupNode || node instanceof WindowTransformNode || node instanceof JoinAggregateTransformNode || node instanceof FoldTransformNode || node instanceof FlattenTransformNode || node instanceof DensityTransformNode || node instanceof LoessTransformNode || node instanceof QuantileTransformNode || node instanceof RegressionTransformNode || node instanceof IdentifierNode || node instanceof SampleTransformNode || node instanceof PivotTransformNode) {
      dataSource.transform.push(node.assemble());
    }
    if (node instanceof BinNode || node instanceof TimeUnitNode || node instanceof ImputeNode || node instanceof StackNode || node instanceof GeoJSONNode) {
      dataSource.transform.push(...node.assemble());
    }
    if (node instanceof OutputNode) {
      if (dataSource.source && dataSource.transform.length === 0) {
        node.setSource(dataSource.source);
      } else if (node.parent instanceof OutputNode) {
        node.setSource(dataSource.name);
      } else {
        if (!dataSource.name) {
          dataSource.name = `data_${datasetIndex++}`;
        }
        node.setSource(dataSource.name);
        if (node.numChildren() === 1) {
          data.push(dataSource);
          const newData = {
            name: null,
            source: dataSource.name,
            transform: []
          };
          dataSource = newData;
        }
      }
    }
    switch (node.numChildren()) {
      case 0:
        if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {
          data.push(dataSource);
        }
        break;
      case 1:
        walkTree(node.children[0], dataSource);
        break;
      default: {
        if (!dataSource.name) {
          dataSource.name = `data_${datasetIndex++}`;
        }
        let source2 = dataSource.name;
        if (!dataSource.source || dataSource.transform.length > 0) {
          data.push(dataSource);
        } else {
          source2 = dataSource.source;
        }
        for (const child of node.children) {
          const newData = {
            name: null,
            source: source2,
            transform: []
          };
          walkTree(child, newData);
        }
        break;
      }
    }
  }
  return walkTree;
}
function assembleFacetData(root) {
  const data = [];
  const walkTree = makeWalkTree(data);
  for (const child of root.children) {
    walkTree(child, {
      source: root.name,
      name: null,
      transform: []
    });
  }
  return data;
}
function assembleRootData(dataComponent, datasets) {
  var _a, _b;
  const data = [];
  const walkTree = makeWalkTree(data);
  let sourceIndex = 0;
  for (const root of dataComponent.sources) {
    if (!root.hasName()) {
      root.dataName = `source_${sourceIndex++}`;
    }
    const newData = root.assemble();
    walkTree(root, newData);
  }
  for (const d of data) {
    if (d.transform.length === 0) {
      delete d.transform;
    }
  }
  let whereTo = 0;
  for (const [i, d] of data.entries()) {
    if (((_a = d.transform) !== null && _a !== void 0 ? _a : []).length === 0 && !d.source) {
      data.splice(whereTo++, 0, data.splice(i, 1)[0]);
    }
  }
  for (const d of data) {
    for (const t2 of (_b = d.transform) !== null && _b !== void 0 ? _b : []) {
      if (t2.type === "lookup") {
        t2.from = dataComponent.outputNodes[t2.from].getSource();
      }
    }
  }
  for (const d of data) {
    if (d.name in datasets) {
      d.values = datasets[d.name];
    }
  }
  return data;
}

// node_modules/vega-lite/build/src/compile/header/parse.js
function getHeaderType(orient2) {
  if (orient2 === "top" || orient2 === "left" || isSignalRef(orient2)) {
    return "header";
  }
  return "footer";
}
function parseFacetHeaders(model) {
  for (const channel of FACET_CHANNELS) {
    parseFacetHeader(model, channel);
  }
  mergeChildAxis(model, "x");
  mergeChildAxis(model, "y");
}
function parseFacetHeader(model, channel) {
  var _a;
  const { facet, config, child, component } = model;
  if (model.channelHasField(channel)) {
    const fieldDef = facet[channel];
    const titleConfig = getHeaderProperty("title", null, config, channel);
    let title2 = title(fieldDef, config, {
      allowDisabling: true,
      includeDefault: titleConfig === void 0 || !!titleConfig
    });
    if (child.component.layoutHeaders[channel].title) {
      title2 = isArray2(title2) ? title2.join(", ") : title2;
      title2 += ` / ${child.component.layoutHeaders[channel].title}`;
      child.component.layoutHeaders[channel].title = null;
    }
    const labelOrient = getHeaderProperty("labelOrient", fieldDef.header, config, channel);
    const labels3 = fieldDef.header !== null ? getFirstDefined((_a = fieldDef.header) === null || _a === void 0 ? void 0 : _a.labels, config.header.labels, true) : false;
    const headerType = contains(["bottom", "right"], labelOrient) ? "footer" : "header";
    component.layoutHeaders[channel] = {
      title: fieldDef.header !== null ? title2 : null,
      facetFieldDef: fieldDef,
      [headerType]: channel === "facet" ? [] : [makeHeaderComponent(model, channel, labels3)]
    };
  }
}
function makeHeaderComponent(model, channel, labels3) {
  const sizeType = channel === "row" ? "height" : "width";
  return {
    labels: labels3,
    sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : void 0,
    axes: []
  };
}
function mergeChildAxis(model, channel) {
  var _a;
  const { child } = model;
  if (child.component.axes[channel]) {
    const { layoutHeaders, resolve } = model.component;
    resolve.axis[channel] = parseGuideResolve(resolve, channel);
    if (resolve.axis[channel] === "shared") {
      const headerChannel = channel === "x" ? "column" : "row";
      const layoutHeader = layoutHeaders[headerChannel];
      for (const axisComponent of child.component.axes[channel]) {
        const headerType = getHeaderType(axisComponent.get("orient"));
        (_a = layoutHeader[headerType]) !== null && _a !== void 0 ? _a : layoutHeader[headerType] = [makeHeaderComponent(model, headerChannel, false)];
        const mainAxis = assembleAxis(axisComponent, "main", model.config, { header: true });
        if (mainAxis) {
          layoutHeader[headerType][0].axes.push(mainAxis);
        }
        axisComponent.mainExtracted = true;
      }
    } else {
    }
  }
}

// node_modules/vega-lite/build/src/compile/layoutsize/parse.js
function parseLayerLayoutSize(model) {
  parseChildrenLayoutSize(model);
  parseNonUnitLayoutSizeForChannel(model, "width");
  parseNonUnitLayoutSizeForChannel(model, "height");
}
function parseConcatLayoutSize(model) {
  parseChildrenLayoutSize(model);
  const widthType = model.layout.columns === 1 ? "width" : "childWidth";
  const heightType = model.layout.columns === void 0 ? "height" : "childHeight";
  parseNonUnitLayoutSizeForChannel(model, widthType);
  parseNonUnitLayoutSizeForChannel(model, heightType);
}
function parseChildrenLayoutSize(model) {
  for (const child of model.children) {
    child.parseLayoutSize();
  }
}
function parseNonUnitLayoutSizeForChannel(model, layoutSizeType) {
  var _a;
  const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);
  const channel = getPositionScaleChannel(sizeType);
  const resolve = model.component.resolve;
  const layoutSizeCmpt = model.component.layoutSize;
  let mergedSize;
  for (const child of model.children) {
    const childSize = child.component.layoutSize.getWithExplicit(sizeType);
    const scaleResolve = (_a = resolve.scale[channel]) !== null && _a !== void 0 ? _a : defaultScaleResolve(channel, model);
    if (scaleResolve === "independent" && childSize.value === "step") {
      mergedSize = void 0;
      break;
    }
    if (mergedSize) {
      if (scaleResolve === "independent" && mergedSize.value !== childSize.value) {
        mergedSize = void 0;
        break;
      }
      mergedSize = mergeValuesWithExplicit(mergedSize, childSize, sizeType, "");
    } else {
      mergedSize = childSize;
    }
  }
  if (mergedSize) {
    for (const child of model.children) {
      model.renameSignal(child.getName(sizeType), model.getName(layoutSizeType));
      child.component.layoutSize.set(sizeType, "merged", false);
    }
    layoutSizeCmpt.setWithExplicit(layoutSizeType, mergedSize);
  } else {
    layoutSizeCmpt.setWithExplicit(layoutSizeType, {
      explicit: false,
      value: void 0
    });
  }
}
function parseUnitLayoutSize(model) {
  const { size, component } = model;
  for (const channel of POSITION_SCALE_CHANNELS) {
    const sizeType = getSizeChannel(channel);
    if (size[sizeType]) {
      const specifiedSize = size[sizeType];
      component.layoutSize.set(sizeType, isStep(specifiedSize) ? "step" : specifiedSize, true);
    } else {
      const defaultSize2 = defaultUnitSize(model, sizeType);
      component.layoutSize.set(sizeType, defaultSize2, false);
    }
  }
}
function defaultUnitSize(model, sizeType) {
  const channel = sizeType === "width" ? "x" : "y";
  const config = model.config;
  const scaleComponent = model.getScaleComponent(channel);
  if (scaleComponent) {
    const scaleType2 = scaleComponent.get("type");
    const range2 = scaleComponent.get("range");
    if (hasDiscreteDomain(scaleType2)) {
      const size = getViewConfigDiscreteSize(config.view, sizeType);
      if (isVgRangeStep(range2) || isStep(size)) {
        return "step";
      } else {
        return size;
      }
    } else {
      return getViewConfigContinuousSize(config.view, sizeType);
    }
  } else if (model.hasProjection || model.mark === "arc") {
    return getViewConfigContinuousSize(config.view, sizeType);
  } else {
    const size = getViewConfigDiscreteSize(config.view, sizeType);
    return isStep(size) ? size.step : size;
  }
}

// node_modules/vega-lite/build/src/compile/facet.js
function facetSortFieldName(fieldDef, sort, opt) {
  return vgField(sort, Object.assign({ suffix: `by_${vgField(fieldDef)}` }, opt !== null && opt !== void 0 ? opt : {}));
}
var FacetModel = class extends ModelWithField {
  constructor(spec, parent, parentGivenName, config) {
    super(spec, "facet", parent, parentGivenName, config, spec.resolve);
    this.child = buildModel(spec.spec, this, this.getName("child"), void 0, config);
    this.children = [this.child];
    this.facet = this.initFacet(spec.facet);
  }
  initFacet(facet) {
    if (!isFacetMapping(facet)) {
      return { facet: this.initFacetFieldDef(facet, "facet") };
    }
    const channels = keys(facet);
    const normalizedFacet = {};
    for (const channel of channels) {
      if (![ROW, COLUMN].includes(channel)) {
        warn(message_exports.incompatibleChannel(channel, "facet"));
        break;
      }
      const fieldDef = facet[channel];
      if (fieldDef.field === void 0) {
        warn(message_exports.emptyFieldDef(fieldDef, channel));
        break;
      }
      normalizedFacet[channel] = this.initFacetFieldDef(fieldDef, channel);
    }
    return normalizedFacet;
  }
  initFacetFieldDef(fieldDef, channel) {
    const facetFieldDef = initFieldDef(fieldDef, channel);
    if (facetFieldDef.header) {
      facetFieldDef.header = replaceExprRef(facetFieldDef.header);
    } else if (facetFieldDef.header === null) {
      facetFieldDef.header = null;
    }
    return facetFieldDef;
  }
  channelHasField(channel) {
    return !!this.facet[channel];
  }
  fieldDef(channel) {
    return this.facet[channel];
  }
  parseData() {
    this.component.data = parseData(this);
    this.child.parseData();
  }
  parseLayoutSize() {
    parseChildrenLayoutSize(this);
  }
  parseSelections() {
    this.child.parseSelections();
    this.component.selection = this.child.component.selection;
  }
  parseMarkGroup() {
    this.child.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    this.child.parseAxesAndHeaders();
    parseFacetHeaders(this);
  }
  assembleSelectionTopLevelSignals(signals) {
    return this.child.assembleSelectionTopLevelSignals(signals);
  }
  assembleSignals() {
    this.child.assembleSignals();
    return [];
  }
  assembleSelectionData(data) {
    return this.child.assembleSelectionData(data);
  }
  getHeaderLayoutMixins() {
    var _a, _b, _c;
    const layoutMixins = {};
    for (const channel of FACET_CHANNELS) {
      for (const headerType of HEADER_TYPES) {
        const layoutHeaderComponent = this.component.layoutHeaders[channel];
        const headerComponent = layoutHeaderComponent[headerType];
        const { facetFieldDef } = layoutHeaderComponent;
        if (facetFieldDef) {
          const titleOrient = getHeaderProperty("titleOrient", facetFieldDef.header, this.config, channel);
          if (["right", "bottom"].includes(titleOrient)) {
            const headerChannel = getHeaderChannel(channel, titleOrient);
            (_a = layoutMixins.titleAnchor) !== null && _a !== void 0 ? _a : layoutMixins.titleAnchor = {};
            layoutMixins.titleAnchor[headerChannel] = "end";
          }
        }
        if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent[0]) {
          const sizeType = channel === "row" ? "height" : "width";
          const bandType = headerType === "header" ? "headerBand" : "footerBand";
          if (channel !== "facet" && !this.child.component.layoutSize.get(sizeType)) {
            (_b = layoutMixins[bandType]) !== null && _b !== void 0 ? _b : layoutMixins[bandType] = {};
            layoutMixins[bandType][channel] = 0.5;
          }
          if (layoutHeaderComponent.title) {
            (_c = layoutMixins.offset) !== null && _c !== void 0 ? _c : layoutMixins.offset = {};
            layoutMixins.offset[channel === "row" ? "rowTitle" : "columnTitle"] = 10;
          }
        }
      }
    }
    return layoutMixins;
  }
  assembleDefaultLayout() {
    const { column, row } = this.facet;
    const columns = column ? this.columnDistinctSignal() : row ? 1 : void 0;
    let align2 = "all";
    if (!row && this.component.resolve.scale.x === "independent") {
      align2 = "none";
    } else if (!column && this.component.resolve.scale.y === "independent") {
      align2 = "none";
    }
    return Object.assign(Object.assign(Object.assign({}, this.getHeaderLayoutMixins()), columns ? { columns } : {}), { bounds: "full", align: align2 });
  }
  assembleLayoutSignals() {
    return this.child.assembleLayoutSignals();
  }
  columnDistinctSignal() {
    if (this.parent && this.parent instanceof FacetModel) {
      return void 0;
    } else {
      const facetLayoutDataName = this.getName("column_domain");
      return { signal: `length(data('${facetLayoutDataName}'))` };
    }
  }
  assembleGroupStyle() {
    return void 0;
  }
  assembleGroup(signals) {
    if (this.parent && this.parent instanceof FacetModel) {
      return Object.assign(Object.assign({}, this.channelHasField("column") ? {
        encode: {
          update: {
            columns: { field: vgField(this.facet.column, { prefix: "distinct" }) }
          }
        }
      } : {}), super.assembleGroup(signals));
    }
    return super.assembleGroup(signals);
  }
  getCardinalityAggregateForChild() {
    const fields = [];
    const ops = [];
    const as = [];
    if (this.child instanceof FacetModel) {
      if (this.child.channelHasField("column")) {
        const field = vgField(this.child.facet.column);
        fields.push(field);
        ops.push("distinct");
        as.push(`distinct_${field}`);
      }
    } else {
      for (const channel of POSITION_SCALE_CHANNELS) {
        const childScaleComponent = this.child.component.scales[channel];
        if (childScaleComponent && !childScaleComponent.merged) {
          const type = childScaleComponent.get("type");
          const range2 = childScaleComponent.get("range");
          if (hasDiscreteDomain(type) && isVgRangeStep(range2)) {
            const domain2 = assembleDomain(this.child, channel);
            const field = getFieldFromDomain(domain2);
            if (field) {
              fields.push(field);
              ops.push("distinct");
              as.push(`distinct_${field}`);
            } else {
              warn(message_exports.unknownField(channel));
            }
          }
        }
      }
    }
    return { fields, ops, as };
  }
  assembleFacet() {
    const { name: name5, data } = this.component.data.facetRoot;
    const { row, column } = this.facet;
    const { fields, ops, as } = this.getCardinalityAggregateForChild();
    const groupby = [];
    for (const channel of FACET_CHANNELS) {
      const fieldDef = this.facet[channel];
      if (fieldDef) {
        groupby.push(vgField(fieldDef));
        const { bin: bin2, sort } = fieldDef;
        if (isBinning(bin2)) {
          groupby.push(vgField(fieldDef, { binSuffix: "end" }));
        }
        if (isSortField(sort)) {
          const { field, op = DEFAULT_SORT_OP } = sort;
          const outputName = facetSortFieldName(fieldDef, sort);
          if (row && column) {
            fields.push(outputName);
            ops.push("max");
            as.push(outputName);
          } else {
            fields.push(field);
            ops.push(op);
            as.push(outputName);
          }
        } else if (isArray2(sort)) {
          const outputName = sortArrayIndexField(fieldDef, channel);
          fields.push(outputName);
          ops.push("max");
          as.push(outputName);
        }
      }
    }
    const cross = !!row && !!column;
    return Object.assign({
      name: name5,
      data,
      groupby
    }, cross || fields.length > 0 ? {
      aggregate: Object.assign(Object.assign({}, cross ? { cross } : {}), fields.length ? { fields, ops, as } : {})
    } : {});
  }
  facetSortFields(channel) {
    const { facet } = this;
    const fieldDef = facet[channel];
    if (fieldDef) {
      if (isSortField(fieldDef.sort)) {
        return [facetSortFieldName(fieldDef, fieldDef.sort, { expr: "datum" })];
      } else if (isArray2(fieldDef.sort)) {
        return [sortArrayIndexField(fieldDef, channel, { expr: "datum" })];
      }
      return [vgField(fieldDef, { expr: "datum" })];
    }
    return [];
  }
  facetSortOrder(channel) {
    const { facet } = this;
    const fieldDef = facet[channel];
    if (fieldDef) {
      const { sort } = fieldDef;
      const order = (isSortField(sort) ? sort.order : !isArray2(sort) && sort) || "ascending";
      return [order];
    }
    return [];
  }
  assembleLabelTitle() {
    var _a;
    const { facet, config } = this;
    if (facet.facet) {
      return assembleLabelTitle(facet.facet, "facet", config);
    }
    const ORTHOGONAL_ORIENT = {
      row: ["top", "bottom"],
      column: ["left", "right"]
    };
    for (const channel of HEADER_CHANNELS) {
      if (facet[channel]) {
        const labelOrient = getHeaderProperty("labelOrient", (_a = facet[channel]) === null || _a === void 0 ? void 0 : _a.header, config, channel);
        if (ORTHOGONAL_ORIENT[channel].includes(labelOrient)) {
          return assembleLabelTitle(facet[channel], channel, config);
        }
      }
    }
    return void 0;
  }
  assembleMarks() {
    const { child } = this;
    const facetRoot = this.component.data.facetRoot;
    const data = assembleFacetData(facetRoot);
    const encodeEntry2 = child.assembleGroupEncodeEntry(false);
    const title2 = this.assembleLabelTitle() || child.assembleTitle();
    const style = child.assembleGroupStyle();
    const markGroup = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: this.getName("cell"), type: "group" }, title2 ? { title: title2 } : {}), style ? { style } : {}), {
      from: {
        facet: this.assembleFacet()
      },
      sort: {
        field: FACET_CHANNELS.map((c) => this.facetSortFields(c)).flat(),
        order: FACET_CHANNELS.map((c) => this.facetSortOrder(c)).flat()
      }
    }), data.length > 0 ? { data } : {}), encodeEntry2 ? { encode: { update: encodeEntry2 } } : {}), child.assembleGroup(assembleFacetSignals(this, [])));
    return [markGroup];
  }
  getMapping() {
    return this.facet;
  }
};

// node_modules/vega-lite/build/src/compile/data/joinaggregatefacet.js
function makeJoinAggregateFromFacet(parent, facet) {
  const { row, column } = facet;
  if (row && column) {
    let newParent = null;
    for (const fieldDef of [row, column]) {
      if (isSortField(fieldDef.sort)) {
        const { field, op = DEFAULT_SORT_OP } = fieldDef.sort;
        parent = newParent = new JoinAggregateTransformNode(parent, {
          joinaggregate: [
            {
              op,
              field,
              as: facetSortFieldName(fieldDef, fieldDef.sort, { forAs: true })
            }
          ],
          groupby: [vgField(fieldDef)]
        });
      }
    }
    return newParent;
  }
  return null;
}

// node_modules/vega-lite/build/src/compile/data/parse.js
function findSource(data, sources) {
  var _a, _b, _c, _d;
  for (const other of sources) {
    const otherData = other.data;
    if (data.name && other.hasName() && data.name !== other.dataName) {
      continue;
    }
    const formatMesh = (_a = data["format"]) === null || _a === void 0 ? void 0 : _a.mesh;
    const otherFeature = (_b = otherData.format) === null || _b === void 0 ? void 0 : _b.feature;
    if (formatMesh && otherFeature) {
      continue;
    }
    const formatFeature = (_c = data["format"]) === null || _c === void 0 ? void 0 : _c.feature;
    if ((formatFeature || otherFeature) && formatFeature !== otherFeature) {
      continue;
    }
    const otherMesh = (_d = otherData.format) === null || _d === void 0 ? void 0 : _d.mesh;
    if ((formatMesh || otherMesh) && formatMesh !== otherMesh) {
      continue;
    }
    if (isInlineData(data) && isInlineData(otherData)) {
      if (deepEqual(data.values, otherData.values)) {
        return other;
      }
    } else if (isUrlData(data) && isUrlData(otherData)) {
      if (data.url === otherData.url) {
        return other;
      }
    } else if (isNamedData(data)) {
      if (data.name === other.dataName) {
        return other;
      }
    }
  }
  return null;
}
function parseRoot(model, sources) {
  if (model.data || !model.parent) {
    if (model.data === null) {
      const source2 = new SourceNode({ values: [] });
      sources.push(source2);
      return source2;
    }
    const existingSource = findSource(model.data, sources);
    if (existingSource) {
      if (!isGenerator(model.data)) {
        existingSource.data.format = mergeDeep({}, model.data.format, existingSource.data.format);
      }
      if (!existingSource.hasName() && model.data.name) {
        existingSource.dataName = model.data.name;
      }
      return existingSource;
    } else {
      const source2 = new SourceNode(model.data);
      sources.push(source2);
      return source2;
    }
  } else {
    return model.parent.component.data.facetRoot ? model.parent.component.data.facetRoot : model.parent.component.data.main;
  }
}
function parseTransformArray(head, model, ancestorParse) {
  var _a, _b;
  let lookupCounter = 0;
  for (const t2 of model.transforms) {
    let derivedType = void 0;
    let transformNode;
    if (isCalculate(t2)) {
      transformNode = head = new CalculateNode(head, t2);
      derivedType = "derived";
    } else if (isFilter(t2)) {
      const implicit = getImplicitFromFilterTransform(t2);
      transformNode = head = (_a = ParseNode.makeWithAncestors(head, {}, implicit, ancestorParse)) !== null && _a !== void 0 ? _a : head;
      head = new FilterNode(head, model, t2.filter);
    } else if (isBin(t2)) {
      transformNode = head = BinNode.makeFromTransform(head, t2, model);
      derivedType = "number";
    } else if (isTimeUnit(t2)) {
      derivedType = "date";
      const parsedAs = ancestorParse.getWithExplicit(t2.field);
      if (parsedAs.value === void 0) {
        head = new ParseNode(head, { [t2.field]: derivedType });
        ancestorParse.set(t2.field, derivedType, false);
      }
      transformNode = head = TimeUnitNode.makeFromTransform(head, t2);
    } else if (isAggregate2(t2)) {
      transformNode = head = AggregateNode.makeFromTransform(head, t2);
      derivedType = "number";
      if (requiresSelectionId(model)) {
        head = new IdentifierNode(head);
      }
    } else if (isLookup(t2)) {
      transformNode = head = LookupNode.make(head, model, t2, lookupCounter++);
      derivedType = "derived";
    } else if (isWindow(t2)) {
      transformNode = head = new WindowTransformNode(head, t2);
      derivedType = "number";
    } else if (isJoinAggregate(t2)) {
      transformNode = head = new JoinAggregateTransformNode(head, t2);
      derivedType = "number";
    } else if (isStack(t2)) {
      transformNode = head = StackNode.makeFromTransform(head, t2);
      derivedType = "derived";
    } else if (isFold(t2)) {
      transformNode = head = new FoldTransformNode(head, t2);
      derivedType = "derived";
    } else if (isFlatten(t2)) {
      transformNode = head = new FlattenTransformNode(head, t2);
      derivedType = "derived";
    } else if (isPivot(t2)) {
      transformNode = head = new PivotTransformNode(head, t2);
      derivedType = "derived";
    } else if (isSample(t2)) {
      head = new SampleTransformNode(head, t2);
    } else if (isImpute(t2)) {
      transformNode = head = ImputeNode.makeFromTransform(head, t2);
      derivedType = "derived";
    } else if (isDensity(t2)) {
      transformNode = head = new DensityTransformNode(head, t2);
      derivedType = "derived";
    } else if (isQuantile(t2)) {
      transformNode = head = new QuantileTransformNode(head, t2);
      derivedType = "derived";
    } else if (isRegression(t2)) {
      transformNode = head = new RegressionTransformNode(head, t2);
      derivedType = "derived";
    } else if (isLoess(t2)) {
      transformNode = head = new LoessTransformNode(head, t2);
      derivedType = "derived";
    } else {
      warn(message_exports.invalidTransformIgnored(t2));
      continue;
    }
    if (transformNode && derivedType !== void 0) {
      for (const field of (_b = transformNode.producedFields()) !== null && _b !== void 0 ? _b : []) {
        ancestorParse.set(field, derivedType, false);
      }
    }
  }
  return head;
}
function parseData(model) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
  let head = parseRoot(model, model.component.data.sources);
  const { outputNodes, outputNodeRefCounts } = model.component.data;
  const data = model.data;
  const newData = data && (isGenerator(data) || isUrlData(data) || isInlineData(data));
  const ancestorParse = !newData && model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();
  if (isGenerator(data)) {
    if (isSequenceGenerator(data)) {
      head = new SequenceNode(head, data.sequence);
    } else if (isGraticuleGenerator(data)) {
      head = new GraticuleNode(head, data.graticule);
    }
    ancestorParse.parseNothing = true;
  } else if (((_a = data === null || data === void 0 ? void 0 : data.format) === null || _a === void 0 ? void 0 : _a.parse) === null) {
    ancestorParse.parseNothing = true;
  }
  head = (_b = ParseNode.makeExplicit(head, model, ancestorParse)) !== null && _b !== void 0 ? _b : head;
  head = new IdentifierNode(head);
  const parentIsLayer = model.parent && isLayerModel(model.parent);
  if (isUnitModel(model) || isFacetModel(model)) {
    if (parentIsLayer) {
      head = (_c = BinNode.makeFromEncoding(head, model)) !== null && _c !== void 0 ? _c : head;
    }
  }
  if (model.transforms.length > 0) {
    head = parseTransformArray(head, model, ancestorParse);
  }
  const implicitSelection = getImplicitFromSelection(model);
  const implicitEncoding = getImplicitFromEncoding(model);
  head = (_d = ParseNode.makeWithAncestors(head, {}, Object.assign(Object.assign({}, implicitSelection), implicitEncoding), ancestorParse)) !== null && _d !== void 0 ? _d : head;
  if (isUnitModel(model)) {
    head = GeoJSONNode.parseAll(head, model);
    head = GeoPointNode.parseAll(head, model);
  }
  if (isUnitModel(model) || isFacetModel(model)) {
    if (!parentIsLayer) {
      head = (_e = BinNode.makeFromEncoding(head, model)) !== null && _e !== void 0 ? _e : head;
    }
    head = (_f = TimeUnitNode.makeFromEncoding(head, model)) !== null && _f !== void 0 ? _f : head;
    head = CalculateNode.parseAllForSortIndex(head, model);
  }
  const rawName = model.getDataName(DataSourceType.Raw);
  const raw = new OutputNode(head, rawName, DataSourceType.Raw, outputNodeRefCounts);
  outputNodes[rawName] = raw;
  head = raw;
  if (isUnitModel(model)) {
    const agg = AggregateNode.makeFromEncoding(head, model);
    if (agg) {
      head = agg;
      if (requiresSelectionId(model)) {
        head = new IdentifierNode(head);
      }
    }
    head = (_g = ImputeNode.makeFromEncoding(head, model)) !== null && _g !== void 0 ? _g : head;
    head = (_h = StackNode.makeFromEncoding(head, model)) !== null && _h !== void 0 ? _h : head;
  }
  if (isUnitModel(model)) {
    head = (_j = FilterInvalidNode.make(head, model)) !== null && _j !== void 0 ? _j : head;
  }
  const mainName = model.getDataName(DataSourceType.Main);
  const main5 = new OutputNode(head, mainName, DataSourceType.Main, outputNodeRefCounts);
  outputNodes[mainName] = main5;
  head = main5;
  if (isUnitModel(model)) {
    materializeSelections(model, main5);
  }
  let facetRoot = null;
  if (isFacetModel(model)) {
    const facetName = model.getName("facet");
    head = (_k = makeJoinAggregateFromFacet(head, model.facet)) !== null && _k !== void 0 ? _k : head;
    facetRoot = new FacetNode(head, model, facetName, main5.getSource());
    outputNodes[facetName] = facetRoot;
  }
  return Object.assign(Object.assign({}, model.component.data), {
    outputNodes,
    outputNodeRefCounts,
    raw,
    main: main5,
    facetRoot,
    ancestorParse
  });
}

// node_modules/vega-lite/build/src/compile/concat.js
var ConcatModel = class extends Model {
  constructor(spec, parent, parentGivenName, config) {
    var _a, _b, _c, _d;
    super(spec, "concat", parent, parentGivenName, config, spec.resolve);
    if (((_b = (_a = spec.resolve) === null || _a === void 0 ? void 0 : _a.axis) === null || _b === void 0 ? void 0 : _b.x) === "shared" || ((_d = (_c = spec.resolve) === null || _c === void 0 ? void 0 : _c.axis) === null || _d === void 0 ? void 0 : _d.y) === "shared") {
      warn(message_exports.CONCAT_CANNOT_SHARE_AXIS);
    }
    this.children = this.getChildren(spec).map((child, i) => {
      return buildModel(child, this, this.getName(`concat_${i}`), void 0, config);
    });
  }
  parseData() {
    this.component.data = parseData(this);
    for (const child of this.children) {
      child.parseData();
    }
  }
  parseSelections() {
    this.component.selection = {};
    for (const child of this.children) {
      child.parseSelections();
      for (const key of keys(child.component.selection)) {
        this.component.selection[key] = child.component.selection[key];
      }
    }
  }
  parseMarkGroup() {
    for (const child of this.children) {
      child.parseMarkGroup();
    }
  }
  parseAxesAndHeaders() {
    for (const child of this.children) {
      child.parseAxesAndHeaders();
    }
  }
  getChildren(spec) {
    if (isVConcatSpec(spec)) {
      return spec.vconcat;
    } else if (isHConcatSpec(spec)) {
      return spec.hconcat;
    }
    return spec.concat;
  }
  parseLayoutSize() {
    parseConcatLayoutSize(this);
  }
  parseAxisGroup() {
    return null;
  }
  assembleSelectionTopLevelSignals(signals) {
    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);
  }
  assembleSignals() {
    this.children.forEach((child) => child.assembleSignals());
    return [];
  }
  assembleLayoutSignals() {
    const layoutSignals = assembleLayoutSignals(this);
    for (const child of this.children) {
      layoutSignals.push(...child.assembleLayoutSignals());
    }
    return layoutSignals;
  }
  assembleSelectionData(data) {
    return this.children.reduce((db, child) => child.assembleSelectionData(db), data);
  }
  assembleMarks() {
    return this.children.map((child) => {
      const title2 = child.assembleTitle();
      const style = child.assembleGroupStyle();
      const encodeEntry2 = child.assembleGroupEncodeEntry(false);
      return Object.assign(Object.assign(Object.assign(Object.assign({ type: "group", name: child.getName("group") }, title2 ? { title: title2 } : {}), style ? { style } : {}), encodeEntry2 ? { encode: { update: encodeEntry2 } } : {}), child.assembleGroup());
    });
  }
  assembleGroupStyle() {
    return void 0;
  }
  assembleDefaultLayout() {
    const columns = this.layout.columns;
    return Object.assign(Object.assign({}, columns != null ? { columns } : {}), {
      bounds: "full",
      align: "each"
    });
  }
};

// node_modules/vega-lite/build/src/compile/axis/component.js
function isFalseOrNull(v) {
  return v === false || v === null;
}
var AXIS_COMPONENT_PROPERTIES_INDEX = Object.assign(Object.assign({ disable: 1, gridScale: 1, scale: 1 }, COMMON_AXIS_PROPERTIES_INDEX), { labelExpr: 1, encode: 1 });
var AXIS_COMPONENT_PROPERTIES = keys(AXIS_COMPONENT_PROPERTIES_INDEX);
var AxisComponent = class extends Split {
  constructor(explicit = {}, implicit = {}, mainExtracted = false) {
    super();
    this.explicit = explicit;
    this.implicit = implicit;
    this.mainExtracted = mainExtracted;
  }
  clone() {
    return new AxisComponent(duplicate(this.explicit), duplicate(this.implicit), this.mainExtracted);
  }
  hasAxisPart(part) {
    if (part === "axis") {
      return true;
    }
    if (part === "grid" || part === "title") {
      return !!this.get(part);
    }
    return !isFalseOrNull(this.get(part));
  }
  hasOrientSignalRef() {
    return isSignalRef(this.explicit.orient);
  }
};

// node_modules/vega-lite/build/src/compile/axis/encode.js
function labels2(model, channel, specifiedLabelsSpec) {
  var _a;
  const { encoding, config } = model;
  const fieldOrDatumDef = (_a = getFieldOrDatumDef(encoding[channel])) !== null && _a !== void 0 ? _a : getFieldOrDatumDef(encoding[getSecondaryRangeChannel(channel)]);
  const axis = model.axis(channel) || {};
  const { format, formatType } = axis;
  if (isCustomFormatType(formatType)) {
    return Object.assign({ text: formatCustomType({
      fieldOrDatumDef,
      field: "datum.value",
      format,
      formatType,
      config
    }) }, specifiedLabelsSpec);
  }
  return specifiedLabelsSpec;
}

// node_modules/vega-lite/build/src/compile/axis/parse.js
function parseUnitAxes(model) {
  return POSITION_SCALE_CHANNELS.reduce((axis, channel) => {
    if (model.component.scales[channel]) {
      axis[channel] = [parseAxis(channel, model)];
    }
    return axis;
  }, {});
}
var OPPOSITE_ORIENT = {
  bottom: "top",
  top: "bottom",
  left: "right",
  right: "left"
};
function parseLayerAxes(model) {
  var _a;
  const { axes, resolve } = model.component;
  const axisCount = { top: 0, bottom: 0, right: 0, left: 0 };
  for (const child of model.children) {
    child.parseAxesAndHeaders();
    for (const channel of keys(child.component.axes)) {
      resolve.axis[channel] = parseGuideResolve(model.component.resolve, channel);
      if (resolve.axis[channel] === "shared") {
        axes[channel] = mergeAxisComponents(axes[channel], child.component.axes[channel]);
        if (!axes[channel]) {
          resolve.axis[channel] = "independent";
          delete axes[channel];
        }
      }
    }
  }
  for (const channel of POSITION_SCALE_CHANNELS) {
    for (const child of model.children) {
      if (!child.component.axes[channel]) {
        continue;
      }
      if (resolve.axis[channel] === "independent") {
        axes[channel] = ((_a = axes[channel]) !== null && _a !== void 0 ? _a : []).concat(child.component.axes[channel]);
        for (const axisComponent of child.component.axes[channel]) {
          const { value: orient2, explicit } = axisComponent.getWithExplicit("orient");
          if (isSignalRef(orient2)) {
            continue;
          }
          if (axisCount[orient2] > 0 && !explicit) {
            const oppositeOrient = OPPOSITE_ORIENT[orient2];
            if (axisCount[orient2] > axisCount[oppositeOrient]) {
              axisComponent.set("orient", oppositeOrient, false);
            }
          }
          axisCount[orient2]++;
        }
      }
      delete child.component.axes[channel];
    }
    if (resolve.axis[channel] === "independent" && axes[channel] && axes[channel].length > 1) {
      for (const axisCmpt of axes[channel]) {
        if (!!axisCmpt.get("grid") && !axisCmpt.explicit.grid) {
          axisCmpt.implicit.grid = false;
        }
      }
    }
  }
}
function mergeAxisComponents(mergedAxisCmpts, childAxisCmpts) {
  if (mergedAxisCmpts) {
    if (mergedAxisCmpts.length !== childAxisCmpts.length) {
      return void 0;
    }
    const length2 = mergedAxisCmpts.length;
    for (let i = 0; i < length2; i++) {
      const merged = mergedAxisCmpts[i];
      const child = childAxisCmpts[i];
      if (!!merged !== !!child) {
        return void 0;
      } else if (merged && child) {
        const mergedOrient = merged.getWithExplicit("orient");
        const childOrient = child.getWithExplicit("orient");
        if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {
          return void 0;
        } else {
          mergedAxisCmpts[i] = mergeAxisComponent(merged, child);
        }
      }
    }
  } else {
    return childAxisCmpts.map((axisComponent) => axisComponent.clone());
  }
  return mergedAxisCmpts;
}
function mergeAxisComponent(merged, child) {
  for (const prop of AXIS_COMPONENT_PROPERTIES) {
    const mergedValueWithExplicit = mergeValuesWithExplicit(merged.getWithExplicit(prop), child.getWithExplicit(prop), prop, "axis", (v1, v2) => {
      switch (prop) {
        case "title":
          return mergeTitleComponent(v1, v2);
        case "gridScale":
          return {
            explicit: v1.explicit,
            value: getFirstDefined(v1.value, v2.value)
          };
      }
      return defaultTieBreaker(v1, v2, prop, "axis");
    });
    merged.setWithExplicit(prop, mergedValueWithExplicit);
  }
  return merged;
}
function isExplicit2(value, property, axis, model, channel) {
  if (property === "disable") {
    return axis !== void 0;
  }
  axis = axis || {};
  switch (property) {
    case "titleAngle":
    case "labelAngle":
      return value === (isSignalRef(axis.labelAngle) ? axis.labelAngle : normalizeAngle(axis.labelAngle));
    case "values":
      return !!axis.values;
    case "encode":
      return !!axis.encoding || !!axis.labelAngle;
    case "title":
      if (value === getFieldDefTitle(model, channel)) {
        return true;
      }
  }
  return value === axis[property];
}
var propsToAlwaysIncludeConfig = new Set([
  "grid",
  "translate",
  "format",
  "formatType",
  "orient",
  "labelExpr",
  "tickCount",
  "position",
  "tickMinStep"
]);
function parseAxis(channel, model) {
  var _a, _b, _c;
  let axis = model.axis(channel);
  const axisComponent = new AxisComponent();
  const fieldOrDatumDef = getFieldOrDatumDef(model.encoding[channel]);
  const { mark: mark3, config } = model;
  const orient2 = (axis === null || axis === void 0 ? void 0 : axis.orient) || ((_a = config[channel === "x" ? "axisX" : "axisY"]) === null || _a === void 0 ? void 0 : _a.orient) || ((_b = config.axis) === null || _b === void 0 ? void 0 : _b.orient) || defaultOrient(channel);
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const axisConfigs = getAxisConfigs(channel, scaleType2, orient2, model.config);
  const disable = axis !== void 0 ? !axis : getAxisConfig("disable", config.style, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs).configValue;
  axisComponent.set("disable", disable, axis !== void 0);
  if (disable) {
    return axisComponent;
  }
  axis = axis || {};
  const labelAngle = getLabelAngle(fieldOrDatumDef, axis, channel, config.style, axisConfigs);
  const ruleParams = {
    fieldOrDatumDef,
    axis,
    channel,
    model,
    scaleType: scaleType2,
    orient: orient2,
    labelAngle,
    mark: mark3,
    config
  };
  for (const property of AXIS_COMPONENT_PROPERTIES) {
    const value = property in axisRules ? axisRules[property](ruleParams) : isAxisProperty(property) ? axis[property] : void 0;
    const hasValue = value !== void 0;
    const explicit = isExplicit2(value, property, axis, model, channel);
    if (hasValue && explicit) {
      axisComponent.set(property, value, explicit);
    } else {
      const { configValue = void 0, configFrom = void 0 } = isAxisProperty(property) && property !== "values" ? getAxisConfig(property, config.style, axis.style, axisConfigs) : {};
      const hasConfigValue = configValue !== void 0;
      if (hasValue && !hasConfigValue) {
        axisComponent.set(property, value, explicit);
      } else if (!(configFrom === "vgAxisConfig") || propsToAlwaysIncludeConfig.has(property) && hasConfigValue || isConditionalAxisValue(configValue) || isSignalRef(configValue)) {
        axisComponent.set(property, configValue, false);
      }
    }
  }
  const axisEncoding = (_c = axis.encoding) !== null && _c !== void 0 ? _c : {};
  const axisEncode = AXIS_PARTS.reduce((e2, part) => {
    var _a2;
    if (!axisComponent.hasAxisPart(part)) {
      return e2;
    }
    const axisEncodingPart = guideEncodeEntry((_a2 = axisEncoding[part]) !== null && _a2 !== void 0 ? _a2 : {}, model);
    const value = part === "labels" ? labels2(model, channel, axisEncodingPart) : axisEncodingPart;
    if (value !== void 0 && !isEmpty(value)) {
      e2[part] = { update: value };
    }
    return e2;
  }, {});
  if (!isEmpty(axisEncode)) {
    axisComponent.set("encode", axisEncode, !!axis.encoding || axis.labelAngle !== void 0);
  }
  return axisComponent;
}

// node_modules/vega-lite/build/src/compile/layoutsize/init.js
function initLayoutSize({ encoding, size }) {
  for (const channel of POSITION_SCALE_CHANNELS) {
    const sizeType = getSizeChannel(channel);
    if (isStep(size[sizeType])) {
      if (isContinuousFieldOrDatumDef(encoding[channel])) {
        delete size[sizeType];
        warn(message_exports.stepDropped(sizeType));
      }
    }
  }
  return size;
}

// node_modules/vega-lite/build/src/compile/mark/init.js
function initMarkdef(originalMarkDef, encoding, config) {
  const markDef = replaceExprRef(originalMarkDef);
  const specifiedOrient = getMarkPropOrConfig("orient", markDef, config);
  markDef.orient = orient(markDef.type, encoding, specifiedOrient);
  if (specifiedOrient !== void 0 && specifiedOrient !== markDef.orient) {
    warn(message_exports.orientOverridden(markDef.orient, specifiedOrient));
  }
  if (markDef.type === "bar" && markDef.orient) {
    const cornerRadiusEnd = getMarkPropOrConfig("cornerRadiusEnd", markDef, config);
    if (cornerRadiusEnd !== void 0) {
      const newProps = markDef.orient === "horizontal" && encoding.x2 || markDef.orient === "vertical" && encoding.y2 ? ["cornerRadius"] : BAR_CORNER_RADIUS_INDEX[markDef.orient];
      for (const newProp of newProps) {
        markDef[newProp] = cornerRadiusEnd;
      }
      if (markDef.cornerRadiusEnd !== void 0) {
        delete markDef.cornerRadiusEnd;
      }
    }
  }
  const specifiedOpacity = getMarkPropOrConfig("opacity", markDef, config);
  if (specifiedOpacity === void 0) {
    markDef.opacity = opacity(markDef.type, encoding);
  }
  const specifiedCursor = getMarkPropOrConfig("cursor", markDef, config);
  if (specifiedCursor === void 0) {
    markDef.cursor = cursor(markDef, encoding, config);
  }
  return markDef;
}
function cursor(markDef, encoding, config) {
  if (encoding.href || markDef.href || getMarkPropOrConfig("href", markDef, config)) {
    return "pointer";
  }
  return markDef.cursor;
}
function opacity(mark3, encoding) {
  if (contains([POINT, TICK, CIRCLE, SQUARE], mark3)) {
    if (!isAggregate(encoding)) {
      return 0.7;
    }
  }
  return void 0;
}
function defaultFilled(markDef, config, { graticule }) {
  if (graticule) {
    return false;
  }
  const filledConfig = getMarkConfig("filled", markDef, config);
  const mark3 = markDef.type;
  return getFirstDefined(filledConfig, mark3 !== POINT && mark3 !== LINE && mark3 !== RULE);
}
function orient(mark3, encoding, specifiedOrient) {
  switch (mark3) {
    case POINT:
    case CIRCLE:
    case SQUARE:
    case TEXT2:
    case RECT:
    case IMAGE:
      return void 0;
  }
  const { x, y, x2, y2 } = encoding;
  switch (mark3) {
    case BAR:
      if (isFieldDef(x) && (isBinned(x.bin) || isFieldDef(y) && y.aggregate && !x.aggregate)) {
        return "vertical";
      }
      if (isFieldDef(y) && (isBinned(y.bin) || isFieldDef(x) && x.aggregate && !y.aggregate)) {
        return "horizontal";
      }
      if (y2 || x2) {
        if (specifiedOrient) {
          return specifiedOrient;
        }
        if (!x2) {
          if (isFieldDef(x) && x.type === QUANTITATIVE && !isBinning(x.bin) || isNumericDataDef(x)) {
            return "horizontal";
          }
        }
        if (!y2) {
          if (isFieldDef(y) && y.type === QUANTITATIVE && !isBinning(y.bin) || isNumericDataDef(y)) {
            return "vertical";
          }
        }
      }
    case RULE:
      if (x2 && !(isFieldDef(x) && isBinned(x.bin)) && y2 && !(isFieldDef(y) && isBinned(y.bin))) {
        return void 0;
      }
    case AREA:
      if (y2) {
        if (isFieldDef(y) && isBinned(y.bin)) {
          return "horizontal";
        } else {
          return "vertical";
        }
      } else if (x2) {
        if (isFieldDef(x) && isBinned(x.bin)) {
          return "vertical";
        } else {
          return "horizontal";
        }
      } else if (mark3 === RULE) {
        if (x && !y) {
          return "vertical";
        } else if (y && !x) {
          return "horizontal";
        }
      }
    case LINE:
    case TICK: {
      const xIsContinuous = isContinuousFieldOrDatumDef(x);
      const yIsContinuous = isContinuousFieldOrDatumDef(y);
      if (specifiedOrient) {
        return specifiedOrient;
      } else if (xIsContinuous && !yIsContinuous) {
        return mark3 !== "tick" ? "horizontal" : "vertical";
      } else if (!xIsContinuous && yIsContinuous) {
        return mark3 !== "tick" ? "vertical" : "horizontal";
      } else if (xIsContinuous && yIsContinuous) {
        const xDef = x;
        const yDef = y;
        const xIsTemporal = xDef.type === TEMPORAL;
        const yIsTemporal = yDef.type === TEMPORAL;
        if (xIsTemporal && !yIsTemporal) {
          return mark3 !== "tick" ? "vertical" : "horizontal";
        } else if (!xIsTemporal && yIsTemporal) {
          return mark3 !== "tick" ? "horizontal" : "vertical";
        }
        if (!xDef.aggregate && yDef.aggregate) {
          return mark3 !== "tick" ? "vertical" : "horizontal";
        } else if (xDef.aggregate && !yDef.aggregate) {
          return mark3 !== "tick" ? "horizontal" : "vertical";
        }
        return "vertical";
      } else {
        return void 0;
      }
    }
  }
  return "vertical";
}

// node_modules/vega-lite/build/src/compile/mark/arc.js
var arc = {
  vgMark: "arc",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), rectPosition(model, "radius", "arc")), rectPosition(model, "theta", "arc"));
  }
};

// node_modules/vega-lite/build/src/compile/mark/area.js
var area = {
  vgMark: "area",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "include",
      size: "ignore",
      theta: "ignore"
    })), pointOrRangePosition("x", model, {
      defaultPos: "zeroOrMin",
      defaultPos2: "zeroOrMin",
      range: model.markDef.orient === "horizontal"
    })), pointOrRangePosition("y", model, {
      defaultPos: "zeroOrMin",
      defaultPos2: "zeroOrMin",
      range: model.markDef.orient === "vertical"
    })), defined(model));
  }
};

// node_modules/vega-lite/build/src/compile/mark/bar.js
var bar = {
  vgMark: "rect",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), rectPosition(model, "x", "bar")), rectPosition(model, "y", "bar"));
  }
};

// node_modules/vega-lite/build/src/compile/mark/geoshape.js
var geoshape = {
  vgMark: "shape",
  encodeEntry: (model) => {
    return Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    }));
  },
  postEncodingTransform: (model) => {
    const { encoding } = model;
    const shapeDef = encoding.shape;
    const transform = Object.assign({ type: "geoshape", projection: model.projectionName() }, shapeDef && isFieldDef(shapeDef) && shapeDef.type === GEOJSON ? { field: vgField(shapeDef, { expr: "datum" }) } : {});
    return [transform];
  }
};

// node_modules/vega-lite/build/src/compile/mark/image.js
var image = {
  vgMark: "image",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "ignore",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), rectPosition(model, "x", "image")), rectPosition(model, "y", "image")), text(model, "url"));
  }
};

// node_modules/vega-lite/build/src/compile/mark/line.js
var line = {
  vgMark: "line",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), nonPosition("size", model, {
      vgChannel: "strokeWidth"
    })), defined(model));
  }
};
var trail = {
  vgMark: "trail",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "include",
      orient: "ignore",
      theta: "ignore"
    })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), nonPosition("size", model)), defined(model));
  }
};

// node_modules/vega-lite/build/src/compile/mark/point.js
function encodeEntry(model, fixedShape) {
  const { config } = model;
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
    align: "ignore",
    baseline: "ignore",
    color: "include",
    size: "include",
    orient: "ignore",
    theta: "ignore"
  })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), nonPosition("size", model)), nonPosition("angle", model)), shapeMixins(model, config, fixedShape));
}
function shapeMixins(model, config, fixedShape) {
  if (fixedShape) {
    return { shape: { value: fixedShape } };
  }
  return nonPosition("shape", model);
}
var point2 = {
  vgMark: "symbol",
  encodeEntry: (model) => {
    return encodeEntry(model);
  }
};
var circle = {
  vgMark: "symbol",
  encodeEntry: (model) => {
    return encodeEntry(model, "circle");
  }
};
var square = {
  vgMark: "symbol",
  encodeEntry: (model) => {
    return encodeEntry(model, "square");
  }
};

// node_modules/vega-lite/build/src/compile/mark/rect.js
var rect = {
  vgMark: "rect",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), rectPosition(model, "x", "rect")), rectPosition(model, "y", "rect"));
  }
};

// node_modules/vega-lite/build/src/compile/mark/rule.js
var rule = {
  vgMark: "rule",
  encodeEntry: (model) => {
    const { markDef } = model;
    const orient2 = markDef.orient;
    if (!model.encoding.x && !model.encoding.y && !model.encoding.latitude && !model.encoding.longitude) {
      return {};
    }
    return Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), pointOrRangePosition("x", model, {
      defaultPos: orient2 === "horizontal" ? "zeroOrMax" : "mid",
      defaultPos2: "zeroOrMin",
      range: orient2 !== "vertical"
    })), pointOrRangePosition("y", model, {
      defaultPos: orient2 === "vertical" ? "zeroOrMax" : "mid",
      defaultPos2: "zeroOrMin",
      range: orient2 !== "horizontal"
    })), nonPosition("size", model, {
      vgChannel: "strokeWidth"
    }));
  }
};

// node_modules/vega-lite/build/src/compile/mark/text.js
var text2 = {
  vgMark: "text",
  encodeEntry: (model) => {
    const { config, encoding } = model;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "include",
      baseline: "include",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "include"
    })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), text(model)), nonPosition("size", model, {
      vgChannel: "fontSize"
    })), nonPosition("angle", model)), valueIfDefined("align", align(model.markDef, encoding, config))), valueIfDefined("baseline", baseline(model.markDef, encoding, config))), pointPosition("radius", model, { defaultPos: null })), pointPosition("theta", model, { defaultPos: null }));
  }
};
function align(markDef, encoding, config) {
  const a = getMarkPropOrConfig("align", markDef, config);
  if (a === void 0) {
    return "center";
  }
  return void 0;
}
function baseline(markDef, encoding, config) {
  const b = getMarkPropOrConfig("baseline", markDef, config);
  if (b === void 0) {
    return "middle";
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/mark/tick.js
var tick = {
  vgMark: "rect",
  encodeEntry: (model) => {
    const { config, markDef } = model;
    const orient2 = markDef.orient;
    const vgSizeChannel = orient2 === "horizontal" ? "width" : "height";
    const vgThicknessChannel = orient2 === "horizontal" ? "height" : "width";
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), pointPosition("x", model, { defaultPos: "mid", vgChannel: "xc" })), pointPosition("y", model, { defaultPos: "mid", vgChannel: "yc" })), nonPosition("size", model, {
      defaultValue: defaultSize(model),
      vgChannel: vgSizeChannel
    })), { [vgThicknessChannel]: signalOrValueRef(getMarkPropOrConfig("thickness", markDef, config)) });
  }
};
function defaultSize(model) {
  var _a;
  const { config, markDef } = model;
  const { orient: orient2 } = markDef;
  const vgSizeChannel = orient2 === "horizontal" ? "width" : "height";
  const scale = model.getScaleComponent(orient2 === "horizontal" ? "x" : "y");
  const markPropOrConfig = (_a = getMarkPropOrConfig("size", markDef, config, { vgChannel: vgSizeChannel })) !== null && _a !== void 0 ? _a : config.tick.bandSize;
  if (markPropOrConfig !== void 0) {
    return markPropOrConfig;
  } else {
    const scaleRange = scale ? scale.get("range") : void 0;
    if (scaleRange && isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {
      return scaleRange.step * 3 / 4;
    }
    const defaultViewStep = getViewConfigDiscreteStep(config.view, vgSizeChannel);
    return defaultViewStep * 3 / 4;
  }
}

// node_modules/vega-lite/build/src/compile/mark/mark.js
var markCompiler = {
  arc,
  area,
  bar,
  circle,
  geoshape,
  image,
  line,
  point: point2,
  rect,
  rule,
  square,
  text: text2,
  tick,
  trail
};
function parseMarkGroups(model) {
  if (contains([LINE, AREA, TRAIL], model.mark)) {
    const details = pathGroupingFields(model.mark, model.encoding);
    if (details.length > 0) {
      return getPathGroups(model, details);
    }
  } else if (model.mark === BAR) {
    const hasCornerRadius = VG_CORNERRADIUS_CHANNELS.some((prop) => getMarkPropOrConfig(prop, model.markDef, model.config));
    if (model.stack && !model.fieldDef("size") && hasCornerRadius) {
      return getGroupsForStackedBarWithCornerRadius(model);
    }
  }
  return getMarkGroup(model);
}
var FACETED_PATH_PREFIX = "faceted_path_";
function getPathGroups(model, details) {
  return [
    {
      name: model.getName("pathgroup"),
      type: "group",
      from: {
        facet: {
          name: FACETED_PATH_PREFIX + model.requestDataName(DataSourceType.Main),
          data: model.requestDataName(DataSourceType.Main),
          groupby: details
        }
      },
      encode: {
        update: {
          width: { field: { group: "width" } },
          height: { field: { group: "height" } }
        }
      },
      marks: getMarkGroup(model, { fromPrefix: FACETED_PATH_PREFIX })
    }
  ];
}
var STACK_GROUP_PREFIX = "stack_group_";
function getGroupsForStackedBarWithCornerRadius(model) {
  const [mark3] = getMarkGroup(model, { fromPrefix: STACK_GROUP_PREFIX });
  const fieldScale = model.scaleName(model.stack.fieldChannel);
  const stackField = (opt = {}) => model.vgField(model.stack.fieldChannel, opt);
  const stackFieldGroup = (func, expr) => {
    const vgFieldMinMax = [
      stackField({ prefix: "min", suffix: "start", expr }),
      stackField({ prefix: "max", suffix: "start", expr }),
      stackField({ prefix: "min", suffix: "end", expr }),
      stackField({ prefix: "max", suffix: "end", expr })
    ];
    return `${func}(${vgFieldMinMax.map((field) => `scale('${fieldScale}',${field})`).join(",")})`;
  };
  let groupUpdate;
  let innerGroupUpdate;
  if (model.stack.fieldChannel === "x") {
    groupUpdate = Object.assign(Object.assign({}, pick(mark3.encode.update, ["y", "yc", "y2", "height", ...VG_CORNERRADIUS_CHANNELS])), { x: { signal: stackFieldGroup("min", "datum") }, x2: { signal: stackFieldGroup("max", "datum") }, clip: { value: true } });
    innerGroupUpdate = {
      x: { field: { group: "x" }, mult: -1 },
      height: { field: { group: "height" } }
    };
    mark3.encode.update = Object.assign(Object.assign({}, omit(mark3.encode.update, ["y", "yc", "y2"])), { height: { field: { group: "height" } } });
  } else {
    groupUpdate = Object.assign(Object.assign({}, pick(mark3.encode.update, ["x", "xc", "x2", "width"])), { y: { signal: stackFieldGroup("min", "datum") }, y2: { signal: stackFieldGroup("max", "datum") }, clip: { value: true } });
    innerGroupUpdate = {
      y: { field: { group: "y" }, mult: -1 },
      width: { field: { group: "width" } }
    };
    mark3.encode.update = Object.assign(Object.assign({}, omit(mark3.encode.update, ["x", "xc", "x2"])), { width: { field: { group: "width" } } });
  }
  for (const key of VG_CORNERRADIUS_CHANNELS) {
    const configValue = getMarkConfig(key, model.markDef, model.config);
    if (mark3.encode.update[key]) {
      groupUpdate[key] = mark3.encode.update[key];
      delete mark3.encode.update[key];
    } else if (configValue) {
      groupUpdate[key] = signalOrValueRef(configValue);
    }
    if (configValue) {
      mark3.encode.update[key] = { value: 0 };
    }
  }
  const groupby = [];
  if (model.stack.groupbyChannel) {
    const groupByField = model.fieldDef(model.stack.groupbyChannel);
    const field = vgField(groupByField);
    if (field) {
      groupby.push(field);
    }
    if ((groupByField === null || groupByField === void 0 ? void 0 : groupByField.bin) || (groupByField === null || groupByField === void 0 ? void 0 : groupByField.timeUnit)) {
      groupby.push(vgField(groupByField, { binSuffix: "end" }));
    }
  }
  const strokeProperties = [
    "stroke",
    "strokeWidth",
    "strokeJoin",
    "strokeCap",
    "strokeDash",
    "strokeDashOffset",
    "strokeMiterLimit",
    "strokeOpacity"
  ];
  groupUpdate = strokeProperties.reduce((encode13, prop) => {
    if (mark3.encode.update[prop]) {
      return Object.assign(Object.assign({}, encode13), { [prop]: mark3.encode.update[prop] });
    } else {
      const configValue = getMarkConfig(prop, model.markDef, model.config);
      if (configValue !== void 0) {
        return Object.assign(Object.assign({}, encode13), { [prop]: signalOrValueRef(configValue) });
      } else {
        return encode13;
      }
    }
  }, groupUpdate);
  if (groupUpdate.stroke) {
    groupUpdate.strokeForeground = { value: true };
    groupUpdate.strokeOffset = { value: 0 };
  }
  return [
    {
      type: "group",
      from: {
        facet: {
          data: model.requestDataName(DataSourceType.Main),
          name: STACK_GROUP_PREFIX + model.requestDataName(DataSourceType.Main),
          groupby,
          aggregate: {
            fields: [
              stackField({ suffix: "start" }),
              stackField({ suffix: "start" }),
              stackField({ suffix: "end" }),
              stackField({ suffix: "end" })
            ],
            ops: ["min", "max", "min", "max"]
          }
        }
      },
      encode: {
        update: groupUpdate
      },
      marks: [
        {
          type: "group",
          encode: { update: innerGroupUpdate },
          marks: [mark3]
        }
      ]
    }
  ];
}
function getSort2(model) {
  var _a;
  const { encoding, stack: stack2, mark: mark3, markDef, config } = model;
  const order = encoding.order;
  if (!isArray2(order) && isValueDef(order) && isNullOrFalse(order.value) || !order && isNullOrFalse(getMarkPropOrConfig("order", markDef, config))) {
    return void 0;
  } else if ((isArray2(order) || isFieldDef(order)) && !stack2) {
    return sortParams(order, { expr: "datum" });
  } else if (isPathMark(mark3)) {
    const dimensionChannel = markDef.orient === "horizontal" ? "y" : "x";
    const dimensionChannelDef = encoding[dimensionChannel];
    if (isFieldDef(dimensionChannelDef)) {
      const s = dimensionChannelDef.sort;
      if (isArray2(s)) {
        return {
          field: vgField(dimensionChannelDef, { prefix: dimensionChannel, suffix: "sort_index", expr: "datum" })
        };
      } else if (isSortField(s)) {
        return {
          field: vgField({
            aggregate: isAggregate(model.encoding) ? s.op : void 0,
            field: s.field
          }, { expr: "datum" })
        };
      } else if (isSortByEncoding(s)) {
        const fieldDefToSort = model.fieldDef(s.encoding);
        return {
          field: vgField(fieldDefToSort, { expr: "datum" }),
          order: s.order
        };
      } else if (s === null) {
        return void 0;
      } else {
        return {
          field: vgField(dimensionChannelDef, {
            binSuffix: ((_a = model.stack) === null || _a === void 0 ? void 0 : _a.impute) ? "mid" : void 0,
            expr: "datum"
          })
        };
      }
    }
    return void 0;
  }
  return void 0;
}
function getMarkGroup(model, opt = { fromPrefix: "" }) {
  const { mark: mark3, markDef, encoding, config } = model;
  const clip = getFirstDefined(markDef.clip, scaleClip(model), projectionClip(model));
  const style = getStyles(markDef);
  const key = encoding.key;
  const sort = getSort2(model);
  const interactive = interactiveFlag(model);
  const aria2 = getMarkPropOrConfig("aria", markDef, config);
  const postEncodingTransform = markCompiler[mark3].postEncodingTransform ? markCompiler[mark3].postEncodingTransform(model) : null;
  return [
    Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: model.getName("marks"), type: markCompiler[mark3].vgMark }, clip ? { clip: true } : {}), style ? { style } : {}), key ? { key: key.field } : {}), sort ? { sort } : {}), interactive ? interactive : {}), aria2 === false ? { aria: aria2 } : {}), { from: { data: opt.fromPrefix + model.requestDataName(DataSourceType.Main) }, encode: {
      update: markCompiler[mark3].encodeEntry(model)
    } }), postEncodingTransform ? {
      transform: postEncodingTransform
    } : {})
  ];
}
function scaleClip(model) {
  const xScale = model.getScaleComponent("x");
  const yScale = model.getScaleComponent("y");
  return xScale && xScale.get("selectionExtent") || yScale && yScale.get("selectionExtent") ? true : void 0;
}
function projectionClip(model) {
  const projection = model.component.projection;
  return projection && !projection.isFit ? true : void 0;
}
function interactiveFlag(model) {
  if (!model.component.selection)
    return null;
  const unitCount = keys(model.component.selection).length;
  let parentCount = unitCount;
  let parent = model.parent;
  while (parent && parentCount === 0) {
    parentCount = keys(parent.component.selection).length;
    parent = parent.parent;
  }
  return parentCount ? {
    interactive: unitCount > 0 || !!model.encoding.tooltip
  } : null;
}

// node_modules/vega-lite/build/src/compile/unit.js
var UnitModel = class extends ModelWithField {
  constructor(spec, parent, parentGivenName, parentGivenSize = {}, config) {
    var _a;
    super(spec, "unit", parent, parentGivenName, config, void 0, isFrameMixins(spec) ? spec.view : void 0);
    this.specifiedScales = {};
    this.specifiedAxes = {};
    this.specifiedLegends = {};
    this.specifiedProjection = {};
    this.selection = [];
    this.children = [];
    const markDef = isMarkDef(spec.mark) ? Object.assign({}, spec.mark) : { type: spec.mark };
    const mark3 = markDef.type;
    if (markDef.filled === void 0) {
      markDef.filled = defaultFilled(markDef, config, {
        graticule: spec.data && isGraticuleGenerator(spec.data)
      });
    }
    const encoding = this.encoding = initEncoding(spec.encoding || {}, mark3, markDef.filled, config);
    this.markDef = initMarkdef(markDef, encoding, config);
    this.size = initLayoutSize({
      encoding,
      size: isFrameMixins(spec) ? Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? { width: spec.width } : {}), spec.height ? { height: spec.height } : {}) : parentGivenSize
    });
    this.stack = stack(mark3, encoding);
    this.specifiedScales = this.initScales(mark3, encoding);
    this.specifiedAxes = this.initAxes(encoding);
    this.specifiedLegends = this.initLegends(encoding);
    this.specifiedProjection = spec.projection;
    this.selection = ((_a = spec.params) !== null && _a !== void 0 ? _a : []).filter((p) => isSelectionParameter(p));
  }
  get hasProjection() {
    const { encoding } = this;
    const isGeoShapeMark = this.mark === GEOSHAPE;
    const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some((channel) => isFieldOrDatumDef(encoding[channel]));
    return isGeoShapeMark || hasGeoPosition;
  }
  scaleDomain(channel) {
    const scale = this.specifiedScales[channel];
    return scale ? scale.domain : void 0;
  }
  axis(channel) {
    return this.specifiedAxes[channel];
  }
  legend(channel) {
    return this.specifiedLegends[channel];
  }
  initScales(mark3, encoding) {
    return SCALE_CHANNELS.reduce((scales, channel) => {
      var _a;
      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
      if (fieldOrDatumDef) {
        scales[channel] = this.initScale((_a = fieldOrDatumDef.scale) !== null && _a !== void 0 ? _a : {});
      }
      return scales;
    }, {});
  }
  initScale(scale) {
    const { domain: domain2, range: range2 } = scale;
    const scaleInternal = replaceExprRef(scale);
    if (isArray2(domain2)) {
      scaleInternal.domain = domain2.map(signalRefOrValue);
    }
    if (isArray2(range2)) {
      scaleInternal.range = range2.map(signalRefOrValue);
    }
    return scaleInternal;
  }
  initAxes(encoding) {
    return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {
      const channelDef = encoding[channel];
      if (isFieldOrDatumDef(channelDef) || channel === X && isFieldOrDatumDef(encoding.x2) || channel === Y && isFieldOrDatumDef(encoding.y2)) {
        const axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : void 0;
        _axis[channel] = axisSpec ? this.initAxis(Object.assign({}, axisSpec)) : axisSpec;
      }
      return _axis;
    }, {});
  }
  initAxis(axis) {
    const props = keys(axis);
    const axisInternal = {};
    for (const prop of props) {
      const val = axis[prop];
      axisInternal[prop] = isConditionalAxisValue(val) ? signalOrValueRefWithCondition(val) : signalRefOrValue(val);
    }
    return axisInternal;
  }
  initLegends(encoding) {
    return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {
      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
      if (fieldOrDatumDef && supportLegend(channel)) {
        const legend = fieldOrDatumDef.legend;
        _legend[channel] = legend ? replaceExprRef(legend) : legend;
      }
      return _legend;
    }, {});
  }
  parseData() {
    this.component.data = parseData(this);
  }
  parseLayoutSize() {
    parseUnitLayoutSize(this);
  }
  parseSelections() {
    this.component.selection = parseUnitSelection(this, this.selection);
  }
  parseMarkGroup() {
    this.component.mark = parseMarkGroups(this);
  }
  parseAxesAndHeaders() {
    this.component.axes = parseUnitAxes(this);
  }
  assembleSelectionTopLevelSignals(signals) {
    return assembleTopLevelSignals(this, signals);
  }
  assembleSignals() {
    return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];
  }
  assembleSelectionData(data) {
    return assembleUnitSelectionData(this, data);
  }
  assembleLayout() {
    return null;
  }
  assembleLayoutSignals() {
    return assembleLayoutSignals(this);
  }
  assembleMarks() {
    var _a;
    let marks = (_a = this.component.mark) !== null && _a !== void 0 ? _a : [];
    if (!this.parent || !isLayerModel(this.parent)) {
      marks = assembleUnitSelectionMarks(this, marks);
    }
    return marks.map(this.correctDataNames);
  }
  assembleGroupStyle() {
    const { style } = this.view || {};
    if (style !== void 0) {
      return style;
    }
    if (this.encoding.x || this.encoding.y) {
      return "cell";
    } else {
      return void 0;
    }
  }
  getMapping() {
    return this.encoding;
  }
  get mark() {
    return this.markDef.type;
  }
  channelHasField(channel) {
    return channelHasField(this.encoding, channel);
  }
  fieldDef(channel) {
    const channelDef = this.encoding[channel];
    return getFieldDef(channelDef);
  }
  typedFieldDef(channel) {
    const fieldDef = this.fieldDef(channel);
    if (isTypedFieldDef(fieldDef)) {
      return fieldDef;
    }
    return null;
  }
};

// node_modules/vega-lite/build/src/compile/layer.js
var LayerModel = class extends Model {
  constructor(spec, parent, parentGivenName, parentGivenSize, config) {
    super(spec, "layer", parent, parentGivenName, config, spec.resolve, spec.view);
    const layoutSize = Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? { width: spec.width } : {}), spec.height ? { height: spec.height } : {});
    this.children = spec.layer.map((layer, i) => {
      if (isLayerSpec(layer)) {
        return new LayerModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);
      } else if (isUnitSpec(layer)) {
        return new UnitModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);
      }
      throw new Error(message_exports.invalidSpec(layer));
    });
  }
  parseData() {
    this.component.data = parseData(this);
    for (const child of this.children) {
      child.parseData();
    }
  }
  parseLayoutSize() {
    parseLayerLayoutSize(this);
  }
  parseSelections() {
    this.component.selection = {};
    for (const child of this.children) {
      child.parseSelections();
      for (const key of keys(child.component.selection)) {
        this.component.selection[key] = child.component.selection[key];
      }
    }
  }
  parseMarkGroup() {
    for (const child of this.children) {
      child.parseMarkGroup();
    }
  }
  parseAxesAndHeaders() {
    parseLayerAxes(this);
  }
  assembleSelectionTopLevelSignals(signals) {
    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);
  }
  assembleSignals() {
    return this.children.reduce((signals, child) => {
      return signals.concat(child.assembleSignals());
    }, assembleAxisSignals(this));
  }
  assembleLayoutSignals() {
    return this.children.reduce((signals, child) => {
      return signals.concat(child.assembleLayoutSignals());
    }, assembleLayoutSignals(this));
  }
  assembleSelectionData(data) {
    return this.children.reduce((db, child) => child.assembleSelectionData(db), data);
  }
  assembleGroupStyle() {
    const uniqueStyles = new Set();
    for (const child of this.children) {
      for (const style of array(child.assembleGroupStyle())) {
        uniqueStyles.add(style);
      }
    }
    const styles = Array.from(uniqueStyles);
    return styles.length > 1 ? styles : styles.length === 1 ? styles[0] : void 0;
  }
  assembleTitle() {
    let title2 = super.assembleTitle();
    if (title2) {
      return title2;
    }
    for (const child of this.children) {
      title2 = child.assembleTitle();
      if (title2) {
        return title2;
      }
    }
    return void 0;
  }
  assembleLayout() {
    return null;
  }
  assembleMarks() {
    return assembleLayerSelectionMarks(this, this.children.flatMap((child) => {
      return child.assembleMarks();
    }));
  }
  assembleLegends() {
    return this.children.reduce((legends, child) => {
      return legends.concat(child.assembleLegends());
    }, assembleLegends(this));
  }
};

// node_modules/vega-lite/build/src/compile/buildmodel.js
function buildModel(spec, parent, parentGivenName, unitSize, config) {
  if (isFacetSpec(spec)) {
    return new FacetModel(spec, parent, parentGivenName, config);
  } else if (isLayerSpec(spec)) {
    return new LayerModel(spec, parent, parentGivenName, unitSize, config);
  } else if (isUnitSpec(spec)) {
    return new UnitModel(spec, parent, parentGivenName, unitSize, config);
  } else if (isAnyConcatSpec(spec)) {
    return new ConcatModel(spec, parent, parentGivenName, config);
  }
  throw new Error(message_exports.invalidSpec(spec));
}

// node_modules/vega-lite/build/src/compile/compile.js
var __rest30 = function(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
};
function compile(inputSpec, opt = {}) {
  if (opt.logger) {
    set(opt.logger);
  }
  if (opt.fieldTitle) {
    setTitleFormatter(opt.fieldTitle);
  }
  try {
    const config = initConfig(mergeConfig2(opt.config, inputSpec.config));
    const spec = normalize(inputSpec, config);
    const model = buildModel(spec, null, "", void 0, config);
    model.parse();
    optimizeDataflow(model.component.data, model);
    const vgSpec = assembleTopLevelModel(model, getTopLevelProperties(inputSpec, spec.autosize, config, model), inputSpec.datasets, inputSpec.usermeta);
    return {
      spec: vgSpec,
      normalized: spec
    };
  } finally {
    if (opt.logger) {
      reset();
    }
    if (opt.fieldTitle) {
      resetTitleFormatter();
    }
  }
}
function getTopLevelProperties(inputSpec, autosize, config, model) {
  const width = model.component.layoutSize.get("width");
  const height = model.component.layoutSize.get("height");
  if (autosize === void 0) {
    autosize = { type: "pad" };
    if (model.hasAxisOrientSignalRef()) {
      autosize.resize = true;
    }
  } else if (isString2(autosize)) {
    autosize = { type: autosize };
  }
  if (width && height && isFitType(autosize.type)) {
    if (width === "step" && height === "step") {
      warn(message_exports.droppingFit());
      autosize.type = "pad";
    } else if (width === "step" || height === "step") {
      const sizeType = width === "step" ? "width" : "height";
      warn(message_exports.droppingFit(getPositionScaleChannel(sizeType)));
      const inverseSizeType = sizeType === "width" ? "height" : "width";
      autosize.type = getFitType(inverseSizeType);
    }
  }
  return Object.assign(Object.assign(Object.assign({}, keys(autosize).length === 1 && autosize.type ? autosize.type === "pad" ? {} : { autosize: autosize.type } : { autosize }), extractTopLevelProperties(config, false)), extractTopLevelProperties(inputSpec, true));
}
function assembleTopLevelModel(model, topLevelProperties, datasets = {}, usermeta) {
  const vgConfig = model.config ? stripAndRedirectConfig(model.config) : void 0;
  const data = [].concat(model.assembleSelectionData([]), assembleRootData(model.component.data, datasets));
  const projections = model.assembleProjections();
  const title2 = model.assembleTitle();
  const style = model.assembleGroupStyle();
  const encodeEntry2 = model.assembleGroupEncodeEntry(true);
  let layoutSignals = model.assembleLayoutSignals();
  layoutSignals = layoutSignals.filter((signal) => {
    if ((signal.name === "width" || signal.name === "height") && signal.value !== void 0) {
      topLevelProperties[signal.name] = +signal.value;
      return false;
    }
    return true;
  });
  const { params } = topLevelProperties, otherTopLevelProps = __rest30(topLevelProperties, ["params"]);
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ $schema: "https://vega.github.io/schema/vega/v5.json" }, model.description ? { description: model.description } : {}), otherTopLevelProps), title2 ? { title: title2 } : {}), style ? { style } : {}), encodeEntry2 ? { encode: { update: encodeEntry2 } } : {}), { data }), projections.length > 0 ? { projections } : {}), model.assembleGroup([
    ...layoutSignals,
    ...model.assembleSelectionTopLevelSignals([]),
    ...assembleParameterSignals(params)
  ])), vgConfig ? { config: vgConfig } : {}), usermeta ? { usermeta } : {});
}

// node_modules/vega-lite/build/src/index.js
var version2 = package_default.version;

// node_modules/vega-schema-url-parser/dist/parser.module.js
function e(e2) {
  const [n, r] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(e2).slice(1, 3);
  return { library: n, version: r };
}
var parser_module_default = e;

// node_modules/vega-themes/build/vega-themes.module.js
var vega_themes_module_exports = {};
__export(vega_themes_module_exports, {
  dark: () => darkTheme,
  excel: () => excelTheme,
  fivethirtyeight: () => fiveThirtyEightTheme,
  ggplot2: () => ggplot2Theme,
  googlecharts: () => googlechartsTheme,
  latimes: () => latimesTheme,
  quartz: () => quartzTheme,
  urbaninstitute: () => urbanInstituteTheme,
  version: () => version$1,
  vox: () => voxTheme
});
var name2 = "vega-themes";
var version3 = "2.10.0";
var description3 = "Themes for stylized Vega and Vega-Lite visualizations.";
var keywords2 = [
  "vega",
  "vega-lite",
  "themes",
  "style"
];
var license2 = "BSD-3-Clause";
var author2 = {
  name: "UW Interactive Data Lab",
  url: "https://idl.cs.washington.edu"
};
var contributors = [
  {
    name: "Emily Gu",
    url: "https://github.com/emilygu"
  },
  {
    name: "Arvind Satyanarayan",
    url: "http://arvindsatya.com"
  },
  {
    name: "Jeffrey Heer",
    url: "https://idl.cs.washington.edu"
  },
  {
    name: "Dominik Moritz",
    url: "https://www.domoritz.de"
  }
];
var main2 = "build/vega-themes.js";
var module2 = "build/vega-themes.module.js";
var unpkg2 = "build/vega-themes.min.js";
var jsdelivr2 = "build/vega-themes.min.js";
var types2 = "build/vega-themes.module.d.ts";
var repository2 = {
  type: "git",
  url: "https://github.com/vega/vega-themes.git"
};
var files2 = [
  "src",
  "build"
];
var scripts2 = {
  prebuild: "yarn clean",
  build: "rollup -c",
  clean: "rimraf build && rimraf examples/build",
  "copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
  "copy:build": "rsync -r build/* examples/build",
  "deploy:gh": "yarn build && mkdir -p examples/build && rsync -r build/* examples/build && gh-pages -d examples",
  prepublishOnly: "yarn clean && yarn build",
  preversion: "yarn lint",
  serve: "browser-sync start -s -f build examples --serveStatic examples",
  start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
  prepare: "beemo create-config",
  eslintbase: "beemo eslint .",
  format: "yarn eslintbase --fix",
  lint: "yarn eslintbase"
};
var devDependencies2 = {
  "@rollup/plugin-json": "^4.1.0",
  "@rollup/plugin-node-resolve": "^11.2.0",
  "@wessberg/rollup-plugin-ts": "^1.3.8",
  "browser-sync": "^2.26.14",
  concurrently: "^6.0.0",
  "gh-pages": "^3.1.0",
  rollup: "^2.39.1",
  "rollup-plugin-bundle-size": "^1.0.3",
  "rollup-plugin-terser": "^7.0.2",
  typescript: "^4.2.2",
  vega: "^5.19.1",
  "vega-lite": "^5.0.0",
  "vega-lite-dev-config": "^0.16.1"
};
var peerDependencies2 = {
  vega: "*",
  "vega-lite": "*"
};
var pkg = {
  name: name2,
  version: version3,
  description: description3,
  keywords: keywords2,
  license: license2,
  author: author2,
  contributors,
  main: main2,
  module: module2,
  unpkg: unpkg2,
  jsdelivr: jsdelivr2,
  types: types2,
  repository: repository2,
  files: files2,
  scripts: scripts2,
  devDependencies: devDependencies2,
  peerDependencies: peerDependencies2
};
var lightColor = "#fff";
var medColor = "#888";
var darkTheme = {
  background: "#333",
  title: {
    color: lightColor,
    subtitleColor: lightColor
  },
  style: {
    "guide-label": {
      fill: lightColor
    },
    "guide-title": {
      fill: lightColor
    }
  },
  axis: {
    domainColor: lightColor,
    gridColor: medColor,
    tickColor: lightColor
  }
};
var markColor = "#4572a7";
var excelTheme = {
  background: "#fff",
  arc: { fill: markColor },
  area: { fill: markColor },
  line: { stroke: markColor, strokeWidth: 2 },
  path: { stroke: markColor },
  rect: { fill: markColor },
  shape: { stroke: markColor },
  symbol: { fill: markColor, strokeWidth: 1.5, size: 50 },
  axis: {
    bandPosition: 0.5,
    grid: true,
    gridColor: "#000000",
    gridOpacity: 1,
    gridWidth: 0.5,
    labelPadding: 10,
    tickSize: 5,
    tickWidth: 0.5
  },
  axisBand: {
    grid: false,
    tickExtra: true
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 50,
    symbolType: "square"
  },
  range: {
    category: [
      "#4572a7",
      "#aa4643",
      "#8aa453",
      "#71598e",
      "#4598ae",
      "#d98445",
      "#94aace",
      "#d09393",
      "#b9cc98",
      "#a99cbc"
    ]
  }
};
var markColor$1 = "#30a2da";
var axisColor = "#cbcbcb";
var guideLabelColor = "#999";
var guideTitleColor = "#333";
var backgroundColor = "#f0f0f0";
var blackTitle = "#333";
var fiveThirtyEightTheme = {
  arc: { fill: markColor$1 },
  area: { fill: markColor$1 },
  axis: {
    domainColor: axisColor,
    grid: true,
    gridColor: axisColor,
    gridWidth: 1,
    labelColor: guideLabelColor,
    labelFontSize: 10,
    titleColor: guideTitleColor,
    tickColor: axisColor,
    tickSize: 10,
    titleFontSize: 14,
    titlePadding: 10,
    labelPadding: 4
  },
  axisBand: {
    grid: false
  },
  background: backgroundColor,
  group: {
    fill: backgroundColor
  },
  legend: {
    labelColor: blackTitle,
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square",
    titleColor: blackTitle,
    titleFontSize: 14,
    titlePadding: 10
  },
  line: {
    stroke: markColor$1,
    strokeWidth: 2
  },
  path: { stroke: markColor$1, strokeWidth: 0.5 },
  rect: { fill: markColor$1 },
  range: {
    category: [
      "#30a2da",
      "#fc4f30",
      "#e5ae38",
      "#6d904f",
      "#8b8b8b",
      "#b96db8",
      "#ff9e27",
      "#56cc60",
      "#52d2ca",
      "#52689e",
      "#545454",
      "#9fe4f8"
    ],
    diverging: ["#cc0020", "#e77866", "#f6e7e1", "#d6e8ed", "#91bfd9", "#1d78b5"],
    heatmap: ["#d6e8ed", "#cee0e5", "#91bfd9", "#549cc6", "#1d78b5"]
  },
  point: {
    filled: true,
    shape: "circle"
  },
  shape: { stroke: markColor$1 },
  bar: {
    binSpacing: 2,
    fill: markColor$1,
    stroke: null
  },
  title: {
    anchor: "start",
    fontSize: 24,
    fontWeight: 600,
    offset: 20
  }
};
var markColor$2 = "#000";
var ggplot2Theme = {
  group: {
    fill: "#e5e5e5"
  },
  arc: { fill: markColor$2 },
  area: { fill: markColor$2 },
  line: { stroke: markColor$2 },
  path: { stroke: markColor$2 },
  rect: { fill: markColor$2 },
  shape: { stroke: markColor$2 },
  symbol: { fill: markColor$2, size: 40 },
  axis: {
    domain: false,
    grid: true,
    gridColor: "#FFFFFF",
    gridOpacity: 1,
    labelColor: "#7F7F7F",
    labelPadding: 4,
    tickColor: "#7F7F7F",
    tickSize: 5.67,
    titleFontSize: 16,
    titleFontWeight: "normal"
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 40
  },
  range: {
    category: [
      "#000000",
      "#7F7F7F",
      "#1A1A1A",
      "#999999",
      "#333333",
      "#B0B0B0",
      "#4D4D4D",
      "#C9C9C9",
      "#666666",
      "#DCDCDC"
    ]
  }
};
var headlineFontSize = 22;
var headlineFontWeight = "normal";
var labelFont = "Benton Gothic, sans-serif";
var labelFontSize = 11.5;
var labelFontWeight = "normal";
var markColor$3 = "#82c6df";
var titleFont = "Benton Gothic Bold, sans-serif";
var titleFontWeight = "normal";
var titleFontSize = 13;
var colorSchemes = {
  "category-6": ["#ec8431", "#829eb1", "#c89d29", "#3580b1", "#adc839", "#ab7fb4"],
  "fire-7": ["#fbf2c7", "#f9e39c", "#f8d36e", "#f4bb6a", "#e68a4f", "#d15a40", "#ab4232"],
  "fireandice-6": ["#e68a4f", "#f4bb6a", "#f9e39c", "#dadfe2", "#a6b7c6", "#849eae"],
  "ice-7": ["#edefee", "#dadfe2", "#c4ccd2", "#a6b7c6", "#849eae", "#607785", "#47525d"]
};
var latimesTheme = {
  background: "#ffffff",
  title: {
    anchor: "start",
    color: "#000000",
    font: titleFont,
    fontSize: headlineFontSize,
    fontWeight: headlineFontWeight
  },
  arc: { fill: markColor$3 },
  area: { fill: markColor$3 },
  line: { stroke: markColor$3, strokeWidth: 2 },
  path: { stroke: markColor$3 },
  rect: { fill: markColor$3 },
  shape: { stroke: markColor$3 },
  symbol: { fill: markColor$3, size: 30 },
  axis: {
    labelFont,
    labelFontSize,
    labelFontWeight,
    titleFont,
    titleFontSize,
    titleFontWeight
  },
  axisX: {
    labelAngle: 0,
    labelPadding: 4,
    tickSize: 3
  },
  axisY: {
    labelBaseline: "middle",
    maxExtent: 45,
    minExtent: 45,
    tickSize: 2,
    titleAlign: "left",
    titleAngle: 0,
    titleX: -45,
    titleY: -11
  },
  legend: {
    labelFont,
    labelFontSize,
    symbolType: "square",
    titleFont,
    titleFontSize,
    titleFontWeight
  },
  range: {
    category: colorSchemes["category-6"],
    diverging: colorSchemes["fireandice-6"],
    heatmap: colorSchemes["fire-7"],
    ordinal: colorSchemes["fire-7"],
    ramp: colorSchemes["fire-7"]
  }
};
var markColor$4 = "#ab5787";
var axisColor$1 = "#979797";
var quartzTheme = {
  background: "#f9f9f9",
  arc: { fill: markColor$4 },
  area: { fill: markColor$4 },
  line: { stroke: markColor$4 },
  path: { stroke: markColor$4 },
  rect: { fill: markColor$4 },
  shape: { stroke: markColor$4 },
  symbol: { fill: markColor$4, size: 30 },
  axis: {
    domainColor: axisColor$1,
    domainWidth: 0.5,
    gridWidth: 0.2,
    labelColor: axisColor$1,
    tickColor: axisColor$1,
    tickWidth: 0.2,
    titleColor: axisColor$1
  },
  axisBand: {
    grid: false
  },
  axisX: {
    grid: true,
    tickSize: 10
  },
  axisY: {
    domain: false,
    grid: true,
    tickSize: 0
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square"
  },
  range: {
    category: [
      "#ab5787",
      "#51b2e5",
      "#703c5c",
      "#168dd9",
      "#d190b6",
      "#00609f",
      "#d365ba",
      "#154866",
      "#666666",
      "#c4c4c4"
    ]
  }
};
var markColor$5 = "#3e5c69";
var voxTheme = {
  background: "#fff",
  arc: { fill: markColor$5 },
  area: { fill: markColor$5 },
  line: { stroke: markColor$5 },
  path: { stroke: markColor$5 },
  rect: { fill: markColor$5 },
  shape: { stroke: markColor$5 },
  symbol: { fill: markColor$5 },
  axis: {
    domainWidth: 0.5,
    grid: true,
    labelPadding: 2,
    tickSize: 5,
    tickWidth: 0.5,
    titleFontWeight: "normal"
  },
  axisBand: {
    grid: false
  },
  axisX: {
    gridWidth: 0.2
  },
  axisY: {
    gridDash: [3],
    gridWidth: 0.4
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolType: "square"
  },
  range: {
    category: ["#3e5c69", "#6793a6", "#182429", "#0570b0", "#3690c0", "#74a9cf", "#a6bddb", "#e2ddf2"]
  }
};
var markColor$6 = "#1696d2";
var axisColor$2 = "#000000";
var backgroundColor$1 = "#FFFFFF";
var font = "Lato";
var labelFont$1 = "Lato";
var sourceFont = "Lato";
var gridColor = "#DEDDDD";
var titleFontSize$1 = 18;
var colorSchemes$1 = {
  "main-colors": ["#1696d2", "#d2d2d2", "#000000", "#fdbf11", "#ec008b", "#55b748", "#5c5859", "#db2b27"],
  "shades-blue": ["#CFE8F3", "#A2D4EC", "#73BFE2", "#46ABDB", "#1696D2", "#12719E", "#0A4C6A", "#062635"],
  "shades-gray": ["#F5F5F5", "#ECECEC", "#E3E3E3", "#DCDBDB", "#D2D2D2", "#9D9D9D", "#696969", "#353535"],
  "shades-yellow": ["#FFF2CF", "#FCE39E", "#FDD870", "#FCCB41", "#FDBF11", "#E88E2D", "#CA5800", "#843215"],
  "shades-magenta": ["#F5CBDF", "#EB99C2", "#E46AA7", "#E54096", "#EC008B", "#AF1F6B", "#761548", "#351123"],
  "shades-green": ["#DCEDD9", "#BCDEB4", "#98CF90", "#78C26D", "#55B748", "#408941", "#2C5C2D", "#1A2E19"],
  "shades-black": ["#D5D5D4", "#ADABAC", "#848081", "#5C5859", "#332D2F", "#262223", "#1A1717", "#0E0C0D"],
  "shades-red": ["#F8D5D4", "#F1AAA9", "#E9807D", "#E25552", "#DB2B27", "#A4201D", "#6E1614", "#370B0A"],
  "one-group": ["#1696d2", "#000000"],
  "two-groups-cat-1": ["#1696d2", "#000000"],
  "two-groups-cat-2": ["#1696d2", "#fdbf11"],
  "two-groups-cat-3": ["#1696d2", "#db2b27"],
  "two-groups-seq": ["#a2d4ec", "#1696d2"],
  "three-groups-cat": ["#1696d2", "#fdbf11", "#000000"],
  "three-groups-seq": ["#a2d4ec", "#1696d2", "#0a4c6a"],
  "four-groups-cat-1": ["#000000", "#d2d2d2", "#fdbf11", "#1696d2"],
  "four-groups-cat-2": ["#1696d2", "#ec0008b", "#fdbf11", "#5c5859"],
  "four-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a"],
  "five-groups-cat-1": ["#1696d2", "#fdbf11", "#d2d2d2", "#ec008b", "#000000"],
  "five-groups-cat-2": ["#1696d2", "#0a4c6a", "#d2d2d2", "#fdbf11", "#332d2f"],
  "five-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a", "#000000"],
  "six-groups-cat-1": ["#1696d2", "#ec008b", "#fdbf11", "#000000", "#d2d2d2", "#55b748"],
  "six-groups-cat-2": ["#1696d2", "#d2d2d2", "#ec008b", "#fdbf11", "#332d2f", "#0a4c6a"],
  "six-groups-seq": ["#cfe8f3", "#a2d4ec", "#73bfe2", "#46abdb", "#1696d2", "#12719e"],
  "diverging-colors": ["#ca5800", "#fdbf11", "#fdd870", "#fff2cf", "#cfe8f3", "#73bfe2", "#1696d2", "#0a4c6a"]
};
var urbanInstituteTheme = {
  background: backgroundColor$1,
  title: {
    anchor: "start",
    fontSize: titleFontSize$1,
    font
  },
  axisX: {
    domain: true,
    domainColor: axisColor$2,
    domainWidth: 1,
    grid: false,
    labelFontSize: 12,
    labelFont: labelFont$1,
    labelAngle: 0,
    tickColor: axisColor$2,
    tickSize: 5,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: font
  },
  axisY: {
    domain: false,
    domainWidth: 1,
    grid: true,
    gridColor,
    gridWidth: 1,
    labelFontSize: 12,
    labelFont: labelFont$1,
    labelPadding: 8,
    ticks: false,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: font,
    titleAngle: 0,
    titleY: -10,
    titleX: 18
  },
  legend: {
    labelFontSize: 12,
    labelFont: labelFont$1,
    symbolSize: 100,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: font,
    orient: "right",
    offset: 10
  },
  view: {
    stroke: "transparent"
  },
  range: {
    category: colorSchemes$1["six-groups-cat-1"],
    diverging: colorSchemes$1["diverging-colors"],
    heatmap: colorSchemes$1["diverging-colors"],
    ordinal: colorSchemes$1["six-groups-seq"],
    ramp: colorSchemes$1["shades-blue"]
  },
  area: {
    fill: markColor$6
  },
  rect: {
    fill: markColor$6
  },
  line: {
    color: markColor$6,
    stroke: markColor$6,
    strokeWidth: 5
  },
  trail: {
    color: markColor$6,
    stroke: markColor$6,
    strokeWidth: 0,
    size: 1
  },
  path: {
    stroke: markColor$6,
    strokeWidth: 0.5
  },
  point: {
    filled: true
  },
  text: {
    font: sourceFont,
    color: markColor$6,
    fontSize: 11,
    align: "center",
    fontWeight: 400,
    size: 11
  },
  style: {
    bar: {
      fill: markColor$6,
      stroke: null
    }
  },
  arc: { fill: markColor$6 },
  shape: { stroke: markColor$6 },
  symbol: { fill: markColor$6, size: 30 }
};
var markColor$7 = "#3366CC";
var gridColor$1 = "#ccc";
var defaultFont = "Arial, sans-serif";
var googlechartsTheme = {
  arc: { fill: markColor$7 },
  area: { fill: markColor$7 },
  path: { stroke: markColor$7 },
  rect: { fill: markColor$7 },
  shape: { stroke: markColor$7 },
  symbol: { stroke: markColor$7 },
  circle: { fill: markColor$7 },
  background: "#fff",
  padding: {
    top: 10,
    right: 10,
    bottom: 10,
    left: 10
  },
  style: {
    "guide-label": {
      font: defaultFont,
      fontSize: 12
    },
    "guide-title": {
      font: defaultFont,
      fontSize: 12
    },
    "group-title": {
      font: defaultFont,
      fontSize: 12
    }
  },
  title: {
    font: defaultFont,
    fontSize: 14,
    fontWeight: "bold",
    dy: -3,
    anchor: "start"
  },
  axis: {
    gridColor: gridColor$1,
    tickColor: gridColor$1,
    domain: false,
    grid: true
  },
  range: {
    category: [
      "#4285F4",
      "#DB4437",
      "#F4B400",
      "#0F9D58",
      "#AB47BC",
      "#00ACC1",
      "#FF7043",
      "#9E9D24",
      "#5C6BC0",
      "#F06292",
      "#00796B",
      "#C2185B"
    ],
    heatmap: ["#c6dafc", "#5e97f6", "#2a56c6"]
  }
};
var version$1 = pkg.version;

// node_modules/vega-tooltip/build/vega-tooltip.module.js
var name3 = "vega-tooltip";
var version$12 = "0.27.0";
var description4 = "A tooltip plugin for Vega-Lite and Vega visualizations.";
var keywords3 = [
  "vega-lite",
  "vega",
  "tooltip"
];
var repository3 = {
  type: "git",
  url: "https://github.com/vega/vega-tooltip.git"
};
var author3 = {
  name: "UW Interactive Data Lab",
  url: "https://idl.cs.washington.edu"
};
var collaborators2 = [
  "Dominik Moritz",
  "Sira Horradarn",
  "Zening Qu",
  "Kanit Wongsuphasawat",
  "Yuri Astrakhan",
  "Jeffrey Heer"
];
var license3 = "BSD-3-Clause";
var bugs2 = {
  url: "https://github.com/vega/vega-tooltip/issues"
};
var homepage2 = "https://github.com/vega/vega-tooltip#readme";
var main3 = "build/vega-tooltip.js";
var module3 = "build/vega-tooltip.module.js";
var unpkg3 = "build/vega-tooltip.min.js";
var jsdelivr3 = "build/vega-tooltip.min.js";
var types3 = "build/vega-tooltip.module.d.ts";
var files3 = [
  "src",
  "build",
  "types"
];
var scripts3 = {
  prebuild: "yarn clean && yarn build:style",
  build: "rollup -c",
  "build:style": "./build-style.sh",
  clean: "rimraf build && rimraf src/style.ts",
  "copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
  "copy:build": "rsync -r build/* examples/build",
  "deploy:gh": "yarn build && yarn copy:build && gh-pages -d examples && yarn clean",
  prepublishOnly: "yarn clean && yarn build",
  preversion: "yarn lint && yarn test",
  serve: "browser-sync start -s -f build examples --serveStatic examples",
  start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
  pretest: "yarn build:style",
  test: "beemo jest",
  "test:inspect": "node --inspect-brk ./node_modules/.bin/jest --runInBand",
  prepare: "beemo create-config && yarn copy:data",
  prettierbase: "beemo prettier '*.{css,scss,html}'",
  eslintbase: "beemo eslint .",
  format: "yarn eslintbase --fix && yarn prettierbase --write",
  lint: "yarn eslintbase && yarn prettierbase --check",
  release: "yarn run prebuild && yarn build && auto shipit"
};
var devDependencies3 = {
  "@auto-it/conventional-commits": "^10.30.0",
  "@auto-it/first-time-contributor": "^10.30.0",
  "@rollup/plugin-json": "^4.1.0",
  "@rollup/plugin-node-resolve": "^13.0.0",
  "@wessberg/rollup-plugin-ts": "^1.3.8",
  auto: "^10.30.0",
  "browser-sync": "^2.26.14",
  concurrently: "^6.0.0",
  "gh-pages": "^3.1.0",
  "node-sass": "^6.0.0",
  path: "^0.12.7",
  rollup: "^2.39.1",
  "rollup-plugin-bundle-size": "^1.0.3",
  "rollup-plugin-terser": "^7.0.2",
  typescript: "~4.3.2",
  "vega-datasets": "^2.2.0",
  "vega-lite-dev-config": "^0.18.0",
  "vega-typings": "^0.21.0"
};
var dependencies2 = {
  "vega-util": "^1.16.0"
};
var pkg2 = {
  name: name3,
  version: version$12,
  description: description4,
  keywords: keywords3,
  repository: repository3,
  author: author3,
  collaborators: collaborators2,
  license: license3,
  bugs: bugs2,
  homepage: homepage2,
  main: main3,
  module: module3,
  unpkg: unpkg3,
  jsdelivr: jsdelivr3,
  types: types3,
  files: files3,
  scripts: scripts3,
  devDependencies: devDependencies3,
  dependencies: dependencies2
};
function __rest31(s, e2) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
}
function formatValue(value, valueToHtml, maxDepth) {
  if (isArray(value)) {
    return `[${value.map((v) => valueToHtml(isString(v) ? v : stringify2(v, maxDepth))).join(", ")}]`;
  }
  if (isObject(value)) {
    let content = "";
    const _a = value, { title: title2, image: image2 } = _a, rest = __rest31(_a, ["title", "image"]);
    if (title2) {
      content += `<h2>${valueToHtml(title2)}</h2>`;
    }
    if (image2) {
      content += `<img src="${valueToHtml(image2)}">`;
    }
    const keys3 = Object.keys(rest);
    if (keys3.length > 0) {
      content += "<table>";
      for (const key of keys3) {
        let val = rest[key];
        if (val === void 0) {
          continue;
        }
        if (isObject(val)) {
          val = stringify2(val, maxDepth);
        }
        content += `<tr><td class="key">${valueToHtml(key)}:</td><td class="value">${valueToHtml(val)}</td></tr>`;
      }
      content += `</table>`;
    }
    return content || "{}";
  }
  return valueToHtml(value);
}
function replacer(maxDepth) {
  const stack2 = [];
  return function(key, value) {
    if (typeof value !== "object" || value === null) {
      return value;
    }
    const pos = stack2.indexOf(this) + 1;
    stack2.length = pos;
    if (stack2.length > maxDepth) {
      return "[Object]";
    }
    if (stack2.indexOf(value) >= 0) {
      return "[Circular]";
    }
    stack2.push(value);
    return value;
  };
}
function stringify2(obj, maxDepth) {
  return JSON.stringify(obj, replacer(maxDepth));
}
var defaultStyle = `#vg-tooltip-element {
  visibility: hidden;
  padding: 8px;
  position: fixed;
  z-index: 1000;
  font-family: sans-serif;
  font-size: 11px;
  border-radius: 3px;
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  /* The default theme is the light theme. */
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #d9d9d9;
  color: black; }
  #vg-tooltip-element.visible {
    visibility: visible; }
  #vg-tooltip-element h2 {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 13px; }
  #vg-tooltip-element img {
    max-width: 200px;
    max-height: 200px; }
  #vg-tooltip-element table {
    border-spacing: 0; }
    #vg-tooltip-element table tr {
      border: none; }
      #vg-tooltip-element table tr td {
        overflow: hidden;
        text-overflow: ellipsis;
        padding-top: 2px;
        padding-bottom: 2px; }
        #vg-tooltip-element table tr td.key {
          color: #808080;
          max-width: 150px;
          text-align: right;
          padding-right: 4px; }
        #vg-tooltip-element table tr td.value {
          display: block;
          max-width: 300px;
          max-height: 7em;
          text-align: left; }
  #vg-tooltip-element.dark-theme {
    background-color: rgba(32, 32, 32, 0.9);
    border: 1px solid #f5f5f5;
    color: white; }
    #vg-tooltip-element.dark-theme td.key {
      color: #bfbfbf; }
`;
var EL_ID = "vg-tooltip-element";
var DEFAULT_OPTIONS = {
  offsetX: 10,
  offsetY: 10,
  id: EL_ID,
  styleId: "vega-tooltip-style",
  theme: "light",
  disableDefaultStyle: false,
  sanitize: escapeHTML,
  maxDepth: 2,
  formatTooltip: formatValue
};
function escapeHTML(value) {
  return String(value).replace(/&/g, "&amp;").replace(/</g, "&lt;");
}
function createDefaultStyle(id) {
  if (!/^[A-Za-z]+[-:.\w]*$/.test(id)) {
    throw new Error("Invalid HTML ID");
  }
  return defaultStyle.toString().replace(EL_ID, id);
}
function calculatePosition(event, tooltipBox, offsetX, offsetY) {
  let x = event.clientX + offsetX;
  if (x + tooltipBox.width > window.innerWidth) {
    x = +event.clientX - offsetX - tooltipBox.width;
  }
  let y = event.clientY + offsetY;
  if (y + tooltipBox.height > window.innerHeight) {
    y = +event.clientY - offsetY - tooltipBox.height;
  }
  return { x, y };
}
var Handler = class {
  constructor(options) {
    this.options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    const elementId = this.options.id;
    this.el = null;
    this.call = this.tooltipHandler.bind(this);
    if (!this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
      const style = document.createElement("style");
      style.setAttribute("id", this.options.styleId);
      style.innerHTML = createDefaultStyle(elementId);
      const head = document.head;
      if (head.childNodes.length > 0) {
        head.insertBefore(style, head.childNodes[0]);
      } else {
        head.appendChild(style);
      }
    }
  }
  tooltipHandler(handler, event, item, value) {
    var _a;
    this.el = document.getElementById(this.options.id);
    if (!this.el) {
      this.el = document.createElement("div");
      this.el.setAttribute("id", this.options.id);
      this.el.classList.add("vg-tooltip");
      document.body.appendChild(this.el);
    }
    const tooltipContainer = (_a = document.fullscreenElement) !== null && _a !== void 0 ? _a : document.body;
    tooltipContainer.appendChild(this.el);
    if (value == null || value === "") {
      this.el.classList.remove("visible", `${this.options.theme}-theme`);
      return;
    }
    this.el.innerHTML = this.options.formatTooltip(value, this.options.sanitize, this.options.maxDepth);
    this.el.classList.add("visible", `${this.options.theme}-theme`);
    const { x, y } = calculatePosition(event, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
    this.el.setAttribute("style", `top: ${y}px; left: ${x}px`);
  }
};
var version4 = pkg2.version;

// node_modules/vega-embed/build/vega-embed.module.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error2) {
    reject(error2);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var Op = Object.prototype;
var hasOwn = Op.hasOwnProperty;
var undefined$1;
var $Symbol = typeof Symbol === "function" ? Symbol : {};
var iteratorSymbol = $Symbol.iterator || "@@iterator";
var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
function wrap(innerFn, outerFn, self, tryLocsList) {
  var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
  var generator = Object.create(protoGenerator.prototype);
  var context = new Context(tryLocsList || []);
  generator._invoke = makeInvokeMethod(innerFn, self, context);
  return generator;
}
function tryCatch(fn, obj, arg) {
  try {
    return {
      type: "normal",
      arg: fn.call(obj, arg)
    };
  } catch (err) {
    return {
      type: "throw",
      arg: err
    };
  }
}
var GenStateSuspendedStart = "suspendedStart";
var GenStateSuspendedYield = "suspendedYield";
var GenStateExecuting = "executing";
var GenStateCompleted = "completed";
var ContinueSentinel = {};
function Generator() {
}
function GeneratorFunction() {
}
function GeneratorFunctionPrototype() {
}
var IteratorPrototype = {};
IteratorPrototype[iteratorSymbol] = function() {
  return this;
};
var getProto = Object.getPrototypeOf;
var NativeIteratorPrototype = getProto && getProto(getProto(values3([])));
if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
  IteratorPrototype = NativeIteratorPrototype;
}
var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
GeneratorFunctionPrototype.constructor = GeneratorFunction;
GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
function defineIteratorMethods(prototype) {
  ["next", "throw", "return"].forEach(function(method) {
    prototype[method] = function(arg) {
      return this._invoke(method, arg);
    };
  });
}
function isGeneratorFunction(genFun) {
  var ctor = typeof genFun === "function" && genFun.constructor;
  return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
}
function mark2(genFun) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
  } else {
    genFun.__proto__ = GeneratorFunctionPrototype;
    if (!(toStringTagSymbol in genFun)) {
      genFun[toStringTagSymbol] = "GeneratorFunction";
    }
  }
  genFun.prototype = Object.create(Gp);
  return genFun;
}
function awrap(arg) {
  return {
    __await: arg
  };
}
function AsyncIterator(generator, PromiseImpl) {
  function invoke(method, arg, resolve, reject) {
    var record = tryCatch(generator[method], generator, arg);
    if (record.type === "throw") {
      reject(record.arg);
    } else {
      var result = record.arg;
      var value = result.value;
      if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
        return PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        });
      }
      return PromiseImpl.resolve(value).then(function(unwrapped) {
        result.value = unwrapped;
        resolve(result);
      }, function(error2) {
        return invoke("throw", error2, resolve, reject);
      });
    }
  }
  var previousPromise;
  function enqueue(method, arg) {
    function callInvokeWithMethodAndArg() {
      return new PromiseImpl(function(resolve, reject) {
        invoke(method, arg, resolve, reject);
      });
    }
    return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
  }
  this._invoke = enqueue;
}
defineIteratorMethods(AsyncIterator.prototype);
AsyncIterator.prototype[asyncIteratorSymbol] = function() {
  return this;
};
function async(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
  if (PromiseImpl === void 0)
    PromiseImpl = Promise;
  var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
  return isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
    return result.done ? result.value : iter.next();
  });
}
function makeInvokeMethod(innerFn, self, context) {
  var state = GenStateSuspendedStart;
  return function invoke(method, arg) {
    if (state === GenStateExecuting) {
      throw new Error("Generator is already running");
    }
    if (state === GenStateCompleted) {
      if (method === "throw") {
        throw arg;
      }
      return doneResult();
    }
    context.method = method;
    context.arg = arg;
    while (true) {
      var delegate = context.delegate;
      if (delegate) {
        var delegateResult = maybeInvokeDelegate(delegate, context);
        if (delegateResult) {
          if (delegateResult === ContinueSentinel)
            continue;
          return delegateResult;
        }
      }
      if (context.method === "next") {
        context.sent = context._sent = context.arg;
      } else if (context.method === "throw") {
        if (state === GenStateSuspendedStart) {
          state = GenStateCompleted;
          throw context.arg;
        }
        context.dispatchException(context.arg);
      } else if (context.method === "return") {
        context.abrupt("return", context.arg);
      }
      state = GenStateExecuting;
      var record = tryCatch(innerFn, self, context);
      if (record.type === "normal") {
        state = context.done ? GenStateCompleted : GenStateSuspendedYield;
        if (record.arg === ContinueSentinel) {
          continue;
        }
        return {
          value: record.arg,
          done: context.done
        };
      } else if (record.type === "throw") {
        state = GenStateCompleted;
        context.method = "throw";
        context.arg = record.arg;
      }
    }
  };
}
function maybeInvokeDelegate(delegate, context) {
  var method = delegate.iterator[context.method];
  if (method === undefined$1) {
    context.delegate = null;
    if (context.method === "throw") {
      if (delegate.iterator["return"]) {
        context.method = "return";
        context.arg = undefined$1;
        maybeInvokeDelegate(delegate, context);
        if (context.method === "throw") {
          return ContinueSentinel;
        }
      }
      context.method = "throw";
      context.arg = new TypeError("The iterator does not provide a 'throw' method");
    }
    return ContinueSentinel;
  }
  var record = tryCatch(method, delegate.iterator, context.arg);
  if (record.type === "throw") {
    context.method = "throw";
    context.arg = record.arg;
    context.delegate = null;
    return ContinueSentinel;
  }
  var info = record.arg;
  if (!info) {
    context.method = "throw";
    context.arg = new TypeError("iterator result is not an object");
    context.delegate = null;
    return ContinueSentinel;
  }
  if (info.done) {
    context[delegate.resultName] = info.value;
    context.next = delegate.nextLoc;
    if (context.method !== "return") {
      context.method = "next";
      context.arg = undefined$1;
    }
  } else {
    return info;
  }
  context.delegate = null;
  return ContinueSentinel;
}
defineIteratorMethods(Gp);
Gp[toStringTagSymbol] = "Generator";
Gp[iteratorSymbol] = function() {
  return this;
};
Gp.toString = function() {
  return "[object Generator]";
};
function pushTryEntry(locs) {
  var entry = {
    tryLoc: locs[0]
  };
  if (1 in locs) {
    entry.catchLoc = locs[1];
  }
  if (2 in locs) {
    entry.finallyLoc = locs[2];
    entry.afterLoc = locs[3];
  }
  this.tryEntries.push(entry);
}
function resetTryEntry(entry) {
  var record = entry.completion || {};
  record.type = "normal";
  delete record.arg;
  entry.completion = record;
}
function Context(tryLocsList) {
  this.tryEntries = [{
    tryLoc: "root"
  }];
  tryLocsList.forEach(pushTryEntry, this);
  this.reset(true);
}
function keys2(object) {
  var keys3 = [];
  for (var key in object) {
    keys3.push(key);
  }
  keys3.reverse();
  return function next() {
    while (keys3.length) {
      var key2 = keys3.pop();
      if (key2 in object) {
        next.value = key2;
        next.done = false;
        return next;
      }
    }
    next.done = true;
    return next;
  };
}
function values3(iterable) {
  if (iterable) {
    var iteratorMethod = iterable[iteratorSymbol];
    if (iteratorMethod) {
      return iteratorMethod.call(iterable);
    }
    if (typeof iterable.next === "function") {
      return iterable;
    }
    if (!isNaN(iterable.length)) {
      var i = -1, next = function next2() {
        while (++i < iterable.length) {
          if (hasOwn.call(iterable, i)) {
            next2.value = iterable[i];
            next2.done = false;
            return next2;
          }
        }
        next2.value = undefined$1;
        next2.done = true;
        return next2;
      };
      return next.next = next;
    }
  }
  return {
    next: doneResult
  };
}
function doneResult() {
  return {
    value: undefined$1,
    done: true
  };
}
Context.prototype = {
  constructor: Context,
  reset: function reset2(skipTempReset) {
    this.prev = 0;
    this.next = 0;
    this.sent = this._sent = undefined$1;
    this.done = false;
    this.delegate = null;
    this.method = "next";
    this.arg = undefined$1;
    this.tryEntries.forEach(resetTryEntry);
    if (!skipTempReset) {
      for (var name5 in this) {
        if (name5.charAt(0) === "t" && hasOwn.call(this, name5) && !isNaN(+name5.slice(1))) {
          this[name5] = undefined$1;
        }
      }
    }
  },
  stop: function stop() {
    this.done = true;
    var rootEntry = this.tryEntries[0];
    var rootRecord = rootEntry.completion;
    if (rootRecord.type === "throw") {
      throw rootRecord.arg;
    }
    return this.rval;
  },
  dispatchException: function dispatchException(exception) {
    if (this.done) {
      throw exception;
    }
    var context = this;
    function handle(loc, caught) {
      record.type = "throw";
      record.arg = exception;
      context.next = loc;
      if (caught) {
        context.method = "next";
        context.arg = undefined$1;
      }
      return !!caught;
    }
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry = this.tryEntries[i];
      var record = entry.completion;
      if (entry.tryLoc === "root") {
        return handle("end");
      }
      if (entry.tryLoc <= this.prev) {
        var hasCatch = hasOwn.call(entry, "catchLoc");
        var hasFinally = hasOwn.call(entry, "finallyLoc");
        if (hasCatch && hasFinally) {
          if (this.prev < entry.catchLoc) {
            return handle(entry.catchLoc, true);
          } else if (this.prev < entry.finallyLoc) {
            return handle(entry.finallyLoc);
          }
        } else if (hasCatch) {
          if (this.prev < entry.catchLoc) {
            return handle(entry.catchLoc, true);
          }
        } else if (hasFinally) {
          if (this.prev < entry.finallyLoc) {
            return handle(entry.finallyLoc);
          }
        } else {
          throw new Error("try statement without catch or finally");
        }
      }
    }
  },
  abrupt: function abrupt(type, arg) {
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry = this.tryEntries[i];
      if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
        var finallyEntry = entry;
        break;
      }
    }
    if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
      finallyEntry = null;
    }
    var record = finallyEntry ? finallyEntry.completion : {};
    record.type = type;
    record.arg = arg;
    if (finallyEntry) {
      this.method = "next";
      this.next = finallyEntry.finallyLoc;
      return ContinueSentinel;
    }
    return this.complete(record);
  },
  complete: function complete(record, afterLoc) {
    if (record.type === "throw") {
      throw record.arg;
    }
    if (record.type === "break" || record.type === "continue") {
      this.next = record.arg;
    } else if (record.type === "return") {
      this.rval = this.arg = record.arg;
      this.method = "return";
      this.next = "end";
    } else if (record.type === "normal" && afterLoc) {
      this.next = afterLoc;
    }
    return ContinueSentinel;
  },
  finish: function finish(finallyLoc) {
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry = this.tryEntries[i];
      if (entry.finallyLoc === finallyLoc) {
        this.complete(entry.completion, entry.afterLoc);
        resetTryEntry(entry);
        return ContinueSentinel;
      }
    }
  },
  "catch": function _catch(tryLoc) {
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry = this.tryEntries[i];
      if (entry.tryLoc === tryLoc) {
        var record = entry.completion;
        if (record.type === "throw") {
          var thrown = record.arg;
          resetTryEntry(entry);
        }
        return thrown;
      }
    }
    throw new Error("illegal catch attempt");
  },
  delegateYield: function delegateYield(iterable, resultName, nextLoc) {
    this.delegate = {
      iterator: values3(iterable),
      resultName,
      nextLoc
    };
    if (this.method === "next") {
      this.arg = undefined$1;
    }
    return ContinueSentinel;
  }
};
var _regeneratorRuntime = {
  wrap,
  isGeneratorFunction,
  AsyncIterator,
  mark: mark2,
  awrap,
  async,
  keys: keys2,
  values: values3
};
var yallist = Yallist$1;
Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self = this;
  if (!(self instanceof Yallist$1)) {
    self = new Yallist$1();
  }
  self.tail = null;
  self.head = null;
  self.length = 0;
  if (list && typeof list.forEach === "function") {
    list.forEach(function(item) {
      self.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i]);
    }
  }
  return self;
}
Yallist$1.prototype.removeNode = function(node) {
  if (node.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }
  var next = node.next;
  var prev = node.prev;
  if (next) {
    next.prev = prev;
  }
  if (prev) {
    prev.next = next;
  }
  if (node === this.head) {
    this.head = next;
  }
  if (node === this.tail) {
    this.tail = prev;
  }
  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};
Yallist$1.prototype.unshiftNode = function(node) {
  if (node === this.head) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var head = this.head;
  node.list = this;
  node.next = head;
  if (head) {
    head.prev = node;
  }
  this.head = node;
  if (!this.tail) {
    this.tail = node;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function(node) {
  if (node === this.tail) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var tail = this.tail;
  node.list = this;
  node.prev = tail;
  if (tail) {
    tail.next = node;
  }
  this.tail = node;
  if (!this.head) {
    this.head = node;
  }
  this.length++;
};
Yallist$1.prototype.push = function() {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (!this.tail) {
    return void 0;
  }
  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.shift = function() {
  if (!this.head) {
    return void 0;
  }
  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.forEach = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function(n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    walker = walker.next;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function(n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    walker = walker.prev;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist$1.prototype.mapReverse = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist$1.prototype.reduce = function(fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function(fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist$1.prototype.toArrayReverse = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist$1.prototype.slice = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function(start, deleteCount) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }
  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i++) {
    walker = insert(this, walker, i + 2 < 2 || arguments.length <= i + 2 ? void 0 : arguments[i + 2]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function() {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert(self, node, value) {
  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
  if (inserted.next === null) {
    self.tail = inserted;
  }
  if (inserted.prev === null) {
    self.head = inserted;
  }
  self.length++;
  return inserted;
}
function push(self, item) {
  self.tail = new Node(item, self.tail, null, self);
  if (!self.head) {
    self.head = self.tail;
  }
  self.length++;
}
function unshift(self, item) {
  self.head = new Node(item, null, self.head, self);
  if (!self.tail) {
    self.tail = self.head;
  }
  self.length++;
}
function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }
  this.list = list;
  this.value = value;
  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }
  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}
try {
  __require("./iterator.js")(Yallist$1);
} catch (er) {
}
var Yallist = yallist;
var MAX = Symbol("max");
var LENGTH = Symbol("length");
var LENGTH_CALCULATOR = Symbol("lengthCalculator");
var ALLOW_STALE = Symbol("allowStale");
var MAX_AGE = Symbol("maxAge");
var DISPOSE = Symbol("dispose");
var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
var LRU_LIST = Symbol("lruList");
var CACHE = Symbol("cache");
var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
var naiveLength = () => 1;
var LRUCache = class {
  constructor(options) {
    if (typeof options === "number")
      options = {
        max: options
      };
    if (!options)
      options = {};
    if (options.max && (typeof options.max !== "number" || options.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[MAX] = options.max || Infinity;
    var lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }
  set max(mL) {
    if (typeof mL !== "number" || mL < 0)
      throw new TypeError("max must be a non-negative number");
    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  set lengthCalculator(lC) {
    if (typeof lC !== "function")
      lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach((hit) => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this[LRU_LIST].tail; walker !== null; ) {
      var prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this[LRU_LIST].head; walker !== null; ) {
      var next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((k) => k.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((k) => k.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
    }
    this[CACHE] = new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter((h) => h);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    var now = maxAge ? Date.now() : 0;
    var len = this[LENGTH_CALCULATOR](value, key);
    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false;
      }
      var node = this[CACHE].get(key);
      var item = node.value;
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value);
      }
      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }
    var hit = new Entry(key, value, len, now, maxAge);
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value);
      return false;
    }
    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key) {
    if (!this[CACHE].has(key))
      return false;
    var hit = this[CACHE].get(key).value;
    return !isStale(this, hit);
  }
  get(key) {
    return get(this, key, true);
  }
  peek(key) {
    return get(this, key, false);
  }
  pop() {
    var node = this[LRU_LIST].tail;
    if (!node)
      return null;
    del(this, node);
    return node.value;
  }
  del(key) {
    del(this, this[CACHE].get(key));
  }
  load(arr) {
    this.reset();
    var now = Date.now();
    for (var l = arr.length - 1; l >= 0; l--) {
      var hit = arr[l];
      var expiresAt = hit.e || 0;
      if (expiresAt === 0)
        this.set(hit.k, hit.v);
      else {
        var maxAge = expiresAt - now;
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE].forEach((value, key) => get(this, key, false));
  }
};
var get = (self, key, doUse) => {
  var node = self[CACHE].get(key);
  if (node) {
    var hit = node.value;
    if (isStale(self, hit)) {
      del(self, node);
      if (!self[ALLOW_STALE])
        return void 0;
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now();
        self[LRU_LIST].unshiftNode(node);
      }
    }
    return hit.value;
  }
};
var isStale = (self, hit) => {
  if (!hit || !hit.maxAge && !self[MAX_AGE])
    return false;
  var diff = Date.now() - hit.now;
  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};
var trim = (self) => {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
      var prev = walker.prev;
      del(self, walker);
      walker = prev;
    }
  }
};
var del = (self, node) => {
  if (node) {
    var hit = node.value;
    if (self[DISPOSE])
      self[DISPOSE](hit.key, hit.value);
    self[LENGTH] -= hit.length;
    self[CACHE].delete(hit.key);
    self[LRU_LIST].removeNode(node);
  }
};
var Entry = class {
  constructor(key, value, length2, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length2;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
};
var forEachStep = (self, fn, node, thisp) => {
  var hit = node.value;
  if (isStale(self, hit)) {
    del(self, node);
    if (!self[ALLOW_STALE])
      hit = void 0;
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self);
};
var lruCache = LRUCache;
var opts = ["includePrerelease", "loose", "rtl"];
var parseOptions$3 = (options) => !options ? {} : typeof options !== "object" ? {
  loose: true
} : opts.filter((k) => options[k]).reduce((options2, k) => {
  options2[k] = true;
  return options2;
}, {});
var parseOptions_1 = parseOptions$3;
var re$3 = { exports: {} };
var SEMVER_SPEC_VERSION = "2.0.0";
var MAX_LENGTH$1 = 256;
var MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;
var MAX_SAFE_COMPONENT_LENGTH = 16;
var constants = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  MAX_SAFE_COMPONENT_LENGTH
};
var debug$3 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return console.error("SEMVER", ...args);
} : () => {
};
var debug_1 = debug$3;
(function(module5, exports) {
  var MAX_SAFE_COMPONENT_LENGTH2 = constants.MAX_SAFE_COMPONENT_LENGTH;
  var debug3 = debug_1;
  exports = module5.exports = {};
  var re2 = exports.re = [];
  var src = exports.src = [];
  var t2 = exports.t = {};
  var R = 0;
  var createToken = (name5, value, isGlobal) => {
    var index2 = R++;
    debug3(index2, value);
    t2[name5] = index2;
    src[index2] = value;
    re2[index2] = new RegExp(value, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken("MAINVERSION", "(".concat(src[t2.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t2.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t2.NUMERICIDENTIFIER], ")"));
  createToken("MAINVERSIONLOOSE", "(".concat(src[t2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t2.NUMERICIDENTIFIERLOOSE], ")"));
  createToken("PRERELEASEIDENTIFIER", "(?:".concat(src[t2.NUMERICIDENTIFIER], "|").concat(src[t2.NONNUMERICIDENTIFIER], ")"));
  createToken("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(src[t2.NUMERICIDENTIFIERLOOSE], "|").concat(src[t2.NONNUMERICIDENTIFIER], ")"));
  createToken("PRERELEASE", "(?:-(".concat(src[t2.PRERELEASEIDENTIFIER], "(?:\\.").concat(src[t2.PRERELEASEIDENTIFIER], ")*))"));
  createToken("PRERELEASELOOSE", "(?:-?(".concat(src[t2.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(src[t2.PRERELEASEIDENTIFIERLOOSE], ")*))"));
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken("BUILD", "(?:\\+(".concat(src[t2.BUILDIDENTIFIER], "(?:\\.").concat(src[t2.BUILDIDENTIFIER], ")*))"));
  createToken("FULLPLAIN", "v?".concat(src[t2.MAINVERSION]).concat(src[t2.PRERELEASE], "?").concat(src[t2.BUILD], "?"));
  createToken("FULL", "^".concat(src[t2.FULLPLAIN], "$"));
  createToken("LOOSEPLAIN", "[v=\\s]*".concat(src[t2.MAINVERSIONLOOSE]).concat(src[t2.PRERELEASELOOSE], "?").concat(src[t2.BUILD], "?"));
  createToken("LOOSE", "^".concat(src[t2.LOOSEPLAIN], "$"));
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", "".concat(src[t2.NUMERICIDENTIFIERLOOSE], "|x|X|\\*"));
  createToken("XRANGEIDENTIFIER", "".concat(src[t2.NUMERICIDENTIFIER], "|x|X|\\*"));
  createToken("XRANGEPLAIN", "[v=\\s]*(".concat(src[t2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t2.XRANGEIDENTIFIER], ")") + "(?:".concat(src[t2.PRERELEASE], ")?").concat(src[t2.BUILD], "?") + ")?)?");
  createToken("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(src[t2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t2.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(src[t2.PRERELEASELOOSE], ")?").concat(src[t2.BUILD], "?") + ")?)?");
  createToken("XRANGE", "^".concat(src[t2.GTLT], "\\s*").concat(src[t2.XRANGEPLAIN], "$"));
  createToken("XRANGELOOSE", "^".concat(src[t2.GTLT], "\\s*").concat(src[t2.XRANGEPLAINLOOSE], "$"));
  createToken("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(MAX_SAFE_COMPONENT_LENGTH2, "})") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH2, "}))?") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH2, "}))?") + "(?:$|[^\\d])");
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", "(\\s*)".concat(src[t2.LONETILDE], "\\s+"), true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", "^".concat(src[t2.LONETILDE]).concat(src[t2.XRANGEPLAIN], "$"));
  createToken("TILDELOOSE", "^".concat(src[t2.LONETILDE]).concat(src[t2.XRANGEPLAINLOOSE], "$"));
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", "(\\s*)".concat(src[t2.LONECARET], "\\s+"), true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", "^".concat(src[t2.LONECARET]).concat(src[t2.XRANGEPLAIN], "$"));
  createToken("CARETLOOSE", "^".concat(src[t2.LONECARET]).concat(src[t2.XRANGEPLAINLOOSE], "$"));
  createToken("COMPARATORLOOSE", "^".concat(src[t2.GTLT], "\\s*(").concat(src[t2.LOOSEPLAIN], ")$|^$"));
  createToken("COMPARATOR", "^".concat(src[t2.GTLT], "\\s*(").concat(src[t2.FULLPLAIN], ")$|^$"));
  createToken("COMPARATORTRIM", "(\\s*)".concat(src[t2.GTLT], "\\s*(").concat(src[t2.LOOSEPLAIN], "|").concat(src[t2.XRANGEPLAIN], ")"), true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", "^\\s*(".concat(src[t2.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(src[t2.XRANGEPLAIN], ")") + "\\s*$");
  createToken("HYPHENRANGELOOSE", "^\\s*(".concat(src[t2.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(src[t2.XRANGEPLAINLOOSE], ")") + "\\s*$");
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
})(re$3, re$3.exports);
var numeric = /^[0-9]+$/;
var compareIdentifiers$1 = (a, b) => {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
var rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
var debug$2 = debug_1;
var MAX_LENGTH = constants.MAX_LENGTH;
var MAX_SAFE_INTEGER = constants.MAX_SAFE_INTEGER;
var re$2 = re$3.exports.re;
var t$2 = re$3.exports.t;
var parseOptions$2 = parseOptions_1;
var compareIdentifiers = identifiers.compareIdentifiers;
var SemVer$3 = class {
  constructor(version6, options) {
    options = parseOptions$2(options);
    if (version6 instanceof SemVer$3) {
      if (version6.loose === !!options.loose && version6.includePrerelease === !!options.includePrerelease) {
        return version6;
      } else {
        version6 = version6.version;
      }
    } else if (typeof version6 !== "string") {
      throw new TypeError("Invalid Version: ".concat(version6));
    }
    if (version6.length > MAX_LENGTH) {
      throw new TypeError("version is longer than ".concat(MAX_LENGTH, " characters"));
    }
    debug$2("SemVer", version6, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    var m = version6.trim().match(options.loose ? re$2[t$2.LOOSE] : re$2[t$2.FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: ".concat(version6));
    }
    this.raw = version6;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map((id) => {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch);
    if (this.prerelease.length) {
      this.version += "-".concat(this.prerelease.join("."));
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug$2("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer$3)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer$3(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer$3)) {
      other = new SemVer$3(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer$3)) {
      other = new SemVer$3(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i = 0;
    do {
      var a = this.prerelease[i];
      var b = other.prerelease[i];
      debug$2("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer$3)) {
      other = new SemVer$3(other, this.options);
    }
    var i = 0;
    do {
      var a = this.build[i];
      var b = other.build[i];
      debug$2("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  inc(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === "number") {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: ".concat(release));
    }
    this.format();
    this.raw = this.version;
    return this;
  }
};
var semver = SemVer$3;
var SemVer$2 = semver;
var compare$6 = (a, b, loose) => new SemVer$2(a, loose).compare(new SemVer$2(b, loose));
var compare_1 = compare$6;
var compare$5 = compare_1;
var eq$1 = (a, b, loose) => compare$5(a, b, loose) === 0;
var eq_1 = eq$1;
var compare$4 = compare_1;
var neq$1 = (a, b, loose) => compare$4(a, b, loose) !== 0;
var neq_1 = neq$1;
var compare$3 = compare_1;
var gt$1 = (a, b, loose) => compare$3(a, b, loose) > 0;
var gt_1 = gt$1;
var compare$2 = compare_1;
var gte$1 = (a, b, loose) => compare$2(a, b, loose) >= 0;
var gte_1 = gte$1;
var compare$1 = compare_1;
var lt$1 = (a, b, loose) => compare$1(a, b, loose) < 0;
var lt_1 = lt$1;
var compare2 = compare_1;
var lte$1 = (a, b, loose) => compare2(a, b, loose) <= 0;
var lte_1 = lte$1;
var eq = eq_1;
var neq = neq_1;
var gt = gt_1;
var gte = gte_1;
var lt = lt_1;
var lte = lte_1;
var cmp$1 = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object")
        a = a.version;
      if (typeof b === "object")
        b = b.version;
      return a === b;
    case "!==":
      if (typeof a === "object")
        a = a.version;
      if (typeof b === "object")
        b = b.version;
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq(a, b, loose);
    case "!=":
      return neq(a, b, loose);
    case ">":
      return gt(a, b, loose);
    case ">=":
      return gte(a, b, loose);
    case "<":
      return lt(a, b, loose);
    case "<=":
      return lte(a, b, loose);
    default:
      throw new TypeError("Invalid operator: ".concat(op));
  }
};
var cmp_1 = cmp$1;
var ANY = Symbol("SemVer ANY");
var Comparator$1 = class {
  static get ANY() {
    return ANY;
  }
  constructor(comp, options) {
    options = parseOptions$1(options);
    if (comp instanceof Comparator$1) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    debug$1("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug$1("comp", this);
  }
  parse(comp) {
    var r = this.options.loose ? re$1[t$1.COMPARATORLOOSE] : re$1[t$1.COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: ".concat(comp));
    }
    this.operator = m[1] !== void 0 ? m[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer$1(m[2], this.options.loose);
    }
  }
  toString() {
    return this.value;
  }
  test(version6) {
    debug$1("Comparator.test", version6, this.options.loose);
    if (this.semver === ANY || version6 === ANY) {
      return true;
    }
    if (typeof version6 === "string") {
      try {
        version6 = new SemVer$1(version6, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version6, this.operator, this.semver, this.options);
  }
  intersects(comp, options) {
    if (!(comp instanceof Comparator$1)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      return new Range$2(comp.value, options).test(this.value);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      return new Range$2(this.value, options).test(comp.semver);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  }
};
var comparator = Comparator$1;
var parseOptions$1 = parseOptions_1;
var re$1 = re$3.exports.re;
var t$1 = re$3.exports.t;
var cmp = cmp_1;
var debug$1 = debug_1;
var SemVer$1 = semver;
var Range$2 = range;
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var Range$1 = class {
  constructor(range2, options) {
    options = parseOptions(options);
    if (range2 instanceof Range$1) {
      if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
        return range2;
      } else {
        return new Range$1(range2.raw, options);
      }
    }
    if (range2 instanceof Comparator) {
      this.raw = range2.value;
      this.set = [[range2]];
      this.format();
      return this;
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range2;
    this.set = range2.split(/\s*\|\|\s*/).map((range3) => this.parseRange(range3.trim())).filter((c2) => c2.length);
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: ".concat(range2));
    }
    if (this.set.length > 1) {
      var first = this.set[0];
      this.set = this.set.filter((c2) => !isNullSet(c2[0]));
      if (this.set.length === 0)
        this.set = [first];
      else if (this.set.length > 1) {
        var _iterator = _createForOfIteratorHelper(this.set), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var c = _step.value;
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
    this.format();
  }
  format() {
    this.range = this.set.map((comps) => {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  }
  toString() {
    return this.range;
  }
  parseRange(range2) {
    range2 = range2.trim();
    var memoOpts = Object.keys(this.options).join(",");
    var memoKey = "parseRange:".concat(memoOpts, ":").concat(range2);
    var cached = cache.get(memoKey);
    if (cached)
      return cached;
    var loose = this.options.loose;
    var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
    range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
    debug2("hyphen replace", range2);
    range2 = range2.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
    debug2("comparator trim", range2, re[t.COMPARATORTRIM]);
    range2 = range2.replace(re[t.TILDETRIM], tildeTrimReplace);
    range2 = range2.replace(re[t.CARETTRIM], caretTrimReplace);
    range2 = range2.split(/\s+/).join(" ");
    var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    var rangeList = range2.split(" ").map((comp2) => parseComparator(comp2, this.options)).join(" ").split(/\s+/).map((comp2) => replaceGTE0(comp2, this.options)).filter(this.options.loose ? (comp2) => !!comp2.match(compRe) : () => true).map((comp2) => new Comparator(comp2, this.options));
    rangeList.length;
    var rangeMap = new Map();
    var _iterator2 = _createForOfIteratorHelper(rangeList), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var comp = _step2.value;
        if (isNullSet(comp))
          return [comp];
        rangeMap.set(comp.value, comp);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    if (rangeMap.size > 1 && rangeMap.has(""))
      rangeMap.delete("");
    var result = [...rangeMap.values()];
    cache.set(memoKey, result);
    return result;
  }
  intersects(range2, options) {
    if (!(range2 instanceof Range$1)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some((thisComparators) => {
      return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
        return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
          return rangeComparators.every((rangeComparator) => {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  }
  test(version6) {
    if (!version6) {
      return false;
    }
    if (typeof version6 === "string") {
      try {
        version6 = new SemVer(version6, this.options);
      } catch (er) {
        return false;
      }
    }
    for (var i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version6, this.options)) {
        return true;
      }
    }
    return false;
  }
};
var range = Range$1;
var LRU = lruCache;
var cache = new LRU({
  max: 1e3
});
var parseOptions = parseOptions_1;
var Comparator = comparator;
var debug2 = debug_1;
var SemVer = semver;
var re = re$3.exports.re;
var t = re$3.exports.t;
var comparatorTrimReplace = re$3.exports.comparatorTrimReplace;
var tildeTrimReplace = re$3.exports.tildeTrimReplace;
var caretTrimReplace = re$3.exports.caretTrimReplace;
var isNullSet = (c) => c.value === "<0.0.0-0";
var isAny = (c) => c.value === "";
var isSatisfiable = (comparators, options) => {
  var result = true;
  var remainingComparators = comparators.slice();
  var testComparator = remainingComparators.pop();
  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options);
    });
    testComparator = remainingComparators.pop();
  }
  return result;
};
var parseComparator = (comp, options) => {
  debug2("comp", comp, options);
  comp = replaceCarets(comp, options);
  debug2("caret", comp);
  comp = replaceTildes(comp, options);
  debug2("tildes", comp);
  comp = replaceXRanges(comp, options);
  debug2("xrange", comp);
  comp = replaceStars(comp, options);
  debug2("stars", comp);
  return comp;
};
var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
  return replaceTilde(comp2, options);
}).join(" ");
var replaceTilde = (comp, options) => {
  var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
  return comp.replace(r, (_, M, m, p, pr) => {
    debug2("tilde", comp, _, M, m, p, pr);
    var ret;
    if (isX(M)) {
      ret = "";
    } else if (isX(m)) {
      ret = ">=".concat(M, ".0.0 <").concat(+M + 1, ".0.0-0");
    } else if (isX(p)) {
      ret = ">=".concat(M, ".").concat(m, ".0 <").concat(M, ".").concat(+m + 1, ".0-0");
    } else if (pr) {
      debug2("replaceTilde pr", pr);
      ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
    } else {
      ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(M, ".").concat(+m + 1, ".0-0");
    }
    debug2("tilde return", ret);
    return ret;
  });
};
var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
  return replaceCaret(comp2, options);
}).join(" ");
var replaceCaret = (comp, options) => {
  debug2("caret", comp, options);
  var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
  var z = options.includePrerelease ? "-0" : "";
  return comp.replace(r, (_, M, m, p, pr) => {
    debug2("caret", comp, _, M, m, p, pr);
    var ret;
    if (isX(M)) {
      ret = "";
    } else if (isX(m)) {
      ret = ">=".concat(M, ".0.0").concat(z, " <").concat(+M + 1, ".0.0-0");
    } else if (isX(p)) {
      if (M === "0") {
        ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
      } else {
        ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(+M + 1, ".0.0-0");
      }
    } else if (pr) {
      debug2("replaceCaret pr", pr);
      if (M === "0") {
        if (m === "0") {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
        } else {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
        }
      } else {
        ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(+M + 1, ".0.0-0");
      }
    } else {
      debug2("no pr");
      if (M === "0") {
        if (m === "0") {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
        } else {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
        }
      } else {
        ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(+M + 1, ".0.0-0");
      }
    }
    debug2("caret return", ret);
    return ret;
  });
};
var replaceXRanges = (comp, options) => {
  debug2("replaceXRanges", comp, options);
  return comp.split(/\s+/).map((comp2) => {
    return replaceXRange(comp2, options);
  }).join(" ");
};
var replaceXRange = (comp, options) => {
  comp = comp.trim();
  var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug2("xRange", comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;
    if (gtlt === "=" && anyX) {
      gtlt = "";
    }
    pr = options.includePrerelease ? "-0" : "";
    if (xM) {
      if (gtlt === ">" || gtlt === "<") {
        ret = "<0.0.0-0";
      } else {
        ret = "*";
      }
    } else if (gtlt && anyX) {
      if (xm) {
        m = 0;
      }
      p = 0;
      if (gtlt === ">") {
        gtlt = ">=";
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === "<=") {
        gtlt = "<";
        if (xm) {
          M = +M + 1;
        } else {
          m = +m + 1;
        }
      }
      if (gtlt === "<")
        pr = "-0";
      ret = "".concat(gtlt + M, ".").concat(m, ".").concat(p).concat(pr);
    } else if (xm) {
      ret = ">=".concat(M, ".0.0").concat(pr, " <").concat(+M + 1, ".0.0-0");
    } else if (xp) {
      ret = ">=".concat(M, ".").concat(m, ".0").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
    }
    debug2("xRange return", ret);
    return ret;
  });
};
var replaceStars = (comp, options) => {
  debug2("replaceStars", comp, options);
  return comp.trim().replace(re[t.STAR], "");
};
var replaceGTE0 = (comp, options) => {
  debug2("replaceGTE0", comp, options);
  return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
};
var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = "";
  } else if (isX(fm)) {
    from = ">=".concat(fM, ".0.0").concat(incPr ? "-0" : "");
  } else if (isX(fp)) {
    from = ">=".concat(fM, ".").concat(fm, ".0").concat(incPr ? "-0" : "");
  } else if (fpr) {
    from = ">=".concat(from);
  } else {
    from = ">=".concat(from).concat(incPr ? "-0" : "");
  }
  if (isX(tM)) {
    to = "";
  } else if (isX(tm)) {
    to = "<".concat(+tM + 1, ".0.0-0");
  } else if (isX(tp)) {
    to = "<".concat(tM, ".").concat(+tm + 1, ".0-0");
  } else if (tpr) {
    to = "<=".concat(tM, ".").concat(tm, ".").concat(tp, "-").concat(tpr);
  } else if (incPr) {
    to = "<".concat(tM, ".").concat(tm, ".").concat(+tp + 1, "-0");
  } else {
    to = "<=".concat(to);
  }
  return "".concat(from, " ").concat(to).trim();
};
var testSet = (set2, version6, options) => {
  for (var i = 0; i < set2.length; i++) {
    if (!set2[i].test(version6)) {
      return false;
    }
  }
  if (version6.prerelease.length && !options.includePrerelease) {
    for (var _i = 0; _i < set2.length; _i++) {
      debug2(set2[_i].semver);
      if (set2[_i].semver === Comparator.ANY) {
        continue;
      }
      if (set2[_i].semver.prerelease.length > 0) {
        var allowed = set2[_i].semver;
        if (allowed.major === version6.major && allowed.minor === version6.minor && allowed.patch === version6.patch) {
          return true;
        }
      }
    }
    return false;
  }
  return true;
};
var Range = range;
var satisfies = (version6, range2, options) => {
  try {
    range2 = new Range(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version6);
};
var satisfies_1 = satisfies;
function post(window2, url, data) {
  var editor = window2.open(url);
  var wait = 1e4;
  var step = 250;
  var _URL = new URL(url), origin = _URL.origin;
  var count = ~~(wait / step);
  function listen(evt) {
    if (evt.source === editor) {
      count = 0;
      window2.removeEventListener("message", listen, false);
    }
  }
  window2.addEventListener("message", listen, false);
  function send() {
    if (count <= 0) {
      return;
    }
    editor.postMessage(data, origin);
    setTimeout(send, step);
    count -= 1;
  }
  setTimeout(send, step);
}
var embedStyle = '.vega-embed {\n  position: relative;\n  display: inline-block;\n  box-sizing: border-box;\n}\n.vega-embed.has-actions {\n  padding-right: 38px;\n}\n.vega-embed details:not([open]) > :not(summary) {\n  display: none !important;\n}\n.vega-embed summary {\n  list-style: none;\n  position: absolute;\n  top: 0;\n  right: 0;\n  padding: 6px;\n  z-index: 1000;\n  background: white;\n  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);\n  color: #1b1e23;\n  border: 1px solid #aaa;\n  border-radius: 999px;\n  opacity: 0.2;\n  transition: opacity 0.4s ease-in;\n  outline: none;\n  cursor: pointer;\n  line-height: 0px;\n}\n.vega-embed summary::-webkit-details-marker {\n  display: none;\n}\n.vega-embed summary:active {\n  box-shadow: #aaa 0px 0px 0px 1px inset;\n}\n.vega-embed summary svg {\n  width: 14px;\n  height: 14px;\n}\n.vega-embed details[open] summary {\n  opacity: 0.7;\n}\n.vega-embed:hover summary, .vega-embed:focus summary {\n  opacity: 1 !important;\n  transition: opacity 0.2s ease;\n}\n.vega-embed .vega-actions {\n  position: absolute;\n  z-index: 1001;\n  top: 35px;\n  right: -9px;\n  display: flex;\n  flex-direction: column;\n  padding-bottom: 8px;\n  padding-top: 8px;\n  border-radius: 4px;\n  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);\n  border: 1px solid #d9d9d9;\n  background: white;\n  animation-duration: 0.15s;\n  animation-name: scale-in;\n  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);\n  text-align: left;\n}\n.vega-embed .vega-actions a {\n  padding: 8px 16px;\n  font-family: sans-serif;\n  font-size: 14px;\n  font-weight: 600;\n  white-space: nowrap;\n  color: #434a56;\n  text-decoration: none;\n}\n.vega-embed .vega-actions a:hover {\n  background-color: #f7f7f9;\n  color: black;\n}\n.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {\n  content: "";\n  display: inline-block;\n  position: absolute;\n}\n.vega-embed .vega-actions::before {\n  left: auto;\n  right: 14px;\n  top: -16px;\n  border: 8px solid #0000;\n  border-bottom-color: #d9d9d9;\n}\n.vega-embed .vega-actions::after {\n  left: auto;\n  right: 15px;\n  top: -14px;\n  border: 7px solid #0000;\n  border-bottom-color: #fff;\n}\n.vega-embed .chart-wrapper.fit-x {\n  width: 100%;\n}\n.vega-embed .chart-wrapper.fit-y {\n  height: 100%;\n}\n\n.vega-embed-wrapper {\n  max-width: 100%;\n  overflow: auto;\n  padding-right: 14px;\n}\n\n@keyframes scale-in {\n  from {\n    opacity: 0;\n    transform: scale(0.6);\n  }\n  to {\n    opacity: 1;\n    transform: scale(1);\n  }\n}\n';
if (!String.prototype.startsWith) {
  String.prototype.startsWith = function(search, pos) {
    return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  };
}
function mergeDeep2(dest) {
  for (var _len = arguments.length, src = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    src[_key - 1] = arguments[_key];
  }
  for (var _i = 0, _src = src; _i < _src.length; _i++) {
    var s = _src[_i];
    deepMerge_(dest, s);
  }
  return dest;
}
function deepMerge_(dest, src) {
  for (var _i2 = 0, _Object$keys = Object.keys(src); _i2 < _Object$keys.length; _i2++) {
    var property = _Object$keys[_i2];
    writeConfig(dest, property, src[property], true);
  }
}
var name4 = "vega-embed";
var version$13 = "6.20.2";
var description5 = "Publish Vega visualizations as embedded web components.";
var keywords4 = ["vega", "data", "visualization", "component", "embed"];
var repository4 = {
  type: "git",
  url: "http://github.com/vega/vega-embed.git"
};
var author4 = {
  name: "UW Interactive Data Lab",
  url: "http://idl.cs.washington.edu"
};
var contributors2 = [{
  name: "Dominik Moritz",
  url: "https://www.domoritz.de"
}];
var bugs3 = {
  url: "https://github.com/vega/vega-embed/issues"
};
var homepage3 = "https://github.com/vega/vega-embed#readme";
var license4 = "BSD-3-Clause";
var main4 = "build/vega-embed.js";
var module4 = "build/vega-embed.module.js";
var unpkg4 = "build/vega-embed.min.js";
var jsdelivr4 = "build/vega-embed.min.js";
var types4 = "build/vega-embed.module.d.ts";
var files4 = ["src", "build", "build-es5"];
var devDependencies4 = {
  "@auto-it/conventional-commits": "^10.32.2",
  "@auto-it/first-time-contributor": "^10.32.2",
  "@rollup/plugin-commonjs": "21.0.1",
  "@rollup/plugin-json": "^4.1.0",
  "@rollup/plugin-node-resolve": "^13.0.6",
  "@types/semver": "^7.3.9",
  "rollup-plugin-ts": "^1.4.7",
  auto: "^10.32.2",
  "browser-sync": "^2.27.7",
  concurrently: "^6.4.0",
  "del-cli": "^4.0.1",
  "jest-canvas-mock": "^2.3.1",
  sass: "^1.43.4",
  "rollup-plugin-bundle-size": "^1.0.3",
  "rollup-plugin-terser": "^7.0.2",
  rollup: "2.60.0",
  typescript: "^4.4.4",
  "vega-lite-dev-config": "^0.20.0",
  "vega-lite": "^5.0.0",
  vega: "^5.21.0"
};
var peerDependencies3 = {
  vega: "^5.20.2",
  "vega-lite": "*"
};
var dependencies3 = {
  "fast-json-patch": "^3.1.0",
  "json-stringify-pretty-compact": "^3.0.0",
  semver: "^7.3.5",
  tslib: "^2.3.1",
  "vega-interpreter": "^1.0.4",
  "vega-schema-url-parser": "^2.2.0",
  "vega-themes": "^2.10.0",
  "vega-tooltip": "^0.27.0"
};
var scripts4 = {
  prebuild: "yarn clean && yarn build:style",
  build: "rollup -c",
  "build:style": "./build-style.sh",
  clean: "del-cli build build-es5 src/style.ts",
  prepublishOnly: "yarn clean && yarn build",
  preversion: "yarn lint && yarn test",
  serve: "browser-sync start --directory -s -f build *.html",
  start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
  pretest: "yarn build:style",
  test: "beemo jest --stdio stream",
  "test:inspect": "node --inspect-brk ./node_modules/.bin/jest --runInBand",
  prepare: "beemo create-config",
  prettierbase: "beemo prettier '*.{css,scss,html}'",
  eslintbase: "beemo eslint .",
  format: "yarn eslintbase --fix && yarn prettierbase --write",
  lint: "yarn eslintbase && yarn prettierbase --check",
  release: "auto shipit"
};
var pkg3 = {
  name: name4,
  version: version$13,
  description: description5,
  keywords: keywords4,
  repository: repository4,
  author: author4,
  contributors: contributors2,
  bugs: bugs3,
  homepage: homepage3,
  license: license4,
  main: main4,
  module: module4,
  unpkg: unpkg4,
  jsdelivr: jsdelivr4,
  types: types4,
  files: files4,
  devDependencies: devDependencies4,
  peerDependencies: peerDependencies3,
  dependencies: dependencies3,
  scripts: scripts4
};
var _w$vl;
function ownKeys(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols2);
  }
  return keys3;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source2 = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source2), true).forEach(function(key) {
        _defineProperty(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
var version5 = pkg3.version;
var vega = vega_module_exports;
var _vegaLite = src_exports;
var w = typeof window !== "undefined" ? window : void 0;
if (_vegaLite === void 0 && w !== null && w !== void 0 && (_w$vl = w.vl) !== null && _w$vl !== void 0 && _w$vl.compile) {
  _vegaLite = w.vl;
}
var DEFAULT_ACTIONS = {
  export: {
    svg: true,
    png: true
  },
  source: true,
  compiled: true,
  editor: true
};
var I18N = {
  CLICK_TO_VIEW_ACTIONS: "Click to view actions",
  COMPILED_ACTION: "View Compiled Vega",
  EDITOR_ACTION: "Open in Vega Editor",
  PNG_ACTION: "Save as PNG",
  SOURCE_ACTION: "View Source",
  SVG_ACTION: "Save as SVG"
};
var NAMES = {
  vega: "Vega",
  "vega-lite": "Vega-Lite"
};
var VERSION = {
  vega: vega.version,
  "vega-lite": _vegaLite ? _vegaLite.version : "not available"
};
var PREPROCESSOR = {
  vega: (vgSpec) => vgSpec,
  "vega-lite": (vlSpec, config) => _vegaLite.compile(vlSpec, {
    config
  }).spec
};
var SVG_CIRCLES = '\n<svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">\n  <circle r="2" cy="8" cx="2"></circle>\n  <circle r="2" cy="8" cx="8"></circle>\n  <circle r="2" cy="8" cx="14"></circle>\n</svg>';
var CHART_WRAPPER_CLASS = "chart-wrapper";
function isTooltipHandler(h) {
  return typeof h === "function";
}
function viewSource(source2, sourceHeader, sourceFooter, mode) {
  var header = "<html><head>".concat(sourceHeader, '</head><body><pre><code class="json">');
  var footer = "</code></pre>".concat(sourceFooter, "</body></html>");
  var win = window.open("");
  win.document.write(header + source2 + footer);
  win.document.title = "".concat(NAMES[mode], " JSON Source");
}
function guessMode(spec, providedMode) {
  if (spec.$schema) {
    var parsed = parser_module_default(spec.$schema);
    if (providedMode && providedMode !== parsed.library) {
      var _NAMES$providedMode;
      console.warn("The given visualization spec is written in ".concat(NAMES[parsed.library], ", but mode argument sets ").concat((_NAMES$providedMode = NAMES[providedMode]) !== null && _NAMES$providedMode !== void 0 ? _NAMES$providedMode : providedMode, "."));
    }
    var mode = parsed.library;
    if (!satisfies_1(VERSION[mode], "^".concat(parsed.version.slice(1)))) {
      console.warn("The input spec uses ".concat(NAMES[mode], " ").concat(parsed.version, ", but the current version of ").concat(NAMES[mode], " is v").concat(VERSION[mode], "."));
    }
    return mode;
  }
  if ("mark" in spec || "encoding" in spec || "layer" in spec || "hconcat" in spec || "vconcat" in spec || "facet" in spec || "repeat" in spec) {
    return "vega-lite";
  }
  if ("marks" in spec || "signals" in spec || "scales" in spec || "axes" in spec) {
    return "vega";
  }
  return providedMode !== null && providedMode !== void 0 ? providedMode : "vega";
}
function isLoader(o) {
  return !!(o && "load" in o);
}
function createLoader(opts2) {
  return isLoader(opts2) ? opts2 : vega.loader(opts2);
}
function embedOptionsFromUsermeta(parsedSpec) {
  var _ref;
  return (_ref = parsedSpec.usermeta && parsedSpec.usermeta.embedOptions) !== null && _ref !== void 0 ? _ref : {};
}
function embed(_x, _x2) {
  return _embed2.apply(this, arguments);
}
function _embed2() {
  _embed2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(el, spec) {
    var _parsedOpts$config, _usermetaOpts$config;
    var opts2, parsedSpec, loader, usermetaLoader, _opts$loader, usermetaOpts, parsedOpts, mergedOpts, _args = arguments;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            opts2 = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
            if (!isString(spec)) {
              _context.next = 10;
              break;
            }
            loader = createLoader(opts2.loader);
            _context.t0 = JSON;
            _context.next = 6;
            return loader.load(spec);
          case 6:
            _context.t1 = _context.sent;
            parsedSpec = _context.t0.parse.call(_context.t0, _context.t1);
            _context.next = 11;
            break;
          case 10:
            parsedSpec = spec;
          case 11:
            usermetaLoader = embedOptionsFromUsermeta(parsedSpec).loader;
            if (!loader || usermetaLoader) {
              loader = createLoader((_opts$loader = opts2.loader) !== null && _opts$loader !== void 0 ? _opts$loader : usermetaLoader);
            }
            _context.next = 15;
            return loadOpts(embedOptionsFromUsermeta(parsedSpec), loader);
          case 15:
            usermetaOpts = _context.sent;
            _context.next = 18;
            return loadOpts(opts2, loader);
          case 18:
            parsedOpts = _context.sent;
            mergedOpts = _objectSpread(_objectSpread({}, mergeDeep2(parsedOpts, usermetaOpts)), {}, {
              config: mergeConfig((_parsedOpts$config = parsedOpts.config) !== null && _parsedOpts$config !== void 0 ? _parsedOpts$config : {}, (_usermetaOpts$config = usermetaOpts.config) !== null && _usermetaOpts$config !== void 0 ? _usermetaOpts$config : {})
            });
            _context.next = 22;
            return _embed(el, parsedSpec, mergedOpts, loader);
          case 22:
            return _context.abrupt("return", _context.sent);
          case 23:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _embed2.apply(this, arguments);
}
function loadOpts(_x3, _x4) {
  return _loadOpts.apply(this, arguments);
}
function _loadOpts() {
  _loadOpts = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(opt, loader) {
    var _opt$config;
    var config, patch;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!isString(opt.config)) {
              _context2.next = 8;
              break;
            }
            _context2.t1 = JSON;
            _context2.next = 4;
            return loader.load(opt.config);
          case 4:
            _context2.t2 = _context2.sent;
            _context2.t0 = _context2.t1.parse.call(_context2.t1, _context2.t2);
            _context2.next = 9;
            break;
          case 8:
            _context2.t0 = (_opt$config = opt.config) !== null && _opt$config !== void 0 ? _opt$config : {};
          case 9:
            config = _context2.t0;
            if (!isString(opt.patch)) {
              _context2.next = 18;
              break;
            }
            _context2.t4 = JSON;
            _context2.next = 14;
            return loader.load(opt.patch);
          case 14:
            _context2.t5 = _context2.sent;
            _context2.t3 = _context2.t4.parse.call(_context2.t4, _context2.t5);
            _context2.next = 19;
            break;
          case 18:
            _context2.t3 = opt.patch;
          case 19:
            patch = _context2.t3;
            return _context2.abrupt("return", _objectSpread(_objectSpread(_objectSpread({}, opt), patch ? {
              patch
            } : {}), config ? {
              config
            } : {}));
          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _loadOpts.apply(this, arguments);
}
function getRoot(el) {
  var _document$head;
  var possibleRoot = el.getRootNode ? el.getRootNode() : document;
  return possibleRoot instanceof ShadowRoot ? {
    root: possibleRoot,
    rootContainer: possibleRoot
  } : {
    root: document,
    rootContainer: (_document$head = document.head) !== null && _document$head !== void 0 ? _document$head : document.body
  };
}
function _embed(_x5, _x6) {
  return _embed3.apply(this, arguments);
}
function _embed3() {
  _embed3 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee4(el, spec) {
    var _opts$config, _opts$actions, _opts$renderer, _opts$logLevel, _opts$downloadFileNam, _ref2, _vega$expressionInter;
    var opts2, loader, config, actions, i18n, renderer, logLevel, downloadFileName, element, ID, _getRoot, root, rootContainer, style, mode, vgSpec, parsed, container, chartWrapper, patch, ast, runtime, view, handler, hover, _ref3, hoverSet, updateSet, documentClickHandler, wrapper, details, summary, ctrl, _loop, _i, _arr, viewSourceLink, compileLink, _opts$editorUrl, editorUrl, editorLink, finalize, _args4 = arguments;
    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            finalize = function _finalize() {
              if (documentClickHandler) {
                document.removeEventListener("click", documentClickHandler);
              }
              view.finalize();
            };
            opts2 = _args4.length > 2 && _args4[2] !== void 0 ? _args4[2] : {};
            loader = _args4.length > 3 ? _args4[3] : void 0;
            config = opts2.theme ? mergeConfig(vega_themes_module_exports[opts2.theme], (_opts$config = opts2.config) !== null && _opts$config !== void 0 ? _opts$config : {}) : opts2.config;
            actions = isBoolean(opts2.actions) ? opts2.actions : mergeDeep2({}, DEFAULT_ACTIONS, (_opts$actions = opts2.actions) !== null && _opts$actions !== void 0 ? _opts$actions : {});
            i18n = _objectSpread(_objectSpread({}, I18N), opts2.i18n);
            renderer = (_opts$renderer = opts2.renderer) !== null && _opts$renderer !== void 0 ? _opts$renderer : "canvas";
            logLevel = (_opts$logLevel = opts2.logLevel) !== null && _opts$logLevel !== void 0 ? _opts$logLevel : vega.Warn;
            downloadFileName = (_opts$downloadFileNam = opts2.downloadFileName) !== null && _opts$downloadFileNam !== void 0 ? _opts$downloadFileNam : "visualization";
            element = typeof el === "string" ? document.querySelector(el) : el;
            if (element) {
              _context4.next = 12;
              break;
            }
            throw new Error("".concat(el, " does not exist"));
          case 12:
            if (opts2.defaultStyle !== false) {
              ID = "vega-embed-style";
              _getRoot = getRoot(element), root = _getRoot.root, rootContainer = _getRoot.rootContainer;
              if (!root.getElementById(ID)) {
                style = document.createElement("style");
                style.id = ID;
                style.innerText = opts2.defaultStyle === void 0 || opts2.defaultStyle === true ? embedStyle.toString() : opts2.defaultStyle;
                rootContainer.appendChild(style);
              }
            }
            mode = guessMode(spec, opts2.mode);
            vgSpec = PREPROCESSOR[mode](spec, config);
            if (mode === "vega-lite") {
              if (vgSpec.$schema) {
                parsed = parser_module_default(vgSpec.$schema);
                if (!satisfies_1(VERSION.vega, "^".concat(parsed.version.slice(1)))) {
                  console.warn("The compiled spec uses Vega ".concat(parsed.version, ", but current version is v").concat(VERSION.vega, "."));
                }
              }
            }
            element.classList.add("vega-embed");
            if (actions) {
              element.classList.add("has-actions");
            }
            element.innerHTML = "";
            container = element;
            if (actions) {
              chartWrapper = document.createElement("div");
              chartWrapper.classList.add(CHART_WRAPPER_CLASS);
              element.appendChild(chartWrapper);
              container = chartWrapper;
            }
            patch = opts2.patch;
            if (patch) {
              vgSpec = patch instanceof Function ? patch(vgSpec) : applyPatch(vgSpec, patch, true, false).newDocument;
            }
            if (opts2.formatLocale) {
              vega.formatLocale(opts2.formatLocale);
            }
            if (opts2.timeFormatLocale) {
              vega.timeFormatLocale(opts2.timeFormatLocale);
            }
            ast = opts2.ast;
            runtime = vega.parse(vgSpec, mode === "vega-lite" ? {} : config, {
              ast
            });
            view = new (opts2.viewClass || vega.View)(runtime, _objectSpread({
              loader,
              logLevel,
              renderer
            }, ast ? {
              expr: (_ref2 = (_vega$expressionInter = vega.expressionInterpreter) !== null && _vega$expressionInter !== void 0 ? _vega$expressionInter : opts2.expr) !== null && _ref2 !== void 0 ? _ref2 : expression
            } : {}));
            view.addSignalListener("autosize", (_, autosize) => {
              var type = autosize.type;
              if (type == "fit-x") {
                container.classList.add("fit-x");
                container.classList.remove("fit-y");
              } else if (type == "fit-y") {
                container.classList.remove("fit-x");
                container.classList.add("fit-y");
              } else if (type == "fit") {
                container.classList.add("fit-x", "fit-y");
              } else {
                container.classList.remove("fit-x", "fit-y");
              }
            });
            if (opts2.tooltip !== false) {
              handler = isTooltipHandler(opts2.tooltip) ? opts2.tooltip : new Handler(opts2.tooltip === true ? {} : opts2.tooltip).call;
              view.tooltip(handler);
            }
            hover = opts2.hover;
            if (hover === void 0) {
              hover = mode === "vega";
            }
            if (hover) {
              _ref3 = typeof hover === "boolean" ? {} : hover, hoverSet = _ref3.hoverSet, updateSet = _ref3.updateSet;
              view.hover(hoverSet, updateSet);
            }
            if (opts2) {
              if (opts2.width != null) {
                view.width(opts2.width);
              }
              if (opts2.height != null) {
                view.height(opts2.height);
              }
              if (opts2.padding != null) {
                view.padding(opts2.padding);
              }
            }
            _context4.next = 36;
            return view.initialize(container, opts2.bind).runAsync();
          case 36:
            if (actions !== false) {
              wrapper = element;
              if (opts2.defaultStyle !== false) {
                details = document.createElement("details");
                details.title = i18n.CLICK_TO_VIEW_ACTIONS;
                element.append(details);
                wrapper = details;
                summary = document.createElement("summary");
                summary.innerHTML = SVG_CIRCLES;
                details.append(summary);
                documentClickHandler = (ev) => {
                  if (!details.contains(ev.target)) {
                    details.removeAttribute("open");
                  }
                };
                document.addEventListener("click", documentClickHandler);
              }
              ctrl = document.createElement("div");
              wrapper.append(ctrl);
              ctrl.classList.add("vega-actions");
              if (actions === true || actions.export !== false) {
                _loop = function _loop2() {
                  var ext = _arr[_i];
                  if (actions === true || actions.export === true || actions.export[ext]) {
                    var i18nExportAction = i18n["".concat(ext.toUpperCase(), "_ACTION")];
                    var exportLink = document.createElement("a");
                    exportLink.text = i18nExportAction;
                    exportLink.href = "#";
                    exportLink.target = "_blank";
                    exportLink.download = "".concat(downloadFileName, ".").concat(ext);
                    exportLink.addEventListener("mousedown", function() {
                      var _ref4 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(e2) {
                        var url;
                        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                          while (1) {
                            switch (_context3.prev = _context3.next) {
                              case 0:
                                e2.preventDefault();
                                _context3.next = 3;
                                return view.toImageURL(ext, opts2.scaleFactor);
                              case 3:
                                url = _context3.sent;
                                this.href = url;
                              case 5:
                              case "end":
                                return _context3.stop();
                            }
                          }
                        }, _callee3, this);
                      }));
                      return function(_x7) {
                        return _ref4.apply(this, arguments);
                      };
                    }());
                    ctrl.append(exportLink);
                  }
                };
                for (_i = 0, _arr = ["svg", "png"]; _i < _arr.length; _i++) {
                  _loop();
                }
              }
              if (actions === true || actions.source !== false) {
                viewSourceLink = document.createElement("a");
                viewSourceLink.text = i18n.SOURCE_ACTION;
                viewSourceLink.href = "#";
                viewSourceLink.addEventListener("click", function(e2) {
                  var _opts$sourceHeader, _opts$sourceFooter;
                  viewSource((0, import_json_stringify_pretty_compact.default)(spec), (_opts$sourceHeader = opts2.sourceHeader) !== null && _opts$sourceHeader !== void 0 ? _opts$sourceHeader : "", (_opts$sourceFooter = opts2.sourceFooter) !== null && _opts$sourceFooter !== void 0 ? _opts$sourceFooter : "", mode);
                  e2.preventDefault();
                });
                ctrl.append(viewSourceLink);
              }
              if (mode === "vega-lite" && (actions === true || actions.compiled !== false)) {
                compileLink = document.createElement("a");
                compileLink.text = i18n.COMPILED_ACTION;
                compileLink.href = "#";
                compileLink.addEventListener("click", function(e2) {
                  var _opts$sourceHeader2, _opts$sourceFooter2;
                  viewSource((0, import_json_stringify_pretty_compact.default)(vgSpec), (_opts$sourceHeader2 = opts2.sourceHeader) !== null && _opts$sourceHeader2 !== void 0 ? _opts$sourceHeader2 : "", (_opts$sourceFooter2 = opts2.sourceFooter) !== null && _opts$sourceFooter2 !== void 0 ? _opts$sourceFooter2 : "", "vega");
                  e2.preventDefault();
                });
                ctrl.append(compileLink);
              }
              if (actions === true || actions.editor !== false) {
                editorUrl = (_opts$editorUrl = opts2.editorUrl) !== null && _opts$editorUrl !== void 0 ? _opts$editorUrl : "https://vega.github.io/editor/";
                editorLink = document.createElement("a");
                editorLink.text = i18n.EDITOR_ACTION;
                editorLink.href = "#";
                editorLink.addEventListener("click", function(e2) {
                  post(window, editorUrl, {
                    config,
                    mode,
                    renderer,
                    spec: (0, import_json_stringify_pretty_compact.default)(spec)
                  });
                  e2.preventDefault();
                });
                ctrl.append(editorLink);
              }
            }
            return _context4.abrupt("return", {
              view,
              spec,
              vgSpec,
              finalize
            });
          case 38:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _embed3.apply(this, arguments);
}

// dep:vega-embed
var vega_embed_default = embed;
export {
  DEFAULT_ACTIONS,
  vega_embed_default as default,
  guessMode,
  vega,
  _vegaLite as vegaLite,
  version5 as version
};
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017 Joachim Wester
 * MIT license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=vega-embed.js.map
